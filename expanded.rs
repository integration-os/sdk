#![feature(prelude_import)]
#![deny(clippy::all)]
#![allow(dead_code)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::sync::Arc;
use anyhow::{anyhow, bail};
use reqwest::RequestBuilder;
use serde::Deserialize;
use url::{ParseError, Url};
#[macro_use]
extern crate napi_derive;
#[macro_use]
extern crate macros;
mod options {
    use std::collections::HashMap;
    use serde::Serialize;
    pub(crate) struct IntegrationOSOptions {
        pub server_url: String,
    }
    impl napi::bindgen_prelude::TypeName for IntegrationOSOptions {
        fn type_name() -> &'static str {
            "IntegrationOSOptions"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for IntegrationOSOptions {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: IntegrationOSOptions,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self { server_url: server_url_ } = val;
            obj.set("serverUrl", server_url_)?;
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for IntegrationOSOptions {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let server_url_: String = obj
                .get("serverUrl")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "serverUrl"),
                        );
                        res
                    },
                ))?;
            let val = Self { server_url: server_url_ };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for IntegrationOSOptions {}
    pub(crate) struct UnifiedOptions {
        pub response_passthrough: Option<bool>,
        pub passthrough_headers: Option<HashMap<String, String>>,
        pub passthrough_query: Option<HashMap<String, String>>,
    }
    impl napi::bindgen_prelude::TypeName for UnifiedOptions {
        fn type_name() -> &'static str {
            "UnifiedOptions"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for UnifiedOptions {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: UnifiedOptions,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self {
                response_passthrough: response_passthrough_,
                passthrough_headers: passthrough_headers_,
                passthrough_query: passthrough_query_,
            } = val;
            if response_passthrough_.is_some() {
                obj.set("responsePassthrough", response_passthrough_)?;
            }
            if passthrough_headers_.is_some() {
                obj.set("passthroughHeaders", passthrough_headers_)?;
            }
            if passthrough_query_.is_some() {
                obj.set("passthroughQuery", passthrough_query_)?;
            }
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for UnifiedOptions {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let response_passthrough_: Option<bool> = obj.get("responsePassthrough")?;
            let passthrough_headers_: Option<HashMap<String, String>> = obj
                .get("passthroughHeaders")?;
            let passthrough_query_: Option<HashMap<String, String>> = obj
                .get("passthroughQuery")?;
            let val = Self {
                response_passthrough: response_passthrough_,
                passthrough_headers: passthrough_headers_,
                passthrough_query: passthrough_query_,
            };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for UnifiedOptions {}
    pub(crate) struct DeleteOptions {
        pub modify_token: Option<String>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DeleteOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DeleteOptions",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "modify_token",
                    &self.modify_token,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl napi::bindgen_prelude::TypeName for DeleteOptions {
        fn type_name() -> &'static str {
            "DeleteOptions"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for DeleteOptions {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: DeleteOptions,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self { modify_token: modify_token_ } = val;
            if modify_token_.is_some() {
                obj.set("modifyToken", modify_token_)?;
            }
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for DeleteOptions {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let modify_token_: Option<String> = obj.get("modifyToken")?;
            let val = Self {
                modify_token: modify_token_,
            };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for DeleteOptions {}
}
mod responses {
    use std::collections::HashMap;
    use serde::{Deserialize, Serialize};
    pub(crate) struct Response {
        pub unified: Option<serde_json::Value>,
        pub passthrough: Option<serde_json::Value>,
        pub meta: serde_json::Value,
        pub headers: HashMap<String, String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Response {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Response",
                "unified",
                &self.unified,
                "passthrough",
                &self.passthrough,
                "meta",
                &self.meta,
                "headers",
                &&self.headers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Response {
        #[inline]
        fn clone(&self) -> Response {
            Response {
                unified: ::core::clone::Clone::clone(&self.unified),
                passthrough: ::core::clone::Clone::clone(&self.passthrough),
                meta: ::core::clone::Clone::clone(&self.meta),
                headers: ::core::clone::Clone::clone(&self.headers),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Response {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Response",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "unified",
                    &self.unified,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "passthrough",
                    &self.passthrough,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "meta",
                    &self.meta,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headers",
                    &self.headers,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Response {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "unified" => _serde::__private::Ok(__Field::__field0),
                            "passthrough" => _serde::__private::Ok(__Field::__field1),
                            "meta" => _serde::__private::Ok(__Field::__field2),
                            "headers" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"unified" => _serde::__private::Ok(__Field::__field0),
                            b"passthrough" => _serde::__private::Ok(__Field::__field1),
                            b"meta" => _serde::__private::Ok(__Field::__field2),
                            b"headers" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Response>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Response;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Response",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<serde_json::Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Response with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<serde_json::Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Response with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            serde_json::Value,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Response with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            HashMap<String, String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Response with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Response {
                            unified: __field0,
                            passthrough: __field1,
                            meta: __field2,
                            headers: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<serde_json::Value>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<serde_json::Value>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<serde_json::Value> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            HashMap<String, String>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "unified",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<serde_json::Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "passthrough",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<serde_json::Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("meta"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            serde_json::Value,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headers",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            HashMap<String, String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("unified")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("passthrough")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("meta")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headers")?
                            }
                        };
                        _serde::__private::Ok(Response {
                            unified: __field0,
                            passthrough: __field1,
                            meta: __field2,
                            headers: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "unified",
                    "passthrough",
                    "meta",
                    "headers",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Response",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Response>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl napi::bindgen_prelude::TypeName for Response {
        fn type_name() -> &'static str {
            "Response"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for Response {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: Response,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self {
                unified: unified_,
                passthrough: passthrough_,
                meta: meta_,
                headers: headers_,
            } = val;
            if unified_.is_some() {
                obj.set("unified", unified_)?;
            }
            if passthrough_.is_some() {
                obj.set("passthrough", passthrough_)?;
            }
            obj.set("meta", meta_)?;
            obj.set("headers", headers_)?;
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for Response {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let unified_: Option<serde_json::Value> = obj.get("unified")?;
            let passthrough_: Option<serde_json::Value> = obj.get("passthrough")?;
            let meta_: serde_json::Value = obj
                .get("meta")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "meta"),
                        );
                        res
                    },
                ))?;
            let headers_: HashMap<String, String> = obj
                .get("headers")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "headers"),
                        );
                        res
                    },
                ))?;
            let val = Self {
                unified: unified_,
                passthrough: passthrough_,
                meta: meta_,
                headers: headers_,
            };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for Response {}
    pub(crate) struct Count {
        pub count: u32,
    }
    impl napi::bindgen_prelude::TypeName for Count {
        fn type_name() -> &'static str {
            "Count"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for Count {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: Count,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self { count: count_ } = val;
            obj.set("count", count_)?;
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for Count {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let count_: u32 = obj
                .get("count")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "count"),
                        );
                        res
                    },
                ))?;
            let val = Self { count: count_ };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for Count {}
    pub(crate) struct Pagination {
        pub limit: Option<u32>,
        pub page_size: u32,
        pub next_cursor: Option<String>,
        pub previous_cursor: Option<String>,
    }
    impl napi::bindgen_prelude::TypeName for Pagination {
        fn type_name() -> &'static str {
            "Pagination"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for Pagination {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: Pagination,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self {
                limit: limit_,
                page_size: page_size_,
                next_cursor: next_cursor_,
                previous_cursor: previous_cursor_,
            } = val;
            if limit_.is_some() {
                obj.set("limit", limit_)?;
            }
            obj.set("pageSize", page_size_)?;
            if next_cursor_.is_some() {
                obj.set("nextCursor", next_cursor_)?;
            }
            if previous_cursor_.is_some() {
                obj.set("previousCursor", previous_cursor_)?;
            }
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for Pagination {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let limit_: Option<u32> = obj.get("limit")?;
            let page_size_: u32 = obj
                .get("pageSize")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "pageSize"),
                        );
                        res
                    },
                ))?;
            let next_cursor_: Option<String> = obj.get("nextCursor")?;
            let previous_cursor_: Option<String> = obj.get("previousCursor")?;
            let val = Self {
                limit: limit_,
                page_size: page_size_,
                next_cursor: next_cursor_,
                previous_cursor: previous_cursor_,
            };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for Pagination {}
    pub(crate) struct ListResponse {
        pub unified: serde_json::Value,
        pub passthrough: Option<serde_json::Value>,
        pub pagination: serde_json::Value,
        pub meta: serde_json::Value,
        pub headers: HashMap<String, String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ListResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ListResponse",
                "unified",
                &self.unified,
                "passthrough",
                &self.passthrough,
                "pagination",
                &self.pagination,
                "meta",
                &self.meta,
                "headers",
                &&self.headers,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ListResponse {
        #[inline]
        fn clone(&self) -> ListResponse {
            ListResponse {
                unified: ::core::clone::Clone::clone(&self.unified),
                passthrough: ::core::clone::Clone::clone(&self.passthrough),
                pagination: ::core::clone::Clone::clone(&self.pagination),
                meta: ::core::clone::Clone::clone(&self.meta),
                headers: ::core::clone::Clone::clone(&self.headers),
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListResponse",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "unified",
                    &self.unified,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "passthrough",
                    &self.passthrough,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pagination",
                    &self.pagination,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "meta",
                    &self.meta,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headers",
                    &self.headers,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ListResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "unified" => _serde::__private::Ok(__Field::__field0),
                            "passthrough" => _serde::__private::Ok(__Field::__field1),
                            "pagination" => _serde::__private::Ok(__Field::__field2),
                            "meta" => _serde::__private::Ok(__Field::__field3),
                            "headers" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"unified" => _serde::__private::Ok(__Field::__field0),
                            b"passthrough" => _serde::__private::Ok(__Field::__field1),
                            b"pagination" => _serde::__private::Ok(__Field::__field2),
                            b"meta" => _serde::__private::Ok(__Field::__field3),
                            b"headers" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ListResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ListResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ListResponse",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            serde_json::Value,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ListResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<serde_json::Value>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ListResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            serde_json::Value,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ListResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            serde_json::Value,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ListResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            HashMap<String, String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ListResponse with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ListResponse {
                            unified: __field0,
                            passthrough: __field1,
                            pagination: __field2,
                            meta: __field3,
                            headers: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<serde_json::Value> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<serde_json::Value>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<serde_json::Value> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<serde_json::Value> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            HashMap<String, String>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "unified",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            serde_json::Value,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "passthrough",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<serde_json::Value>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pagination",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            serde_json::Value,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("meta"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            serde_json::Value,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headers",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            HashMap<String, String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("unified")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("passthrough")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pagination")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("meta")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headers")?
                            }
                        };
                        _serde::__private::Ok(ListResponse {
                            unified: __field0,
                            passthrough: __field1,
                            pagination: __field2,
                            meta: __field3,
                            headers: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "unified",
                    "passthrough",
                    "pagination",
                    "meta",
                    "headers",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ListResponse",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ListResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl napi::bindgen_prelude::TypeName for ListResponse {
        fn type_name() -> &'static str {
            "ListResponse"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for ListResponse {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: ListResponse,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self {
                unified: unified_,
                passthrough: passthrough_,
                pagination: pagination_,
                meta: meta_,
                headers: headers_,
            } = val;
            obj.set("unified", unified_)?;
            if passthrough_.is_some() {
                obj.set("passthrough", passthrough_)?;
            }
            obj.set("pagination", pagination_)?;
            obj.set("meta", meta_)?;
            obj.set("headers", headers_)?;
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for ListResponse {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let unified_: serde_json::Value = obj
                .get("unified")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "unified"),
                        );
                        res
                    },
                ))?;
            let passthrough_: Option<serde_json::Value> = obj.get("passthrough")?;
            let pagination_: serde_json::Value = obj
                .get("pagination")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "pagination"),
                        );
                        res
                    },
                ))?;
            let meta_: serde_json::Value = obj
                .get("meta")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "meta"),
                        );
                        res
                    },
                ))?;
            let headers_: HashMap<String, String> = obj
                .get("headers")?
                .ok_or_else(|| napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!("Missing field `{0}`", "headers"),
                        );
                        res
                    },
                ))?;
            let val = Self {
                unified: unified_,
                passthrough: passthrough_,
                pagination: pagination_,
                meta: meta_,
                headers: headers_,
            };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for ListResponse {}
}
mod unified_api {
    use std::sync::Arc;
    use serde::Serialize;
    use url::Url;
    use crate::*;
    pub(crate) struct UnifiedApi {
        client: Arc<Client>,
        connection_key: String,
        url: Url,
    }
    impl napi::bindgen_prelude::TypeName for UnifiedApi {
        fn type_name() -> &'static str {
            "UnifiedApi"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Function
        }
    }
    impl napi::bindgen_prelude::TypeName for &UnifiedApi {
        fn type_name() -> &'static str {
            "UnifiedApi"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::TypeName for &mut UnifiedApi {
        fn type_name() -> &'static str {
            "UnifiedApi"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for UnifiedApi {
        unsafe fn to_napi_value(
            env: napi::sys::napi_env,
            val: UnifiedApi,
        ) -> napi::Result<napi::bindgen_prelude::sys::napi_value> {
            if let Some(ctor_ref) = napi::__private::get_class_constructor(
                "UnifiedApi<Type>\0",
            ) {
                let wrapped_value = Box::into_raw(Box::new(val));
                let instance_value = UnifiedApi::new_instance(
                    env,
                    wrapped_value.cast(),
                    ctor_ref,
                )?;
                Ok(instance_value)
            } else {
                Err(
                    napi::bindgen_prelude::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Failed to get constructor of class `{0}` in `ToNapiValue`",
                                    "UnifiedApi<Type>",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
    impl napi::bindgen_prelude::ObjectFinalize for UnifiedApi {}
    impl UnifiedApi {
        pub fn instance_of<V: napi::NapiRaw>(
            env: napi::Env,
            value: V,
        ) -> napi::Result<bool> {
            if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
                "UnifiedApi<Type>\0",
            ) {
                let mut ctor = std::ptr::null_mut();
                {
                    let c = unsafe {
                        napi::sys::napi_get_reference_value(
                            env.raw(),
                            ctor_ref,
                            &mut ctor,
                        )
                    };
                    match c {
                        ::napi::sys::Status::napi_ok => Ok(()),
                        _ => {
                            Err(
                                ::napi::Error::new(
                                    ::napi::Status::from(c),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Failed to get constructor reference of class `{0}`",
                                                "UnifiedApi<Type>\0",
                                            ),
                                        );
                                        res
                                    },
                                ),
                            )
                        }
                    }
                }?;
                let mut is_instance_of = false;
                {
                    let c = unsafe {
                        napi::sys::napi_instanceof(
                            env.raw(),
                            value.raw(),
                            ctor,
                            &mut is_instance_of,
                        )
                    };
                    match c {
                        ::napi::sys::Status::napi_ok => Ok(()),
                        _ => {
                            Err(
                                ::napi::Error::new(
                                    ::napi::Status::from(c),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Failed to run instanceof for class `{0}`",
                                                "UnifiedApi<Type>\0",
                                            ),
                                        );
                                        res
                                    },
                                ),
                            )
                        }
                    }
                }?;
                Ok(is_instance_of)
            } else {
                Err(
                    napi::Error::new(
                        napi::Status::GenericFailure,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Failed to get constructor of class `{0}`",
                                    "UnifiedApi<Type>\0",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
    impl UnifiedApi {
        pub fn into_reference(
            val: UnifiedApi,
            env: napi::Env,
        ) -> napi::Result<napi::bindgen_prelude::Reference<UnifiedApi>> {
            if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
                "UnifiedApi<Type>\0",
            ) {
                unsafe {
                    let wrapped_value = Box::into_raw(Box::new(val));
                    let instance_value = UnifiedApi::new_instance(
                        env.raw(),
                        wrapped_value.cast(),
                        ctor_ref,
                    )?;
                    {
                        let env = env.raw();
                    }
                    napi::bindgen_prelude::Reference::<
                        UnifiedApi,
                    >::from_value_ptr(wrapped_value.cast(), env.raw())
                }
            } else {
                Err(
                    napi::bindgen_prelude::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Failed to get constructor of class `{0}`",
                                    "UnifiedApi<Type>",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
        pub fn into_instance(
            self,
            env: napi::Env,
        ) -> napi::Result<napi::bindgen_prelude::ClassInstance<UnifiedApi>> {
            if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
                "UnifiedApi<Type>\0",
            ) {
                unsafe {
                    let wrapped_value = Box::leak(Box::new(self));
                    let instance_value = UnifiedApi::new_instance(
                        env.raw(),
                        wrapped_value as *mut _ as *mut std::ffi::c_void,
                        ctor_ref,
                    )?;
                    Ok(
                        napi::bindgen_prelude::ClassInstance::<
                            UnifiedApi,
                        >::new(instance_value, wrapped_value),
                    )
                }
            } else {
                Err(
                    napi::bindgen_prelude::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Failed to get constructor of class `{0}`",
                                    "UnifiedApi<Type>",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
        unsafe fn new_instance(
            env: napi::sys::napi_env,
            wrapped_value: *mut std::ffi::c_void,
            ctor_ref: napi::sys::napi_ref,
        ) -> napi::Result<napi::bindgen_prelude::sys::napi_value> {
            let mut ctor = std::ptr::null_mut();
            {
                let c = napi::sys::napi_get_reference_value(env, ctor_ref, &mut ctor);
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get constructor reference of class `{0}`",
                                            "UnifiedApi<Type>",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            let mut result = std::ptr::null_mut();
            napi::__private::___CALL_FROM_FACTORY
                .with(|inner| inner.store(true, std::sync::atomic::Ordering::Relaxed));
            {
                let c = napi::sys::napi_new_instance(
                    env,
                    ctor,
                    0,
                    std::ptr::null_mut(),
                    &mut result,
                );
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to construct class `{0}`",
                                            "UnifiedApi<Type>",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            napi::__private::___CALL_FROM_FACTORY
                .with(|inner| inner.store(false, std::sync::atomic::Ordering::Relaxed));
            let mut object_ref = std::ptr::null_mut();
            let initial_finalize: Box<dyn FnOnce()> = Box::new(|| {});
            let finalize_callbacks_ptr = std::rc::Rc::into_raw(
                std::rc::Rc::new(std::cell::Cell::new(Box::into_raw(initial_finalize))),
            );
            {
                let c = napi::sys::napi_wrap(
                    env,
                    result,
                    wrapped_value,
                    Some(napi::bindgen_prelude::raw_finalize_unchecked::<UnifiedApi>),
                    std::ptr::null_mut(),
                    &mut object_ref,
                );
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to wrap native object of class `{0}`",
                                            "UnifiedApi<Type>",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            napi::bindgen_prelude::Reference::<
                UnifiedApi,
            >::add_ref(
                env,
                wrapped_value,
                (wrapped_value, object_ref, finalize_callbacks_ptr),
            );
            Ok(result)
        }
    }
    impl napi::bindgen_prelude::FromNapiRef for UnifiedApi {
        unsafe fn from_napi_ref(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<&'static Self> {
            let mut wrapped_val: *mut std::ffi::c_void = std::ptr::null_mut();
            {
                let c = napi::bindgen_prelude::sys::napi_unwrap(
                    env,
                    napi_val,
                    &mut wrapped_val,
                );
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to recover `{0}` type from napi value",
                                            "UnifiedApi",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            Ok(&*(wrapped_val as *const UnifiedApi))
        }
    }
    impl napi::bindgen_prelude::FromNapiMutRef for UnifiedApi {
        unsafe fn from_napi_mut_ref(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<&'static mut Self> {
            let mut wrapped_val: *mut std::ffi::c_void = std::ptr::null_mut();
            {
                let c = napi::bindgen_prelude::sys::napi_unwrap(
                    env,
                    napi_val,
                    &mut wrapped_val,
                );
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to recover `{0}` type from napi value",
                                            "UnifiedApi",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            Ok(&mut *(wrapped_val as *mut UnifiedApi))
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for &UnifiedApi {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            napi::bindgen_prelude::FromNapiRef::from_napi_ref(env, napi_val)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for &mut UnifiedApi {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            napi::bindgen_prelude::FromNapiMutRef::from_napi_mut_ref(env, napi_val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for &UnifiedApi {
        unsafe fn validate(
            env: napi::sys::napi_env,
            napi_val: napi::sys::napi_value,
        ) -> napi::Result<napi::sys::napi_value> {
            if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
                "UnifiedApi\0",
            ) {
                let mut ctor = std::ptr::null_mut();
                {
                    let c = napi::sys::napi_get_reference_value(
                        env,
                        ctor_ref,
                        &mut ctor,
                    );
                    match c {
                        ::napi::sys::Status::napi_ok => Ok(()),
                        _ => {
                            Err(
                                ::napi::Error::new(
                                    ::napi::Status::from(c),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Failed to get constructor reference of class `{0}`",
                                                "UnifiedApi",
                                            ),
                                        );
                                        res
                                    },
                                ),
                            )
                        }
                    }
                }?;
                let mut is_instance_of = false;
                {
                    let c = napi::sys::napi_instanceof(
                        env,
                        napi_val,
                        ctor,
                        &mut is_instance_of,
                    );
                    match c {
                        ::napi::sys::Status::napi_ok => Ok(()),
                        _ => {
                            Err(
                                ::napi::Error::new(
                                    ::napi::Status::from(c),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Failed to get external value of class `{0}`",
                                                "UnifiedApi",
                                            ),
                                        );
                                        res
                                    },
                                ),
                            )
                        }
                    }
                }?;
                if is_instance_of {
                    Ok(std::ptr::null_mut())
                } else {
                    Err(
                        napi::Error::new(
                            napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Value is not instanceof class `{0}`",
                                        "UnifiedApi",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            } else {
                Err(
                    napi::Error::new(
                        napi::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Failed to get constructor of class `{0}`",
                                    "UnifiedApi",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for &mut UnifiedApi {
        unsafe fn validate(
            env: napi::sys::napi_env,
            napi_val: napi::sys::napi_value,
        ) -> napi::Result<napi::sys::napi_value> {
            if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
                "UnifiedApi\0",
            ) {
                let mut ctor = std::ptr::null_mut();
                {
                    let c = napi::sys::napi_get_reference_value(
                        env,
                        ctor_ref,
                        &mut ctor,
                    );
                    match c {
                        ::napi::sys::Status::napi_ok => Ok(()),
                        _ => {
                            Err(
                                ::napi::Error::new(
                                    ::napi::Status::from(c),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Failed to get constructor reference of class `{0}`",
                                                "UnifiedApi",
                                            ),
                                        );
                                        res
                                    },
                                ),
                            )
                        }
                    }
                }?;
                let mut is_instance_of = false;
                {
                    let c = napi::sys::napi_instanceof(
                        env,
                        napi_val,
                        ctor,
                        &mut is_instance_of,
                    );
                    match c {
                        ::napi::sys::Status::napi_ok => Ok(()),
                        _ => {
                            Err(
                                ::napi::Error::new(
                                    ::napi::Status::from(c),
                                    {
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Failed to get external value of class `{0}`",
                                                "UnifiedApi",
                                            ),
                                        );
                                        res
                                    },
                                ),
                            )
                        }
                    }
                }?;
                if is_instance_of {
                    Ok(std::ptr::null_mut())
                } else {
                    Err(
                        napi::Error::new(
                            napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Value is not instanceof class `{0}`",
                                        "UnifiedApi",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            } else {
                Err(
                    napi::Error::new(
                        napi::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Failed to get constructor of class `{0}`",
                                    "UnifiedApi",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
    #[allow(clippy::all)]
    #[allow(non_snake_case)]
    mod __napi_helper__UnifiedApi {
        use std::ptr;
        use super::*;
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        #[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
        extern fn __napi_register__UnifiedApi_struct_7() {
            napi::__private::register_class(
                "UnifiedApi",
                None,
                "UnifiedApi<Type>\0",
                ::alloc::vec::Vec::new(),
            );
        }
        #[used]
        #[allow(non_upper_case_globals, non_snake_case)]
        #[doc(hidden)]
        #[link_section = ".init_array"]
        static __napi_register__UnifiedApi_struct_7___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
            #[allow(non_snake_case)]
            #[link_section = ".text.startup"]
            unsafe extern "C" fn __napi_register__UnifiedApi_struct_7___rust_ctor___ctor() -> usize {
                __napi_register__UnifiedApi_struct_7();
                0
            }
            __napi_register__UnifiedApi_struct_7___rust_ctor___ctor
        };
    }
    #[serde(rename_all = "camelCase")]
    pub(crate) struct ListFilter {
        pub created_after: Option<String>,
        pub created_before: Option<String>,
        pub updated_after: Option<String>,
        pub updated_before: Option<String>,
        #[serde(with = "serialize_limit")]
        pub limit: Option<u32>,
        pub cursor: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ListFilter {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "created_after",
                "created_before",
                "updated_after",
                "updated_before",
                "limit",
                "cursor",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.created_after,
                &self.created_before,
                &self.updated_after,
                &self.updated_before,
                &self.limit,
                &&self.cursor,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ListFilter",
                names,
                values,
            )
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ListFilter {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ListFilter",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "createdAfter",
                    &self.created_after,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "createdBefore",
                    &self.created_before,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updatedAfter",
                    &self.updated_after,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updatedBefore",
                    &self.updated_before,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "limit",
                    {
                        #[doc(hidden)]
                        struct __SerializeWith<'__a> {
                            values: (&'__a Option<u32>,),
                            phantom: _serde::__private::PhantomData<ListFilter>,
                        }
                        impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::__private::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                serialize_limit::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.limit,),
                            phantom: _serde::__private::PhantomData::<ListFilter>,
                        }
                    },
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "cursor",
                    &self.cursor,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl napi::bindgen_prelude::TypeName for ListFilter {
        fn type_name() -> &'static str {
            "ListFilter"
        }
        fn value_type() -> napi::ValueType {
            napi::ValueType::Object
        }
    }
    impl napi::bindgen_prelude::ToNapiValue for ListFilter {
        unsafe fn to_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            val: ListFilter,
        ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = env_wrapper.create_object()?;
            let Self {
                created_after: created_after_,
                created_before: created_before_,
                updated_after: updated_after_,
                updated_before: updated_before_,
                limit: limit_,
                cursor: cursor_,
            } = val;
            if created_after_.is_some() {
                obj.set("createdAfter", created_after_)?;
            }
            if created_before_.is_some() {
                obj.set("createdBefore", created_before_)?;
            }
            if updated_after_.is_some() {
                obj.set("updatedAfter", updated_after_)?;
            }
            if updated_before_.is_some() {
                obj.set("updatedBefore", updated_before_)?;
            }
            if limit_.is_some() {
                obj.set("limit", limit_)?;
            }
            if cursor_.is_some() {
                obj.set("cursor", cursor_)?;
            }
            napi::bindgen_prelude::Object::to_napi_value(env, obj)
        }
    }
    impl napi::bindgen_prelude::FromNapiValue for ListFilter {
        unsafe fn from_napi_value(
            env: napi::bindgen_prelude::sys::napi_env,
            napi_val: napi::bindgen_prelude::sys::napi_value,
        ) -> napi::bindgen_prelude::Result<Self> {
            let env_wrapper = napi::bindgen_prelude::Env::from(env);
            let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
            let created_after_: Option<String> = obj.get("createdAfter")?;
            let created_before_: Option<String> = obj.get("createdBefore")?;
            let updated_after_: Option<String> = obj.get("updatedAfter")?;
            let updated_before_: Option<String> = obj.get("updatedBefore")?;
            let limit_: Option<u32> = obj.get("limit")?;
            let cursor_: Option<String> = obj.get("cursor")?;
            let val = Self {
                created_after: created_after_,
                created_before: created_before_,
                updated_after: updated_after_,
                updated_before: updated_before_,
                limit: limit_,
                cursor: cursor_,
            };
            Ok(val)
        }
    }
    impl napi::bindgen_prelude::ValidateNapiValue for ListFilter {}
    mod serialize_limit {
        pub fn serialize<S: serde::Serializer>(
            val: &Option<u32>,
            ser: S,
        ) -> Result<S::Ok, S::Error> {
            match *val {
                Some(ref value) => ser.serialize_some(&value.to_string()),
                None => ser.serialize_none(),
            }
        }
    }
    impl UnifiedApi {
        pub fn new(client: Arc<Client>, connection_key: String, url: Url) -> Self {
            Self {
                client,
                connection_key,
                url,
            }
        }
        pub fn _dummy_constructor() {
            ::core::panicking::panic("not implemented")
        }
        pub async fn create(
            &self,
            object: serde_json::Value,
            options: Option<UnifiedOptions>,
        ) -> napi::Result<Response> {
            let builder = self.client.client.post(self.url.clone()).json(&object);
            Ok(self.send(builder, &self.connection_key, options).await?)
        }
        pub async fn list(
            &self,
            filter: Option<ListFilter>,
            options: Option<UnifiedOptions>,
        ) -> napi::Result<ListResponse> {
            let builder = self.client.client.get(self.url.clone()).query(&filter);
            {
                ::std::io::_print(format_args!("Builder {0:?}\n", builder));
            };
            Ok(self.send(builder, &self.connection_key, options).await?)
        }
        pub async fn get(
            &self,
            id: String,
            options: Option<UnifiedOptions>,
        ) -> napi::Result<Response> {
            let builder = self
                .client
                .client
                .get({
                    let res = ::alloc::fmt::format(
                        format_args!("{0}/{1}", self.url, id),
                    );
                    res
                });
            Ok(self.send(builder, &self.connection_key, options).await?)
        }
        pub async fn update(
            &self,
            id: String,
            object: serde_json::Value,
            options: Option<UnifiedOptions>,
        ) -> napi::Result<Response> {
            let builder = self
                .client
                .client
                .patch({
                    let res = ::alloc::fmt::format(
                        format_args!("{0}/{1}", self.url, id),
                    );
                    res
                })
                .json(&object);
            Ok(self.send(builder, &self.connection_key, options).await?)
        }
        pub async fn count(
            &self,
            options: Option<UnifiedOptions>,
        ) -> napi::Result<Response> {
            let builder = self
                .client
                .client
                .get({
                    let res = ::alloc::fmt::format(format_args!("{0}/count", self.url));
                    res
                });
            Ok(self.send(builder, &self.connection_key, options).await?)
        }
        pub async fn delete(
            &self,
            id: String,
            delete_options: Option<DeleteOptions>,
            options: Option<UnifiedOptions>,
        ) -> napi::Result<Response> {
            let builder = self
                .client
                .client
                .delete({
                    let res = ::alloc::fmt::format(
                        format_args!("{0}/{1}", self.url, id),
                    );
                    res
                })
                .json(&delete_options);
            Ok(self.send(builder, &self.connection_key, options).await?)
        }
        async fn send<T: for<'a> Deserialize<'a>>(
            &self,
            mut builder: RequestBuilder,
            key: &str,
            options: Option<UnifiedOptions>,
        ) -> anyhow::Result<T> {
            if let Some(options) = options {
                if options.response_passthrough.is_some_and(|p| p) {
                    builder = builder.header(PASSTHROUGH_HEADER, "true");
                }
                if let Some(headers) = options.passthrough_headers {
                    builder = builder
                        .header(
                            CUSTOM_HEADER,
                            headers
                                .into_iter()
                                .map(|(a, b)| {
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}={1}", a, b),
                                    );
                                    res
                                })
                                .collect::<Vec<_>>()
                                .join(";"),
                        );
                }
                if let Some(params) = options.passthrough_query {
                    builder = builder
                        .query(
                            &[
                                (
                                    CUSTOM_QUERY,
                                    params
                                        .into_iter()
                                        .map(|(a, b)| {
                                            let res = ::alloc::fmt::format(
                                                format_args!("{0}={1}", a, b),
                                            );
                                            res
                                        })
                                        .collect::<Vec<_>>()
                                        .join("&"),
                                ),
                            ],
                        );
                }
            }
            let res = builder
                .header(SECRET_HEADER, self.client.access_key.to_string())
                .header(CONNECTION_HEADER, key)
                .send()
                .await
                .map_err(|e| ::anyhow::__private::must_use({
                    use ::anyhow::__private::kind::*;
                    let error = match e {
                        error => (&error).anyhow_kind().new(error),
                    };
                    error
                }))?;
            let status = res.status();
            if !status.is_success() {
                match res.json::<serde_json::Value>().await {
                    Ok(json) => {
                        return ::anyhow::__private::Err({
                            use ::anyhow::__private::kind::*;
                            let error = match json {
                                error => (&error).anyhow_kind().new(error),
                            };
                            error
                        });
                    }
                    Err(_) => {
                        return ::anyhow::__private::Err({
                            let error = ::anyhow::__private::format_err(
                                format_args!("{{\"error\":\"Invalid response\"}}"),
                            );
                            error
                        });
                    }
                }
            } else {
                let mut headers = serde_json::Map::new();
                for (k, v) in res.headers() {
                    headers
                        .insert(
                            k.to_string(),
                            http_serde_ext::header_value::serialize(
                                    v,
                                    serde_json::value::Serializer,
                                )
                                .unwrap(),
                        );
                }
                match res.json().await {
                    Ok(serde_json::Value::Object(mut map)) => {
                        map.insert(
                            RESPONSE_HEADERS_FIELD_NAME.to_string(),
                            serde_json::Value::Object(headers),
                        );
                        return Ok(
                            serde_json::from_value(serde_json::Value::Object(map))
                                .unwrap(),
                        );
                    }
                    _ => {
                        return ::anyhow::__private::Err({
                            let error = ::anyhow::__private::format_err(
                                format_args!("{{\"error\":\"Invalid response\"}}"),
                            );
                            error
                        });
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    mod __napi_impl_helper__UnifiedApi__0 {
        use super::*;
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi___dummy_constructor(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                if napi::__private::___CALL_FROM_FACTORY
                    .with(|inner| inner.load(std::sync::atomic::Ordering::Relaxed))
                {
                    return std::ptr::null_mut();
                }
                napi::bindgen_prelude::CallbackInfo::<0usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        napi::bindgen_prelude::within_runtime_if_available(move || {
                            let _ret = { UnifiedApi::_dummy_constructor() };
                            <() as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                env,
                                (),
                            )
                        })
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi__create(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                napi::bindgen_prelude::CallbackInfo::<2usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        struct NapiRefContainer([napi::sys::napi_ref; 1usize]);
                        impl NapiRefContainer {
                            fn drop(self, env: napi::sys::napi_env) {
                                for r in self.0.into_iter() {
                                    match (
                                        &unsafe { napi::sys::napi_reference_unref(env, r, &mut 0) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    match (
                                        &unsafe { napi::sys::napi_delete_reference(env, r) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        unsafe impl Send for NapiRefContainer {}
                        unsafe impl Sync for NapiRefContainer {}
                        let _make_ref = |
                            a: ::std::ptr::NonNull<
                                napi::bindgen_prelude::sys::napi_value__,
                            >|
                        {
                            let mut node_ref = ::std::mem::MaybeUninit::uninit();
                            {
                                let c = unsafe {
                                    napi::bindgen_prelude::sys::napi_create_reference(
                                        env,
                                        a.as_ptr(),
                                        1,
                                        node_ref.as_mut_ptr(),
                                    )
                                };
                                match c {
                                    ::napi::sys::Status::napi_ok => Ok(()),
                                    _ => {
                                        Err(
                                            ::napi::Error::new(
                                                ::napi::Status::from(c),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("failed to create napi ref"),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                    }
                                }
                            }?;
                            Ok::<
                                napi::sys::napi_ref,
                                napi::Error,
                            >(unsafe { node_ref.assume_init() })
                        };
                        let mut _args_array = [::std::ptr::null_mut::<
                            napi::bindgen_prelude::sys::napi_ref__,
                        >(); 1usize];
                        let mut _arg_write_index = 0;
                        _args_array[_arg_write_index] = _make_ref(
                            ::std::ptr::NonNull::new(cb.this)
                                .ok_or_else(|| napi::Error::new(
                                    napi::Status::InvalidArg,
                                    "referenced ptr is null".to_owned(),
                                ))?,
                        )?;
                        _arg_write_index += 1;
                        let _args_ref = NapiRefContainer(_args_array);
                        let this_ptr = unsafe { cb.unwrap_raw::<UnifiedApi>()? };
                        let this: &UnifiedApi = Box::leak(Box::from_raw(this_ptr));
                        let arg0 = {
                            <serde_json::Value as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(0usize),
                            )?
                        };
                        let arg1 = {
                            <Option<
                                UnifiedOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(1usize),
                            )?
                        };
                        napi::bindgen_prelude::execute_tokio_future(
                            env,
                            async move { this.create(arg0, arg1).await },
                            move |env, _ret| {
                                _args_ref.drop(env);
                                <Response as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                    env,
                                    _ret,
                                )
                            },
                        )
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi__list(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                napi::bindgen_prelude::CallbackInfo::<2usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        struct NapiRefContainer([napi::sys::napi_ref; 1usize]);
                        impl NapiRefContainer {
                            fn drop(self, env: napi::sys::napi_env) {
                                for r in self.0.into_iter() {
                                    match (
                                        &unsafe { napi::sys::napi_reference_unref(env, r, &mut 0) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    match (
                                        &unsafe { napi::sys::napi_delete_reference(env, r) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        unsafe impl Send for NapiRefContainer {}
                        unsafe impl Sync for NapiRefContainer {}
                        let _make_ref = |
                            a: ::std::ptr::NonNull<
                                napi::bindgen_prelude::sys::napi_value__,
                            >|
                        {
                            let mut node_ref = ::std::mem::MaybeUninit::uninit();
                            {
                                let c = unsafe {
                                    napi::bindgen_prelude::sys::napi_create_reference(
                                        env,
                                        a.as_ptr(),
                                        1,
                                        node_ref.as_mut_ptr(),
                                    )
                                };
                                match c {
                                    ::napi::sys::Status::napi_ok => Ok(()),
                                    _ => {
                                        Err(
                                            ::napi::Error::new(
                                                ::napi::Status::from(c),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("failed to create napi ref"),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                    }
                                }
                            }?;
                            Ok::<
                                napi::sys::napi_ref,
                                napi::Error,
                            >(unsafe { node_ref.assume_init() })
                        };
                        let mut _args_array = [::std::ptr::null_mut::<
                            napi::bindgen_prelude::sys::napi_ref__,
                        >(); 1usize];
                        let mut _arg_write_index = 0;
                        _args_array[_arg_write_index] = _make_ref(
                            ::std::ptr::NonNull::new(cb.this)
                                .ok_or_else(|| napi::Error::new(
                                    napi::Status::InvalidArg,
                                    "referenced ptr is null".to_owned(),
                                ))?,
                        )?;
                        _arg_write_index += 1;
                        let _args_ref = NapiRefContainer(_args_array);
                        let this_ptr = unsafe { cb.unwrap_raw::<UnifiedApi>()? };
                        let this: &UnifiedApi = Box::leak(Box::from_raw(this_ptr));
                        let arg0 = {
                            <Option<
                                ListFilter,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(0usize),
                            )?
                        };
                        let arg1 = {
                            <Option<
                                UnifiedOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(1usize),
                            )?
                        };
                        napi::bindgen_prelude::execute_tokio_future(
                            env,
                            async move { this.list(arg0, arg1).await },
                            move |env, _ret| {
                                _args_ref.drop(env);
                                <ListResponse as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                    env,
                                    _ret,
                                )
                            },
                        )
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi__get(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                napi::bindgen_prelude::CallbackInfo::<2usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        struct NapiRefContainer([napi::sys::napi_ref; 1usize]);
                        impl NapiRefContainer {
                            fn drop(self, env: napi::sys::napi_env) {
                                for r in self.0.into_iter() {
                                    match (
                                        &unsafe { napi::sys::napi_reference_unref(env, r, &mut 0) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    match (
                                        &unsafe { napi::sys::napi_delete_reference(env, r) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        unsafe impl Send for NapiRefContainer {}
                        unsafe impl Sync for NapiRefContainer {}
                        let _make_ref = |
                            a: ::std::ptr::NonNull<
                                napi::bindgen_prelude::sys::napi_value__,
                            >|
                        {
                            let mut node_ref = ::std::mem::MaybeUninit::uninit();
                            {
                                let c = unsafe {
                                    napi::bindgen_prelude::sys::napi_create_reference(
                                        env,
                                        a.as_ptr(),
                                        1,
                                        node_ref.as_mut_ptr(),
                                    )
                                };
                                match c {
                                    ::napi::sys::Status::napi_ok => Ok(()),
                                    _ => {
                                        Err(
                                            ::napi::Error::new(
                                                ::napi::Status::from(c),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("failed to create napi ref"),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                    }
                                }
                            }?;
                            Ok::<
                                napi::sys::napi_ref,
                                napi::Error,
                            >(unsafe { node_ref.assume_init() })
                        };
                        let mut _args_array = [::std::ptr::null_mut::<
                            napi::bindgen_prelude::sys::napi_ref__,
                        >(); 1usize];
                        let mut _arg_write_index = 0;
                        _args_array[_arg_write_index] = _make_ref(
                            ::std::ptr::NonNull::new(cb.this)
                                .ok_or_else(|| napi::Error::new(
                                    napi::Status::InvalidArg,
                                    "referenced ptr is null".to_owned(),
                                ))?,
                        )?;
                        _arg_write_index += 1;
                        let _args_ref = NapiRefContainer(_args_array);
                        let this_ptr = unsafe { cb.unwrap_raw::<UnifiedApi>()? };
                        let this: &UnifiedApi = Box::leak(Box::from_raw(this_ptr));
                        let arg0 = {
                            <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(0usize),
                            )?
                        };
                        let arg1 = {
                            <Option<
                                UnifiedOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(1usize),
                            )?
                        };
                        napi::bindgen_prelude::execute_tokio_future(
                            env,
                            async move { this.get(arg0, arg1).await },
                            move |env, _ret| {
                                _args_ref.drop(env);
                                <Response as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                    env,
                                    _ret,
                                )
                            },
                        )
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi__update(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                napi::bindgen_prelude::CallbackInfo::<3usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        struct NapiRefContainer([napi::sys::napi_ref; 1usize]);
                        impl NapiRefContainer {
                            fn drop(self, env: napi::sys::napi_env) {
                                for r in self.0.into_iter() {
                                    match (
                                        &unsafe { napi::sys::napi_reference_unref(env, r, &mut 0) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    match (
                                        &unsafe { napi::sys::napi_delete_reference(env, r) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        unsafe impl Send for NapiRefContainer {}
                        unsafe impl Sync for NapiRefContainer {}
                        let _make_ref = |
                            a: ::std::ptr::NonNull<
                                napi::bindgen_prelude::sys::napi_value__,
                            >|
                        {
                            let mut node_ref = ::std::mem::MaybeUninit::uninit();
                            {
                                let c = unsafe {
                                    napi::bindgen_prelude::sys::napi_create_reference(
                                        env,
                                        a.as_ptr(),
                                        1,
                                        node_ref.as_mut_ptr(),
                                    )
                                };
                                match c {
                                    ::napi::sys::Status::napi_ok => Ok(()),
                                    _ => {
                                        Err(
                                            ::napi::Error::new(
                                                ::napi::Status::from(c),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("failed to create napi ref"),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                    }
                                }
                            }?;
                            Ok::<
                                napi::sys::napi_ref,
                                napi::Error,
                            >(unsafe { node_ref.assume_init() })
                        };
                        let mut _args_array = [::std::ptr::null_mut::<
                            napi::bindgen_prelude::sys::napi_ref__,
                        >(); 1usize];
                        let mut _arg_write_index = 0;
                        _args_array[_arg_write_index] = _make_ref(
                            ::std::ptr::NonNull::new(cb.this)
                                .ok_or_else(|| napi::Error::new(
                                    napi::Status::InvalidArg,
                                    "referenced ptr is null".to_owned(),
                                ))?,
                        )?;
                        _arg_write_index += 1;
                        let _args_ref = NapiRefContainer(_args_array);
                        let this_ptr = unsafe { cb.unwrap_raw::<UnifiedApi>()? };
                        let this: &UnifiedApi = Box::leak(Box::from_raw(this_ptr));
                        let arg0 = {
                            <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(0usize),
                            )?
                        };
                        let arg1 = {
                            <serde_json::Value as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(1usize),
                            )?
                        };
                        let arg2 = {
                            <Option<
                                UnifiedOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(2usize),
                            )?
                        };
                        napi::bindgen_prelude::execute_tokio_future(
                            env,
                            async move { this.update(arg0, arg1, arg2).await },
                            move |env, _ret| {
                                _args_ref.drop(env);
                                <Response as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                    env,
                                    _ret,
                                )
                            },
                        )
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi__count(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        struct NapiRefContainer([napi::sys::napi_ref; 1usize]);
                        impl NapiRefContainer {
                            fn drop(self, env: napi::sys::napi_env) {
                                for r in self.0.into_iter() {
                                    match (
                                        &unsafe { napi::sys::napi_reference_unref(env, r, &mut 0) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    match (
                                        &unsafe { napi::sys::napi_delete_reference(env, r) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        unsafe impl Send for NapiRefContainer {}
                        unsafe impl Sync for NapiRefContainer {}
                        let _make_ref = |
                            a: ::std::ptr::NonNull<
                                napi::bindgen_prelude::sys::napi_value__,
                            >|
                        {
                            let mut node_ref = ::std::mem::MaybeUninit::uninit();
                            {
                                let c = unsafe {
                                    napi::bindgen_prelude::sys::napi_create_reference(
                                        env,
                                        a.as_ptr(),
                                        1,
                                        node_ref.as_mut_ptr(),
                                    )
                                };
                                match c {
                                    ::napi::sys::Status::napi_ok => Ok(()),
                                    _ => {
                                        Err(
                                            ::napi::Error::new(
                                                ::napi::Status::from(c),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("failed to create napi ref"),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                    }
                                }
                            }?;
                            Ok::<
                                napi::sys::napi_ref,
                                napi::Error,
                            >(unsafe { node_ref.assume_init() })
                        };
                        let mut _args_array = [::std::ptr::null_mut::<
                            napi::bindgen_prelude::sys::napi_ref__,
                        >(); 1usize];
                        let mut _arg_write_index = 0;
                        _args_array[_arg_write_index] = _make_ref(
                            ::std::ptr::NonNull::new(cb.this)
                                .ok_or_else(|| napi::Error::new(
                                    napi::Status::InvalidArg,
                                    "referenced ptr is null".to_owned(),
                                ))?,
                        )?;
                        _arg_write_index += 1;
                        let _args_ref = NapiRefContainer(_args_array);
                        let this_ptr = unsafe { cb.unwrap_raw::<UnifiedApi>()? };
                        let this: &UnifiedApi = Box::leak(Box::from_raw(this_ptr));
                        let arg0 = {
                            <Option<
                                UnifiedOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(0usize),
                            )?
                        };
                        napi::bindgen_prelude::execute_tokio_future(
                            env,
                            async move { this.count(arg0).await },
                            move |env, _ret| {
                                _args_ref.drop(env);
                                <Response as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                    env,
                                    _ret,
                                )
                            },
                        )
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        #[allow(clippy::all)]
        extern "C" fn __napi__delete(
            env: napi::bindgen_prelude::sys::napi_env,
            cb: napi::bindgen_prelude::sys::napi_callback_info,
        ) -> napi::bindgen_prelude::sys::napi_value {
            unsafe {
                napi::bindgen_prelude::CallbackInfo::<3usize>::new(env, cb, None, false)
                    .and_then(|mut cb| {
                        struct NapiRefContainer([napi::sys::napi_ref; 1usize]);
                        impl NapiRefContainer {
                            fn drop(self, env: napi::sys::napi_env) {
                                for r in self.0.into_iter() {
                                    match (
                                        &unsafe { napi::sys::napi_reference_unref(env, r, &mut 0) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    match (
                                        &unsafe { napi::sys::napi_delete_reference(env, r) },
                                        &napi::sys::Status::napi_ok,
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("failed to delete napi ref"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                }
                            }
                        }
                        unsafe impl Send for NapiRefContainer {}
                        unsafe impl Sync for NapiRefContainer {}
                        let _make_ref = |
                            a: ::std::ptr::NonNull<
                                napi::bindgen_prelude::sys::napi_value__,
                            >|
                        {
                            let mut node_ref = ::std::mem::MaybeUninit::uninit();
                            {
                                let c = unsafe {
                                    napi::bindgen_prelude::sys::napi_create_reference(
                                        env,
                                        a.as_ptr(),
                                        1,
                                        node_ref.as_mut_ptr(),
                                    )
                                };
                                match c {
                                    ::napi::sys::Status::napi_ok => Ok(()),
                                    _ => {
                                        Err(
                                            ::napi::Error::new(
                                                ::napi::Status::from(c),
                                                {
                                                    let res = ::alloc::fmt::format(
                                                        format_args!("failed to create napi ref"),
                                                    );
                                                    res
                                                },
                                            ),
                                        )
                                    }
                                }
                            }?;
                            Ok::<
                                napi::sys::napi_ref,
                                napi::Error,
                            >(unsafe { node_ref.assume_init() })
                        };
                        let mut _args_array = [::std::ptr::null_mut::<
                            napi::bindgen_prelude::sys::napi_ref__,
                        >(); 1usize];
                        let mut _arg_write_index = 0;
                        _args_array[_arg_write_index] = _make_ref(
                            ::std::ptr::NonNull::new(cb.this)
                                .ok_or_else(|| napi::Error::new(
                                    napi::Status::InvalidArg,
                                    "referenced ptr is null".to_owned(),
                                ))?,
                        )?;
                        _arg_write_index += 1;
                        let _args_ref = NapiRefContainer(_args_array);
                        let this_ptr = unsafe { cb.unwrap_raw::<UnifiedApi>()? };
                        let this: &UnifiedApi = Box::leak(Box::from_raw(this_ptr));
                        let arg0 = {
                            <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(0usize),
                            )?
                        };
                        let arg1 = {
                            <Option<
                                DeleteOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(1usize),
                            )?
                        };
                        let arg2 = {
                            <Option<
                                UnifiedOptions,
                            > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                                env,
                                cb.get_arg(2usize),
                            )?
                        };
                        napi::bindgen_prelude::execute_tokio_future(
                            env,
                            async move { this.delete(arg0, arg1, arg2).await },
                            move |env, _ret| {
                                _args_ref.drop(env);
                                <Response as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                                    env,
                                    _ret,
                                )
                            },
                        )
                    })
                    .unwrap_or_else(|e| {
                        napi::bindgen_prelude::JsError::from(e).throw_into(env);
                        std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                    })
            }
        }
        #[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
        extern fn __napi_register__UnifiedApi_impl_16() {
            napi::__private::register_class(
                "UnifiedApi",
                None,
                "UnifiedApi<Type>\0",
                <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([
                        napi::bindgen_prelude::Property::new("constructor")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_ctor(__napi___dummy_constructor),
                        napi::bindgen_prelude::Property::new("count")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_method(__napi__count),
                        napi::bindgen_prelude::Property::new("create")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_method(__napi__create),
                        napi::bindgen_prelude::Property::new("delete")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_method(__napi__delete),
                        napi::bindgen_prelude::Property::new("get")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_method(__napi__get),
                        napi::bindgen_prelude::Property::new("list")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_method(__napi__list),
                        napi::bindgen_prelude::Property::new("update")
                            .unwrap()
                            .with_property_attributes(
                                napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                    .unwrap(),
                            )
                            .with_method(__napi__update),
                    ]),
                ),
            );
        }
        #[used]
        #[allow(non_upper_case_globals, non_snake_case)]
        #[doc(hidden)]
        #[link_section = ".init_array"]
        static __napi_register__UnifiedApi_impl_16___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
            #[allow(non_snake_case)]
            #[link_section = ".text.startup"]
            unsafe extern "C" fn __napi_register__UnifiedApi_impl_16___rust_ctor___ctor() -> usize {
                __napi_register__UnifiedApi_impl_16();
                0
            }
            __napi_register__UnifiedApi_impl_16___rust_ctor___ctor
        };
    }
}
use options::*;
use responses::*;
use unified_api::*;
const DEFAULT_URL: &str = "https://api.integrationos.com/v1/unified";
const PASSTHROUGH_HEADER: &str = "x-integrationos-enable-passthrough";
const SECRET_HEADER: &str = "x-integrationos-secret";
const CONNECTION_HEADER: &str = "x-integrationos-connection-key";
const CUSTOM_HEADER: &str = "x-integrationos-passthrough";
const CUSTOM_QUERY: &str = "integrationOSPassthrough";
const RESPONSE_HEADERS_FIELD_NAME: &str = "headers";
struct Client {
    access_key: String,
    url: Url,
    client: reqwest::Client,
}
#[automatically_derived]
impl ::core::fmt::Debug for Client {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "Client",
            "access_key",
            &self.access_key,
            "url",
            &self.url,
            "client",
            &&self.client,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Client {
    #[inline]
    fn clone(&self) -> Client {
        Client {
            access_key: ::core::clone::Clone::clone(&self.access_key),
            url: ::core::clone::Clone::clone(&self.url),
            client: ::core::clone::Clone::clone(&self.client),
        }
    }
}
struct IntegrationOS {
    client: Arc<Client>,
}
impl napi::bindgen_prelude::TypeName for IntegrationOS {
    fn type_name() -> &'static str {
        "IntegrationOS"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Function
    }
}
impl napi::bindgen_prelude::TypeName for &IntegrationOS {
    fn type_name() -> &'static str {
        "IntegrationOS"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::TypeName for &mut IntegrationOS {
    fn type_name() -> &'static str {
        "IntegrationOS"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for IntegrationOS {
    unsafe fn to_napi_value(
        env: napi::sys::napi_env,
        val: IntegrationOS,
    ) -> napi::Result<napi::bindgen_prelude::sys::napi_value> {
        if let Some(ctor_ref) = napi::__private::get_class_constructor(
            "IntegrationOS\0",
        ) {
            let wrapped_value = Box::into_raw(Box::new(val));
            let instance_value = IntegrationOS::new_instance(
                env,
                wrapped_value.cast(),
                ctor_ref,
            )?;
            Ok(instance_value)
        } else {
            Err(
                napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to get constructor of class `{0}` in `ToNapiValue`",
                                "IntegrationOS",
                            ),
                        );
                        res
                    },
                ),
            )
        }
    }
}
impl napi::bindgen_prelude::ObjectFinalize for IntegrationOS {}
impl IntegrationOS {
    pub fn instance_of<V: napi::NapiRaw>(
        env: napi::Env,
        value: V,
    ) -> napi::Result<bool> {
        if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
            "IntegrationOS\0",
        ) {
            let mut ctor = std::ptr::null_mut();
            {
                let c = unsafe {
                    napi::sys::napi_get_reference_value(env.raw(), ctor_ref, &mut ctor)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get constructor reference of class `{0}`",
                                            "IntegrationOS\0",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            let mut is_instance_of = false;
            {
                let c = unsafe {
                    napi::sys::napi_instanceof(
                        env.raw(),
                        value.raw(),
                        ctor,
                        &mut is_instance_of,
                    )
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to run instanceof for class `{0}`",
                                            "IntegrationOS\0",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            Ok(is_instance_of)
        } else {
            Err(
                napi::Error::new(
                    napi::Status::GenericFailure,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to get constructor of class `{0}`",
                                "IntegrationOS\0",
                            ),
                        );
                        res
                    },
                ),
            )
        }
    }
}
impl IntegrationOS {
    pub fn into_reference(
        val: IntegrationOS,
        env: napi::Env,
    ) -> napi::Result<napi::bindgen_prelude::Reference<IntegrationOS>> {
        if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
            "IntegrationOS\0",
        ) {
            unsafe {
                let wrapped_value = Box::into_raw(Box::new(val));
                let instance_value = IntegrationOS::new_instance(
                    env.raw(),
                    wrapped_value.cast(),
                    ctor_ref,
                )?;
                {
                    let env = env.raw();
                }
                napi::bindgen_prelude::Reference::<
                    IntegrationOS,
                >::from_value_ptr(wrapped_value.cast(), env.raw())
            }
        } else {
            Err(
                napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to get constructor of class `{0}`",
                                "IntegrationOS",
                            ),
                        );
                        res
                    },
                ),
            )
        }
    }
    pub fn into_instance(
        self,
        env: napi::Env,
    ) -> napi::Result<napi::bindgen_prelude::ClassInstance<IntegrationOS>> {
        if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
            "IntegrationOS\0",
        ) {
            unsafe {
                let wrapped_value = Box::leak(Box::new(self));
                let instance_value = IntegrationOS::new_instance(
                    env.raw(),
                    wrapped_value as *mut _ as *mut std::ffi::c_void,
                    ctor_ref,
                )?;
                Ok(
                    napi::bindgen_prelude::ClassInstance::<
                        IntegrationOS,
                    >::new(instance_value, wrapped_value),
                )
            }
        } else {
            Err(
                napi::bindgen_prelude::Error::new(
                    napi::bindgen_prelude::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to get constructor of class `{0}`",
                                "IntegrationOS",
                            ),
                        );
                        res
                    },
                ),
            )
        }
    }
    unsafe fn new_instance(
        env: napi::sys::napi_env,
        wrapped_value: *mut std::ffi::c_void,
        ctor_ref: napi::sys::napi_ref,
    ) -> napi::Result<napi::bindgen_prelude::sys::napi_value> {
        let mut ctor = std::ptr::null_mut();
        {
            let c = napi::sys::napi_get_reference_value(env, ctor_ref, &mut ctor);
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to get constructor reference of class `{0}`",
                                        "IntegrationOS",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
        let mut result = std::ptr::null_mut();
        napi::__private::___CALL_FROM_FACTORY
            .with(|inner| inner.store(true, std::sync::atomic::Ordering::Relaxed));
        {
            let c = napi::sys::napi_new_instance(
                env,
                ctor,
                0,
                std::ptr::null_mut(),
                &mut result,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to construct class `{0}`",
                                        "IntegrationOS",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
        napi::__private::___CALL_FROM_FACTORY
            .with(|inner| inner.store(false, std::sync::atomic::Ordering::Relaxed));
        let mut object_ref = std::ptr::null_mut();
        let initial_finalize: Box<dyn FnOnce()> = Box::new(|| {});
        let finalize_callbacks_ptr = std::rc::Rc::into_raw(
            std::rc::Rc::new(std::cell::Cell::new(Box::into_raw(initial_finalize))),
        );
        {
            let c = napi::sys::napi_wrap(
                env,
                result,
                wrapped_value,
                Some(napi::bindgen_prelude::raw_finalize_unchecked::<IntegrationOS>),
                std::ptr::null_mut(),
                &mut object_ref,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to wrap native object of class `{0}`",
                                        "IntegrationOS",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
        napi::bindgen_prelude::Reference::<
            IntegrationOS,
        >::add_ref(
            env,
            wrapped_value,
            (wrapped_value, object_ref, finalize_callbacks_ptr),
        );
        Ok(result)
    }
}
impl napi::bindgen_prelude::FromNapiRef for IntegrationOS {
    unsafe fn from_napi_ref(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<&'static Self> {
        let mut wrapped_val: *mut std::ffi::c_void = std::ptr::null_mut();
        {
            let c = napi::bindgen_prelude::sys::napi_unwrap(
                env,
                napi_val,
                &mut wrapped_val,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to recover `{0}` type from napi value",
                                        "IntegrationOS",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
        Ok(&*(wrapped_val as *const IntegrationOS))
    }
}
impl napi::bindgen_prelude::FromNapiMutRef for IntegrationOS {
    unsafe fn from_napi_mut_ref(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<&'static mut Self> {
        let mut wrapped_val: *mut std::ffi::c_void = std::ptr::null_mut();
        {
            let c = napi::bindgen_prelude::sys::napi_unwrap(
                env,
                napi_val,
                &mut wrapped_val,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to recover `{0}` type from napi value",
                                        "IntegrationOS",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
        Ok(&mut *(wrapped_val as *mut IntegrationOS))
    }
}
impl napi::bindgen_prelude::FromNapiValue for &IntegrationOS {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        napi::bindgen_prelude::FromNapiRef::from_napi_ref(env, napi_val)
    }
}
impl napi::bindgen_prelude::FromNapiValue for &mut IntegrationOS {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        napi::bindgen_prelude::FromNapiMutRef::from_napi_mut_ref(env, napi_val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for &IntegrationOS {
    unsafe fn validate(
        env: napi::sys::napi_env,
        napi_val: napi::sys::napi_value,
    ) -> napi::Result<napi::sys::napi_value> {
        if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
            "IntegrationOS\0",
        ) {
            let mut ctor = std::ptr::null_mut();
            {
                let c = napi::sys::napi_get_reference_value(env, ctor_ref, &mut ctor);
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get constructor reference of class `{0}`",
                                            "IntegrationOS",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            let mut is_instance_of = false;
            {
                let c = napi::sys::napi_instanceof(
                    env,
                    napi_val,
                    ctor,
                    &mut is_instance_of,
                );
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get external value of class `{0}`",
                                            "IntegrationOS",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            if is_instance_of {
                Ok(std::ptr::null_mut())
            } else {
                Err(
                    napi::Error::new(
                        napi::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Value is not instanceof class `{0}`",
                                    "IntegrationOS",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        } else {
            Err(
                napi::Error::new(
                    napi::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to get constructor of class `{0}`",
                                "IntegrationOS",
                            ),
                        );
                        res
                    },
                ),
            )
        }
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for &mut IntegrationOS {
    unsafe fn validate(
        env: napi::sys::napi_env,
        napi_val: napi::sys::napi_value,
    ) -> napi::Result<napi::sys::napi_value> {
        if let Some(ctor_ref) = napi::bindgen_prelude::get_class_constructor(
            "IntegrationOS\0",
        ) {
            let mut ctor = std::ptr::null_mut();
            {
                let c = napi::sys::napi_get_reference_value(env, ctor_ref, &mut ctor);
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get constructor reference of class `{0}`",
                                            "IntegrationOS",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            let mut is_instance_of = false;
            {
                let c = napi::sys::napi_instanceof(
                    env,
                    napi_val,
                    ctor,
                    &mut is_instance_of,
                );
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => {
                        Err(
                            ::napi::Error::new(
                                ::napi::Status::from(c),
                                {
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Failed to get external value of class `{0}`",
                                            "IntegrationOS",
                                        ),
                                    );
                                    res
                                },
                            ),
                        )
                    }
                }
            }?;
            if is_instance_of {
                Ok(std::ptr::null_mut())
            } else {
                Err(
                    napi::Error::new(
                        napi::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Value is not instanceof class `{0}`",
                                    "IntegrationOS",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        } else {
            Err(
                napi::Error::new(
                    napi::Status::InvalidArg,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to get constructor of class `{0}`",
                                "IntegrationOS",
                            ),
                        );
                        res
                    },
                ),
            )
        }
    }
}
#[allow(clippy::all)]
#[allow(non_snake_case)]
mod __napi_helper__IntegrationOS {
    use std::ptr;
    use super::*;
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    #[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
    extern fn __napi_register__IntegrationOS_struct_17() {
        napi::__private::register_class(
            "IntegrationOS",
            None,
            "IntegrationOS\0",
            ::alloc::vec::Vec::new(),
        );
    }
    #[used]
    #[allow(non_upper_case_globals, non_snake_case)]
    #[doc(hidden)]
    #[link_section = ".init_array"]
    static __napi_register__IntegrationOS_struct_17___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
        #[allow(non_snake_case)]
        #[link_section = ".text.startup"]
        unsafe extern "C" fn __napi_register__IntegrationOS_struct_17___rust_ctor___ctor() -> usize {
            __napi_register__IntegrationOS_struct_17();
            0
        }
        __napi_register__IntegrationOS_struct_17___rust_ctor___ctor
    };
}
impl IntegrationOS {
    pub fn new(
        access_key: String,
        options: Option<IntegrationOSOptions>,
    ) -> napi::Result<Self> {
        let url = Url::parse(
                options
                    .as_ref()
                    .map(|o| {
                        let url = o.server_url.as_str();
                        if url.ends_with("/") { &url[..url.len() - 1] } else { url }
                    })
                    .unwrap_or(DEFAULT_URL),
            )
            .map_err(|e: ParseError| ::anyhow::__private::must_use({
                use ::anyhow::__private::kind::*;
                let error = match e {
                    error => (&error).anyhow_kind().new(error),
                };
                error
            }))?;
        let client = reqwest::Client::default();
        Ok(Self {
            client: Arc::new(Client { access_key, url, client }),
        })
    }
    pub fn messages(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/messages", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn chats(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/chats", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn taxrates(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/taxrates", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn creditnotes(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/creditnotes", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn expenses(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/expenses", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn transactions(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/transactions", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn accounts(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/accounts", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn purchaseorders(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/purchaseorders", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn payments(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/payments", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn bills(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/bills", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn vendors(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/vendors", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn balancesheets(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/balancesheets", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn incomestatements(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/incomestatements", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn invoices(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/invoices", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn journalentries(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/journalentries", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn tickets(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/tickets", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn candidates(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/candidates", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn contacts(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/contacts", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn jobs(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/jobs", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn tasks(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/tasks", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn products(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/products", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn orders(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/orders", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn opportunities(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/opportunities", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn users(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/users", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn notes(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/notes", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn leads(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/leads", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn companies(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/companies", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
    pub fn customers(&self, connection_key: String) -> UnifiedApi {
        UnifiedApi::new(
            self.client.clone(),
            connection_key,
            Url::parse(
                    &{
                        let res = ::alloc::fmt::format(
                            format_args!("{0}/customers", self.client.url),
                        );
                        res
                    },
                )
                .unwrap(),
        )
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
mod __napi_impl_helper__IntegrationOS__1 {
    use super::*;
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__new(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            if napi::__private::___CALL_FROM_FACTORY
                .with(|inner| inner.load(std::sync::atomic::Ordering::Relaxed))
            {
                return std::ptr::null_mut();
            }
            napi::bindgen_prelude::CallbackInfo::<2usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    let arg1 = {
                        <Option<
                            IntegrationOSOptions,
                        > as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(1usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { IntegrationOS::new(arg0, arg1) };
                        cb.construct::<false, IntegrationOS>("constructor", _ret?)
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__messages(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.messages(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__chats(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.chats(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__taxrates(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.taxrates(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__creditnotes(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.creditnotes(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__expenses(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.expenses(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__transactions(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.transactions(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__accounts(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.accounts(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__purchaseorders(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.purchaseorders(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__payments(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.payments(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__bills(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.bills(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__vendors(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.vendors(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__balancesheets(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.balancesheets(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__incomestatements(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.incomestatements(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__invoices(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.invoices(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__journalentries(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.journalentries(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__tickets(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.tickets(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__candidates(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.candidates(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__contacts(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.contacts(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__jobs(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.jobs(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__tasks(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.tasks(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__products(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.products(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__orders(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.orders(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__opportunities(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.opportunities(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__users(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.users(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__notes(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.notes(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__leads(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.leads(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__companies(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.companies(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[doc(hidden)]
    #[allow(non_snake_case)]
    #[allow(clippy::all)]
    extern "C" fn __napi__customers(
        env: napi::bindgen_prelude::sys::napi_env,
        cb: napi::bindgen_prelude::sys::napi_callback_info,
    ) -> napi::bindgen_prelude::sys::napi_value {
        unsafe {
            napi::bindgen_prelude::CallbackInfo::<1usize>::new(env, cb, None, false)
                .and_then(|mut cb| {
                    let this_ptr = unsafe { cb.unwrap_raw::<IntegrationOS>()? };
                    let this: &IntegrationOS = Box::leak(Box::from_raw(this_ptr));
                    let arg0 = {
                        <String as napi::bindgen_prelude::FromNapiValue>::from_napi_value(
                            env,
                            cb.get_arg(0usize),
                        )?
                    };
                    napi::bindgen_prelude::within_runtime_if_available(move || {
                        let _ret = { this.customers(arg0) };
                        <UnifiedApi as napi::bindgen_prelude::ToNapiValue>::to_napi_value(
                            env,
                            _ret,
                        )
                    })
                })
                .unwrap_or_else(|e| {
                    napi::bindgen_prelude::JsError::from(e).throw_into(env);
                    std::ptr::null_mut::<napi::bindgen_prelude::sys::napi_value__>()
                })
        }
    }
    #[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
    extern fn __napi_register__IntegrationOS_impl_47() {
        napi::__private::register_class(
            "IntegrationOS",
            None,
            "IntegrationOS\0",
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    napi::bindgen_prelude::Property::new("accounts")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__accounts),
                    napi::bindgen_prelude::Property::new("balancesheets")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__balancesheets),
                    napi::bindgen_prelude::Property::new("bills")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__bills),
                    napi::bindgen_prelude::Property::new("candidates")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__candidates),
                    napi::bindgen_prelude::Property::new("chats")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__chats),
                    napi::bindgen_prelude::Property::new("companies")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__companies),
                    napi::bindgen_prelude::Property::new("constructor")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_ctor(__napi__new),
                    napi::bindgen_prelude::Property::new("contacts")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__contacts),
                    napi::bindgen_prelude::Property::new("creditnotes")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__creditnotes),
                    napi::bindgen_prelude::Property::new("customers")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__customers),
                    napi::bindgen_prelude::Property::new("expenses")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__expenses),
                    napi::bindgen_prelude::Property::new("incomestatements")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__incomestatements),
                    napi::bindgen_prelude::Property::new("invoices")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__invoices),
                    napi::bindgen_prelude::Property::new("jobs")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__jobs),
                    napi::bindgen_prelude::Property::new("journalentries")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__journalentries),
                    napi::bindgen_prelude::Property::new("leads")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__leads),
                    napi::bindgen_prelude::Property::new("messages")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__messages),
                    napi::bindgen_prelude::Property::new("notes")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__notes),
                    napi::bindgen_prelude::Property::new("opportunities")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__opportunities),
                    napi::bindgen_prelude::Property::new("orders")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__orders),
                    napi::bindgen_prelude::Property::new("payments")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__payments),
                    napi::bindgen_prelude::Property::new("products")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__products),
                    napi::bindgen_prelude::Property::new("purchaseorders")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__purchaseorders),
                    napi::bindgen_prelude::Property::new("tasks")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__tasks),
                    napi::bindgen_prelude::Property::new("taxrates")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__taxrates),
                    napi::bindgen_prelude::Property::new("tickets")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__tickets),
                    napi::bindgen_prelude::Property::new("transactions")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__transactions),
                    napi::bindgen_prelude::Property::new("users")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__users),
                    napi::bindgen_prelude::Property::new("vendors")
                        .unwrap()
                        .with_property_attributes(
                            napi::bindgen_prelude::PropertyAttributes::from_bits(7i32)
                                .unwrap(),
                        )
                        .with_method(__napi__vendors),
                ]),
            ),
        );
    }
    #[used]
    #[allow(non_upper_case_globals, non_snake_case)]
    #[doc(hidden)]
    #[link_section = ".init_array"]
    static __napi_register__IntegrationOS_impl_47___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
        #[allow(non_snake_case)]
        #[link_section = ".text.startup"]
        unsafe extern "C" fn __napi_register__IntegrationOS_impl_47___rust_ctor___ctor() -> usize {
            __napi_register__IntegrationOS_impl_47();
            0
        }
        __napi_register__IntegrationOS_impl_47___rust_ctor___ctor
    };
}
pub struct TaxDetails {
    pub active: Option<bool>,
    pub effective_date: Option<chrono::DateTime<chrono::Utc>>,
    pub tax_registration_number: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub region: Option<String>,
    pub id: Option<String>,
    pub is_tax_included_in_price: Option<bool>,
    pub rate: Option<f64>,
    pub deleted: Option<bool>,
    pub currency: Option<Currency>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub expiration_date: Option<chrono::DateTime<chrono::Utc>>,
    pub name: Option<String>,
    pub category: Option<String>,
    pub details: Option<String>,
    pub country: Option<String>,
    pub amount: Option<f64>,
    pub jurisdiction: Option<String>,
    pub tax_code: Option<String>,
}
impl napi::bindgen_prelude::TypeName for TaxDetails {
    fn type_name() -> &'static str {
        "TaxDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for TaxDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: TaxDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            active: active_,
            effective_date: effective_date_,
            tax_registration_number: tax_registration_number_,
            updated_at: updated_at_,
            region: region_,
            id: id_,
            is_tax_included_in_price: is_tax_included_in_price_,
            rate: rate_,
            deleted: deleted_,
            currency: currency_,
            created_at: created_at_,
            expiration_date: expiration_date_,
            name: name_,
            category: category_,
            details: details_,
            country: country_,
            amount: amount_,
            jurisdiction: jurisdiction_,
            tax_code: tax_code_,
        } = val;
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if effective_date_.is_some() {
            obj.set("effectiveDate", effective_date_)?;
        }
        if tax_registration_number_.is_some() {
            obj.set("taxRegistrationNumber", tax_registration_number_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if region_.is_some() {
            obj.set("region", region_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if is_tax_included_in_price_.is_some() {
            obj.set("isTaxIncludedInPrice", is_tax_included_in_price_)?;
        }
        if rate_.is_some() {
            obj.set("rate", rate_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if expiration_date_.is_some() {
            obj.set("expirationDate", expiration_date_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if category_.is_some() {
            obj.set("category", category_)?;
        }
        if details_.is_some() {
            obj.set("details", details_)?;
        }
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if jurisdiction_.is_some() {
            obj.set("jurisdiction", jurisdiction_)?;
        }
        if tax_code_.is_some() {
            obj.set("taxCode", tax_code_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for TaxDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let active_: Option<bool> = obj.get("active")?;
        let effective_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("effectiveDate")?;
        let tax_registration_number_: Option<String> = obj.get("taxRegistrationNumber")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let region_: Option<String> = obj.get("region")?;
        let id_: Option<String> = obj.get("id")?;
        let is_tax_included_in_price_: Option<bool> = obj.get("isTaxIncludedInPrice")?;
        let rate_: Option<f64> = obj.get("rate")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let expiration_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("expirationDate")?;
        let name_: Option<String> = obj.get("name")?;
        let category_: Option<String> = obj.get("category")?;
        let details_: Option<String> = obj.get("details")?;
        let country_: Option<String> = obj.get("country")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let jurisdiction_: Option<String> = obj.get("jurisdiction")?;
        let tax_code_: Option<String> = obj.get("taxCode")?;
        let val = Self {
            active: active_,
            effective_date: effective_date_,
            tax_registration_number: tax_registration_number_,
            updated_at: updated_at_,
            region: region_,
            id: id_,
            is_tax_included_in_price: is_tax_included_in_price_,
            rate: rate_,
            deleted: deleted_,
            currency: currency_,
            created_at: created_at_,
            expiration_date: expiration_date_,
            name: name_,
            category: category_,
            details: details_,
            country: country_,
            amount: amount_,
            jurisdiction: jurisdiction_,
            tax_code: tax_code_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TaxDetails {}
pub struct Evidence {
    pub customer_signature: Option<String>,
    pub shipping_address: Option<String>,
    pub service_documentation: Option<String>,
    pub cancellation_rebuttal: Option<String>,
    pub product_description: Option<String>,
    pub billing_address: Option<String>,
    pub customer_communication: Option<String>,
    pub customer_email_address: Option<String>,
    pub cancellation_policy_disclosure: Option<String>,
    pub duplicate_charge_explanation: Option<String>,
    pub refund_policy: Option<String>,
    pub access_activity_log: Option<String>,
    pub receipt: Option<String>,
    pub refund_refusal_explanation: Option<String>,
    pub shipping_carrier: Option<String>,
    pub duplicate_charge_id: Option<String>,
    pub duplicate_charge_documentation: Option<String>,
    pub cancellation_policy: Option<String>,
    pub customer_purchase_ip: Option<String>,
    pub refund_policy_disclosure: Option<String>,
    pub service_date: Option<chrono::DateTime<chrono::Utc>>,
    pub shipping_date: Option<chrono::DateTime<chrono::Utc>>,
    pub shipping_tracking_number: Option<String>,
    pub uncategorized_text: Option<String>,
    pub uncategorized_file: Option<String>,
    pub shipping_documentation: Option<String>,
    pub customer_name: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Evidence {
    fn type_name() -> &'static str {
        "Evidence"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Evidence {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Evidence,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            customer_signature: customer_signature_,
            shipping_address: shipping_address_,
            service_documentation: service_documentation_,
            cancellation_rebuttal: cancellation_rebuttal_,
            product_description: product_description_,
            billing_address: billing_address_,
            customer_communication: customer_communication_,
            customer_email_address: customer_email_address_,
            cancellation_policy_disclosure: cancellation_policy_disclosure_,
            duplicate_charge_explanation: duplicate_charge_explanation_,
            refund_policy: refund_policy_,
            access_activity_log: access_activity_log_,
            receipt: receipt_,
            refund_refusal_explanation: refund_refusal_explanation_,
            shipping_carrier: shipping_carrier_,
            duplicate_charge_id: duplicate_charge_id_,
            duplicate_charge_documentation: duplicate_charge_documentation_,
            cancellation_policy: cancellation_policy_,
            customer_purchase_ip: customer_purchase_ip_,
            refund_policy_disclosure: refund_policy_disclosure_,
            service_date: service_date_,
            shipping_date: shipping_date_,
            shipping_tracking_number: shipping_tracking_number_,
            uncategorized_text: uncategorized_text_,
            uncategorized_file: uncategorized_file_,
            shipping_documentation: shipping_documentation_,
            customer_name: customer_name_,
        } = val;
        if customer_signature_.is_some() {
            obj.set("customerSignature", customer_signature_)?;
        }
        if shipping_address_.is_some() {
            obj.set("shippingAddress", shipping_address_)?;
        }
        if service_documentation_.is_some() {
            obj.set("serviceDocumentation", service_documentation_)?;
        }
        if cancellation_rebuttal_.is_some() {
            obj.set("cancellationRebuttal", cancellation_rebuttal_)?;
        }
        if product_description_.is_some() {
            obj.set("productDescription", product_description_)?;
        }
        if billing_address_.is_some() {
            obj.set("billingAddress", billing_address_)?;
        }
        if customer_communication_.is_some() {
            obj.set("customerCommunication", customer_communication_)?;
        }
        if customer_email_address_.is_some() {
            obj.set("customerEmailAddress", customer_email_address_)?;
        }
        if cancellation_policy_disclosure_.is_some() {
            obj.set("cancellationPolicyDisclosure", cancellation_policy_disclosure_)?;
        }
        if duplicate_charge_explanation_.is_some() {
            obj.set("duplicateChargeExplanation", duplicate_charge_explanation_)?;
        }
        if refund_policy_.is_some() {
            obj.set("refundPolicy", refund_policy_)?;
        }
        if access_activity_log_.is_some() {
            obj.set("accessActivityLog", access_activity_log_)?;
        }
        if receipt_.is_some() {
            obj.set("receipt", receipt_)?;
        }
        if refund_refusal_explanation_.is_some() {
            obj.set("refundRefusalExplanation", refund_refusal_explanation_)?;
        }
        if shipping_carrier_.is_some() {
            obj.set("shippingCarrier", shipping_carrier_)?;
        }
        if duplicate_charge_id_.is_some() {
            obj.set("duplicateChargeId", duplicate_charge_id_)?;
        }
        if duplicate_charge_documentation_.is_some() {
            obj.set("duplicateChargeDocumentation", duplicate_charge_documentation_)?;
        }
        if cancellation_policy_.is_some() {
            obj.set("cancellationPolicy", cancellation_policy_)?;
        }
        if customer_purchase_ip_.is_some() {
            obj.set("customerPurchaseIp", customer_purchase_ip_)?;
        }
        if refund_policy_disclosure_.is_some() {
            obj.set("refundPolicyDisclosure", refund_policy_disclosure_)?;
        }
        if service_date_.is_some() {
            obj.set("serviceDate", service_date_)?;
        }
        if shipping_date_.is_some() {
            obj.set("shippingDate", shipping_date_)?;
        }
        if shipping_tracking_number_.is_some() {
            obj.set("shippingTrackingNumber", shipping_tracking_number_)?;
        }
        if uncategorized_text_.is_some() {
            obj.set("uncategorizedText", uncategorized_text_)?;
        }
        if uncategorized_file_.is_some() {
            obj.set("uncategorizedFile", uncategorized_file_)?;
        }
        if shipping_documentation_.is_some() {
            obj.set("shippingDocumentation", shipping_documentation_)?;
        }
        if customer_name_.is_some() {
            obj.set("customerName", customer_name_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Evidence {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let customer_signature_: Option<String> = obj.get("customerSignature")?;
        let shipping_address_: Option<String> = obj.get("shippingAddress")?;
        let service_documentation_: Option<String> = obj.get("serviceDocumentation")?;
        let cancellation_rebuttal_: Option<String> = obj.get("cancellationRebuttal")?;
        let product_description_: Option<String> = obj.get("productDescription")?;
        let billing_address_: Option<String> = obj.get("billingAddress")?;
        let customer_communication_: Option<String> = obj.get("customerCommunication")?;
        let customer_email_address_: Option<String> = obj.get("customerEmailAddress")?;
        let cancellation_policy_disclosure_: Option<String> = obj
            .get("cancellationPolicyDisclosure")?;
        let duplicate_charge_explanation_: Option<String> = obj
            .get("duplicateChargeExplanation")?;
        let refund_policy_: Option<String> = obj.get("refundPolicy")?;
        let access_activity_log_: Option<String> = obj.get("accessActivityLog")?;
        let receipt_: Option<String> = obj.get("receipt")?;
        let refund_refusal_explanation_: Option<String> = obj
            .get("refundRefusalExplanation")?;
        let shipping_carrier_: Option<String> = obj.get("shippingCarrier")?;
        let duplicate_charge_id_: Option<String> = obj.get("duplicateChargeId")?;
        let duplicate_charge_documentation_: Option<String> = obj
            .get("duplicateChargeDocumentation")?;
        let cancellation_policy_: Option<String> = obj.get("cancellationPolicy")?;
        let customer_purchase_ip_: Option<String> = obj.get("customerPurchaseIp")?;
        let refund_policy_disclosure_: Option<String> = obj
            .get("refundPolicyDisclosure")?;
        let service_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("serviceDate")?;
        let shipping_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("shippingDate")?;
        let shipping_tracking_number_: Option<String> = obj
            .get("shippingTrackingNumber")?;
        let uncategorized_text_: Option<String> = obj.get("uncategorizedText")?;
        let uncategorized_file_: Option<String> = obj.get("uncategorizedFile")?;
        let shipping_documentation_: Option<String> = obj.get("shippingDocumentation")?;
        let customer_name_: Option<String> = obj.get("customerName")?;
        let val = Self {
            customer_signature: customer_signature_,
            shipping_address: shipping_address_,
            service_documentation: service_documentation_,
            cancellation_rebuttal: cancellation_rebuttal_,
            product_description: product_description_,
            billing_address: billing_address_,
            customer_communication: customer_communication_,
            customer_email_address: customer_email_address_,
            cancellation_policy_disclosure: cancellation_policy_disclosure_,
            duplicate_charge_explanation: duplicate_charge_explanation_,
            refund_policy: refund_policy_,
            access_activity_log: access_activity_log_,
            receipt: receipt_,
            refund_refusal_explanation: refund_refusal_explanation_,
            shipping_carrier: shipping_carrier_,
            duplicate_charge_id: duplicate_charge_id_,
            duplicate_charge_documentation: duplicate_charge_documentation_,
            cancellation_policy: cancellation_policy_,
            customer_purchase_ip: customer_purchase_ip_,
            refund_policy_disclosure: refund_policy_disclosure_,
            service_date: service_date_,
            shipping_date: shipping_date_,
            shipping_tracking_number: shipping_tracking_number_,
            uncategorized_text: uncategorized_text_,
            uncategorized_file: uncategorized_file_,
            shipping_documentation: shipping_documentation_,
            customer_name: customer_name_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Evidence {}
pub struct Disputes {
    pub charge: Option<String>,
    pub active: Option<bool>,
    pub amount: Option<f64>,
    pub currency: Option<Currency>,
    pub version: Option<String>,
    pub customer_id: Option<String>,
    pub deleted: Option<bool>,
    pub created: Option<chrono::DateTime<chrono::Utc>>,
    pub notes: Option<String>,
    pub reason: Option<String>,
    pub transaction_id: Option<String>,
    pub id: Option<String>,
    pub charge_refundable: Option<bool>,
    pub metadata: Option<Metadata>,
    pub updated: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<FinancialDisputeStatus>,
    pub evidence: Option<Evidence>,
}
impl napi::bindgen_prelude::TypeName for Disputes {
    fn type_name() -> &'static str {
        "Disputes"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Disputes {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Disputes,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            charge: charge_,
            active: active_,
            amount: amount_,
            currency: currency_,
            version: version_,
            customer_id: customer_id_,
            deleted: deleted_,
            created: created_,
            notes: notes_,
            reason: reason_,
            transaction_id: transaction_id_,
            id: id_,
            charge_refundable: charge_refundable_,
            metadata: metadata_,
            updated: updated_,
            status: status_,
            evidence: evidence_,
        } = val;
        if charge_.is_some() {
            obj.set("charge", charge_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if version_.is_some() {
            obj.set("version", version_)?;
        }
        if customer_id_.is_some() {
            obj.set("customerId", customer_id_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if created_.is_some() {
            obj.set("created", created_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if reason_.is_some() {
            obj.set("reason", reason_)?;
        }
        if transaction_id_.is_some() {
            obj.set("transactionId", transaction_id_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if charge_refundable_.is_some() {
            obj.set("chargeRefundable", charge_refundable_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if updated_.is_some() {
            obj.set("updated", updated_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if evidence_.is_some() {
            obj.set("evidence", evidence_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Disputes {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let charge_: Option<String> = obj.get("charge")?;
        let active_: Option<bool> = obj.get("active")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let version_: Option<String> = obj.get("version")?;
        let customer_id_: Option<String> = obj.get("customerId")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let created_: Option<chrono::DateTime<chrono::Utc>> = obj.get("created")?;
        let notes_: Option<String> = obj.get("notes")?;
        let reason_: Option<String> = obj.get("reason")?;
        let transaction_id_: Option<String> = obj.get("transactionId")?;
        let id_: Option<String> = obj.get("id")?;
        let charge_refundable_: Option<bool> = obj.get("chargeRefundable")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let updated_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updated")?;
        let status_: Option<FinancialDisputeStatus> = obj.get("status")?;
        let evidence_: Option<Evidence> = obj.get("evidence")?;
        let val = Self {
            charge: charge_,
            active: active_,
            amount: amount_,
            currency: currency_,
            version: version_,
            customer_id: customer_id_,
            deleted: deleted_,
            created: created_,
            notes: notes_,
            reason: reason_,
            transaction_id: transaction_id_,
            id: id_,
            charge_refundable: charge_refundable_,
            metadata: metadata_,
            updated: updated_,
            status: status_,
            evidence: evidence_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Disputes {}
pub struct Reactions {
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub user_id: Option<String>,
    pub r#type: Option<ReactionType>,
    pub message_id: Option<String>,
    pub chat_id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Reactions {
    fn type_name() -> &'static str {
        "Reactions"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Reactions {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Reactions,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            created_at: created_at_,
            user_id: user_id_,
            r#type: type_,
            message_id: message_id_,
            chat_id: chat_id_,
        } = val;
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if user_id_.is_some() {
            obj.set("userId", user_id_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if message_id_.is_some() {
            obj.set("messageId", message_id_)?;
        }
        if chat_id_.is_some() {
            obj.set("chatId", chat_id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Reactions {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let user_id_: Option<String> = obj.get("userId")?;
        let type_: Option<ReactionType> = obj.get("type")?;
        let message_id_: Option<String> = obj.get("messageId")?;
        let chat_id_: Option<String> = obj.get("chatId")?;
        let val = Self {
            created_at: created_at_,
            user_id: user_id_,
            r#type: type_,
            message_id: message_id_,
            chat_id: chat_id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Reactions {}
pub struct Participants {
    pub display_name: Option<String>,
    pub status: Option<ParticipantEngagementStatus>,
    pub r#type: Option<CommunicationRole>,
    pub user_id: Option<String>,
    pub joined_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Participants {
    fn type_name() -> &'static str {
        "Participants"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Participants {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Participants,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            display_name: display_name_,
            status: status_,
            r#type: type_,
            user_id: user_id_,
            joined_at: joined_at_,
        } = val;
        if display_name_.is_some() {
            obj.set("displayName", display_name_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if user_id_.is_some() {
            obj.set("userId", user_id_)?;
        }
        if joined_at_.is_some() {
            obj.set("joinedAt", joined_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Participants {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let display_name_: Option<String> = obj.get("displayName")?;
        let status_: Option<ParticipantEngagementStatus> = obj.get("status")?;
        let type_: Option<CommunicationRole> = obj.get("type")?;
        let user_id_: Option<String> = obj.get("userId")?;
        let joined_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("joinedAt")?;
        let val = Self {
            display_name: display_name_,
            status: status_,
            r#type: type_,
            user_id: user_id_,
            joined_at: joined_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Participants {}
pub struct Messages {
    pub metadata: Option<Vec<Metadata>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    pub content: Option<String>,
    pub attachments: Option<Vec<Attachments>>,
    pub active: Option<bool>,
    pub chat_id: Option<String>,
    pub deleted: Option<bool>,
    pub reply_to_message_id: Option<String>,
    pub sender_id: Option<String>,
    pub priority: Option<PriorityLevel>,
    pub read_status: Option<MessageReadStatus>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub receiver_id: Option<String>,
    pub thread_id: Option<String>,
    pub delivery_status: Option<MessageDeliveryStatus>,
    pub reactions: Option<Vec<Reactions>>,
    pub r#type: Option<MessageContentType>,
    pub modify_token: Option<String>,
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Messages {
    fn type_name() -> &'static str {
        "Messages"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Messages {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Messages,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            metadata: metadata_,
            created_at: created_at_,
            id: id_,
            content: content_,
            attachments: attachments_,
            active: active_,
            chat_id: chat_id_,
            deleted: deleted_,
            reply_to_message_id: reply_to_message_id_,
            sender_id: sender_id_,
            priority: priority_,
            read_status: read_status_,
            updated_at: updated_at_,
            receiver_id: receiver_id_,
            thread_id: thread_id_,
            delivery_status: delivery_status_,
            reactions: reactions_,
            r#type: type_,
            modify_token: modify_token_,
            timestamp: timestamp_,
        } = val;
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if content_.is_some() {
            obj.set("content", content_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if chat_id_.is_some() {
            obj.set("chatId", chat_id_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if reply_to_message_id_.is_some() {
            obj.set("replyToMessageId", reply_to_message_id_)?;
        }
        if sender_id_.is_some() {
            obj.set("senderId", sender_id_)?;
        }
        if priority_.is_some() {
            obj.set("priority", priority_)?;
        }
        if read_status_.is_some() {
            obj.set("readStatus", read_status_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if receiver_id_.is_some() {
            obj.set("receiverId", receiver_id_)?;
        }
        if thread_id_.is_some() {
            obj.set("threadId", thread_id_)?;
        }
        if delivery_status_.is_some() {
            obj.set("deliveryStatus", delivery_status_)?;
        }
        if reactions_.is_some() {
            obj.set("reactions", reactions_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if timestamp_.is_some() {
            obj.set("timestamp", timestamp_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Messages {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let metadata_: Option<Vec<Metadata>> = obj.get("metadata")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let id_: Option<String> = obj.get("id")?;
        let content_: Option<String> = obj.get("content")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let active_: Option<bool> = obj.get("active")?;
        let chat_id_: Option<String> = obj.get("chatId")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let reply_to_message_id_: Option<String> = obj.get("replyToMessageId")?;
        let sender_id_: Option<String> = obj.get("senderId")?;
        let priority_: Option<PriorityLevel> = obj.get("priority")?;
        let read_status_: Option<MessageReadStatus> = obj.get("readStatus")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let receiver_id_: Option<String> = obj.get("receiverId")?;
        let thread_id_: Option<String> = obj.get("threadId")?;
        let delivery_status_: Option<MessageDeliveryStatus> = obj.get("deliveryStatus")?;
        let reactions_: Option<Vec<Reactions>> = obj.get("reactions")?;
        let type_: Option<MessageContentType> = obj.get("type")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let timestamp_: Option<chrono::DateTime<chrono::Utc>> = obj.get("timestamp")?;
        let val = Self {
            metadata: metadata_,
            created_at: created_at_,
            id: id_,
            content: content_,
            attachments: attachments_,
            active: active_,
            chat_id: chat_id_,
            deleted: deleted_,
            reply_to_message_id: reply_to_message_id_,
            sender_id: sender_id_,
            priority: priority_,
            read_status: read_status_,
            updated_at: updated_at_,
            receiver_id: receiver_id_,
            thread_id: thread_id_,
            delivery_status: delivery_status_,
            reactions: reactions_,
            r#type: type_,
            modify_token: modify_token_,
            timestamp: timestamp_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Messages {}
pub struct Chats {
    pub participants: Option<Vec<Participants>>,
    pub id: Option<String>,
    pub status: Option<ConversationStatus>,
    pub modify_token: Option<String>,
    pub last_read_message_id: Option<String>,
    pub messages: Option<Vec<Messages>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub last_message: Option<Messages>,
    pub metadata: Option<String>,
    pub title: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub unread_count: Option<f64>,
    pub r#type: Option<ChatType>,
    pub is_pinned: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Chats {
    fn type_name() -> &'static str {
        "Chats"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Chats {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Chats,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            participants: participants_,
            id: id_,
            status: status_,
            modify_token: modify_token_,
            last_read_message_id: last_read_message_id_,
            messages: messages_,
            created_at: created_at_,
            last_message: last_message_,
            metadata: metadata_,
            title: title_,
            updated_at: updated_at_,
            unread_count: unread_count_,
            r#type: type_,
            is_pinned: is_pinned_,
        } = val;
        if participants_.is_some() {
            obj.set("participants", participants_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if last_read_message_id_.is_some() {
            obj.set("lastReadMessageId", last_read_message_id_)?;
        }
        if messages_.is_some() {
            obj.set("messages", messages_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if last_message_.is_some() {
            obj.set("lastMessage", last_message_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if unread_count_.is_some() {
            obj.set("unreadCount", unread_count_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if is_pinned_.is_some() {
            obj.set("isPinned", is_pinned_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Chats {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let participants_: Option<Vec<Participants>> = obj.get("participants")?;
        let id_: Option<String> = obj.get("id")?;
        let status_: Option<ConversationStatus> = obj.get("status")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let last_read_message_id_: Option<String> = obj.get("lastReadMessageId")?;
        let messages_: Option<Vec<Messages>> = obj.get("messages")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let last_message_: Option<Messages> = obj.get("lastMessage")?;
        let metadata_: Option<String> = obj.get("metadata")?;
        let title_: Option<String> = obj.get("title")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let unread_count_: Option<f64> = obj.get("unreadCount")?;
        let type_: Option<ChatType> = obj.get("type")?;
        let is_pinned_: Option<bool> = obj.get("isPinned")?;
        let val = Self {
            participants: participants_,
            id: id_,
            status: status_,
            modify_token: modify_token_,
            last_read_message_id: last_read_message_id_,
            messages: messages_,
            created_at: created_at_,
            last_message: last_message_,
            metadata: metadata_,
            title: title_,
            updated_at: updated_at_,
            unread_count: unread_count_,
            r#type: type_,
            is_pinned: is_pinned_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Chats {}
pub struct ShareholderEquityDetails {
    pub accumulated_other_comprehensive_income: Option<f64>,
    pub preferred_stock: Option<f64>,
    pub common_stock: Option<f64>,
    pub treasury_stock: Option<f64>,
    pub retained_earnings: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for ShareholderEquityDetails {
    fn type_name() -> &'static str {
        "ShareholderEquityDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for ShareholderEquityDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: ShareholderEquityDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            accumulated_other_comprehensive_income: accumulated_other_comprehensive_income_,
            preferred_stock: preferred_stock_,
            common_stock: common_stock_,
            treasury_stock: treasury_stock_,
            retained_earnings: retained_earnings_,
        } = val;
        if accumulated_other_comprehensive_income_.is_some() {
            obj.set(
                "accumulatedOtherComprehensiveIncome",
                accumulated_other_comprehensive_income_,
            )?;
        }
        if preferred_stock_.is_some() {
            obj.set("preferredStock", preferred_stock_)?;
        }
        if common_stock_.is_some() {
            obj.set("commonStock", common_stock_)?;
        }
        if treasury_stock_.is_some() {
            obj.set("treasuryStock", treasury_stock_)?;
        }
        if retained_earnings_.is_some() {
            obj.set("retainedEarnings", retained_earnings_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for ShareholderEquityDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let accumulated_other_comprehensive_income_: Option<f64> = obj
            .get("accumulatedOtherComprehensiveIncome")?;
        let preferred_stock_: Option<f64> = obj.get("preferredStock")?;
        let common_stock_: Option<f64> = obj.get("commonStock")?;
        let treasury_stock_: Option<f64> = obj.get("treasuryStock")?;
        let retained_earnings_: Option<f64> = obj.get("retainedEarnings")?;
        let val = Self {
            accumulated_other_comprehensive_income: accumulated_other_comprehensive_income_,
            preferred_stock: preferred_stock_,
            common_stock: common_stock_,
            treasury_stock: treasury_stock_,
            retained_earnings: retained_earnings_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ShareholderEquityDetails {}
pub struct IncomeTaxExpenseDetails {
    pub deferred_income_tax: Option<f64>,
    pub current_income_tax: Option<f64>,
    pub tax_allowance_credit: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for IncomeTaxExpenseDetails {
    fn type_name() -> &'static str {
        "IncomeTaxExpenseDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for IncomeTaxExpenseDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: IncomeTaxExpenseDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            deferred_income_tax: deferred_income_tax_,
            current_income_tax: current_income_tax_,
            tax_allowance_credit: tax_allowance_credit_,
        } = val;
        if deferred_income_tax_.is_some() {
            obj.set("deferredIncomeTax", deferred_income_tax_)?;
        }
        if current_income_tax_.is_some() {
            obj.set("currentIncomeTax", current_income_tax_)?;
        }
        if tax_allowance_credit_.is_some() {
            obj.set("taxAllowanceCredit", tax_allowance_credit_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for IncomeTaxExpenseDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let deferred_income_tax_: Option<f64> = obj.get("deferredIncomeTax")?;
        let current_income_tax_: Option<f64> = obj.get("currentIncomeTax")?;
        let tax_allowance_credit_: Option<f64> = obj.get("taxAllowanceCredit")?;
        let val = Self {
            deferred_income_tax: deferred_income_tax_,
            current_income_tax: current_income_tax_,
            tax_allowance_credit: tax_allowance_credit_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for IncomeTaxExpenseDetails {}
pub struct OperatingExpensesDetails {
    pub sales_general_and_administrative_expenses: Option<f64>,
    pub research_and_development_expenses: Option<f64>,
    pub other_operating_expenses: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for OperatingExpensesDetails {
    fn type_name() -> &'static str {
        "OperatingExpensesDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for OperatingExpensesDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: OperatingExpensesDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            sales_general_and_administrative_expenses: sales_general_and_administrative_expenses_,
            research_and_development_expenses: research_and_development_expenses_,
            other_operating_expenses: other_operating_expenses_,
        } = val;
        if sales_general_and_administrative_expenses_.is_some() {
            obj.set(
                "salesGeneralAndAdministrativeExpenses",
                sales_general_and_administrative_expenses_,
            )?;
        }
        if research_and_development_expenses_.is_some() {
            obj.set(
                "researchAndDevelopmentExpenses",
                research_and_development_expenses_,
            )?;
        }
        if other_operating_expenses_.is_some() {
            obj.set("otherOperatingExpenses", other_operating_expenses_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for OperatingExpensesDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let sales_general_and_administrative_expenses_: Option<f64> = obj
            .get("salesGeneralAndAdministrativeExpenses")?;
        let research_and_development_expenses_: Option<f64> = obj
            .get("researchAndDevelopmentExpenses")?;
        let other_operating_expenses_: Option<f64> = obj.get("otherOperatingExpenses")?;
        let val = Self {
            sales_general_and_administrative_expenses: sales_general_and_administrative_expenses_,
            research_and_development_expenses: research_and_development_expenses_,
            other_operating_expenses: other_operating_expenses_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for OperatingExpensesDetails {}
pub struct RevenueDetails {
    pub other_revenue: Option<f64>,
    pub service_revenue: Option<f64>,
    pub sales_revenue: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for RevenueDetails {
    fn type_name() -> &'static str {
        "RevenueDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for RevenueDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: RevenueDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            other_revenue: other_revenue_,
            service_revenue: service_revenue_,
            sales_revenue: sales_revenue_,
        } = val;
        if other_revenue_.is_some() {
            obj.set("otherRevenue", other_revenue_)?;
        }
        if service_revenue_.is_some() {
            obj.set("serviceRevenue", service_revenue_)?;
        }
        if sales_revenue_.is_some() {
            obj.set("salesRevenue", sales_revenue_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for RevenueDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let other_revenue_: Option<f64> = obj.get("otherRevenue")?;
        let service_revenue_: Option<f64> = obj.get("serviceRevenue")?;
        let sales_revenue_: Option<f64> = obj.get("salesRevenue")?;
        let val = Self {
            other_revenue: other_revenue_,
            service_revenue: service_revenue_,
            sales_revenue: sales_revenue_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for RevenueDetails {}
pub struct ShippingItem {
    pub sku: Option<String>,
    pub product_name: Option<String>,
    pub weight_unit: Option<String>,
    pub weight: Option<f64>,
    pub id: Option<String>,
    pub product_id: Option<String>,
    pub quantity: Option<f64>,
    pub dimensions: Option<Dimensions>,
    pub value: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for ShippingItem {
    fn type_name() -> &'static str {
        "ShippingItem"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for ShippingItem {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: ShippingItem,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            sku: sku_,
            product_name: product_name_,
            weight_unit: weight_unit_,
            weight: weight_,
            id: id_,
            product_id: product_id_,
            quantity: quantity_,
            dimensions: dimensions_,
            value: value_,
        } = val;
        if sku_.is_some() {
            obj.set("sku", sku_)?;
        }
        if product_name_.is_some() {
            obj.set("productName", product_name_)?;
        }
        if weight_unit_.is_some() {
            obj.set("weightUnit", weight_unit_)?;
        }
        if weight_.is_some() {
            obj.set("weight", weight_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if product_id_.is_some() {
            obj.set("productId", product_id_)?;
        }
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        if dimensions_.is_some() {
            obj.set("dimensions", dimensions_)?;
        }
        if value_.is_some() {
            obj.set("value", value_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for ShippingItem {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let sku_: Option<String> = obj.get("sku")?;
        let product_name_: Option<String> = obj.get("productName")?;
        let weight_unit_: Option<String> = obj.get("weightUnit")?;
        let weight_: Option<f64> = obj.get("weight")?;
        let id_: Option<String> = obj.get("id")?;
        let product_id_: Option<String> = obj.get("productId")?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let dimensions_: Option<Dimensions> = obj.get("dimensions")?;
        let value_: Option<f64> = obj.get("value")?;
        let val = Self {
            sku: sku_,
            product_name: product_name_,
            weight_unit: weight_unit_,
            weight: weight_,
            id: id_,
            product_id: product_id_,
            quantity: quantity_,
            dimensions: dimensions_,
            value: value_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ShippingItem {}
pub struct BillingDetails {
    pub vat_id: Option<String>,
    pub note: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub language: Option<String>,
    pub full_name: Option<String>,
    pub customer_id: Option<String>,
    pub is_deleted: Option<bool>,
    pub default_payment_method: Option<PaymentMethods>,
    pub email: Option<String>,
    pub phone_number: Option<String>,
    pub company_name: Option<String>,
    pub active: Option<bool>,
    pub address: Option<Addresses>,
    pub payment_terms: Option<PaymentTerm>,
    pub currency: Option<Currency>,
    pub id: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub additional_attributes: Option<Vec<CustomAttributes>>,
}
impl napi::bindgen_prelude::TypeName for BillingDetails {
    fn type_name() -> &'static str {
        "BillingDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for BillingDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: BillingDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            vat_id: vat_id_,
            note: note_,
            created_at: created_at_,
            language: language_,
            full_name: full_name_,
            customer_id: customer_id_,
            is_deleted: is_deleted_,
            default_payment_method: default_payment_method_,
            email: email_,
            phone_number: phone_number_,
            company_name: company_name_,
            active: active_,
            address: address_,
            payment_terms: payment_terms_,
            currency: currency_,
            id: id_,
            updated_at: updated_at_,
            additional_attributes: additional_attributes_,
        } = val;
        if vat_id_.is_some() {
            obj.set("vatId", vat_id_)?;
        }
        if note_.is_some() {
            obj.set("note", note_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if language_.is_some() {
            obj.set("language", language_)?;
        }
        if full_name_.is_some() {
            obj.set("fullName", full_name_)?;
        }
        if customer_id_.is_some() {
            obj.set("customerId", customer_id_)?;
        }
        if is_deleted_.is_some() {
            obj.set("isDeleted", is_deleted_)?;
        }
        if default_payment_method_.is_some() {
            obj.set("defaultPaymentMethod", default_payment_method_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if phone_number_.is_some() {
            obj.set("phoneNumber", phone_number_)?;
        }
        if company_name_.is_some() {
            obj.set("companyName", company_name_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if payment_terms_.is_some() {
            obj.set("paymentTerms", payment_terms_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if additional_attributes_.is_some() {
            obj.set("additionalAttributes", additional_attributes_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for BillingDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let vat_id_: Option<String> = obj.get("vatId")?;
        let note_: Option<String> = obj.get("note")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let language_: Option<String> = obj.get("language")?;
        let full_name_: Option<String> = obj.get("fullName")?;
        let customer_id_: Option<String> = obj.get("customerId")?;
        let is_deleted_: Option<bool> = obj.get("isDeleted")?;
        let default_payment_method_: Option<PaymentMethods> = obj
            .get("defaultPaymentMethod")?;
        let email_: Option<String> = obj.get("email")?;
        let phone_number_: Option<String> = obj.get("phoneNumber")?;
        let company_name_: Option<String> = obj.get("companyName")?;
        let active_: Option<bool> = obj.get("active")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let payment_terms_: Option<PaymentTerm> = obj.get("paymentTerms")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let id_: Option<String> = obj.get("id")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let additional_attributes_: Option<Vec<CustomAttributes>> = obj
            .get("additionalAttributes")?;
        let val = Self {
            vat_id: vat_id_,
            note: note_,
            created_at: created_at_,
            language: language_,
            full_name: full_name_,
            customer_id: customer_id_,
            is_deleted: is_deleted_,
            default_payment_method: default_payment_method_,
            email: email_,
            phone_number: phone_number_,
            company_name: company_name_,
            active: active_,
            address: address_,
            payment_terms: payment_terms_,
            currency: currency_,
            id: id_,
            updated_at: updated_at_,
            additional_attributes: additional_attributes_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for BillingDetails {}
pub struct PaymentTerms {
    pub r#type: Option<PaymentTerm>,
    pub country_specific_terms: Option<Vec<String>>,
    pub discount_days: Option<f64>,
    pub permitted_client_classes: Option<Vec<String>>,
    pub due_days: Option<f64>,
    pub created_date: Option<chrono::DateTime<chrono::Utc>>,
    pub last_updated_date: Option<chrono::DateTime<chrono::Utc>>,
    pub language_support: Option<Vec<String>>,
    pub currency_formatting: Option<String>,
    pub notes: Option<String>,
    pub grace_period_days: Option<f64>,
    pub allowed_methods: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub interest_rate: Option<f64>,
    pub minimum_payment: Option<f64>,
    pub is_deleted: Option<bool>,
    pub currency_code: Option<String>,
    pub discount_rate: Option<f64>,
    pub is_active: Option<bool>,
    pub id: Option<String>,
    pub description: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub penalty_rate: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for PaymentTerms {
    fn type_name() -> &'static str {
        "PaymentTerms"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for PaymentTerms {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: PaymentTerms,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            r#type: type_,
            country_specific_terms: country_specific_terms_,
            discount_days: discount_days_,
            permitted_client_classes: permitted_client_classes_,
            due_days: due_days_,
            created_date: created_date_,
            last_updated_date: last_updated_date_,
            language_support: language_support_,
            currency_formatting: currency_formatting_,
            notes: notes_,
            grace_period_days: grace_period_days_,
            allowed_methods: allowed_methods_,
            updated_at: updated_at_,
            interest_rate: interest_rate_,
            minimum_payment: minimum_payment_,
            is_deleted: is_deleted_,
            currency_code: currency_code_,
            discount_rate: discount_rate_,
            is_active: is_active_,
            id: id_,
            description: description_,
            created_at: created_at_,
            penalty_rate: penalty_rate_,
        } = val;
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if country_specific_terms_.is_some() {
            obj.set("countrySpecificTerms", country_specific_terms_)?;
        }
        if discount_days_.is_some() {
            obj.set("discountDays", discount_days_)?;
        }
        if permitted_client_classes_.is_some() {
            obj.set("permittedClientClasses", permitted_client_classes_)?;
        }
        if due_days_.is_some() {
            obj.set("dueDays", due_days_)?;
        }
        if created_date_.is_some() {
            obj.set("createdDate", created_date_)?;
        }
        if last_updated_date_.is_some() {
            obj.set("lastUpdatedDate", last_updated_date_)?;
        }
        if language_support_.is_some() {
            obj.set("languageSupport", language_support_)?;
        }
        if currency_formatting_.is_some() {
            obj.set("currencyFormatting", currency_formatting_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if grace_period_days_.is_some() {
            obj.set("gracePeriodDays", grace_period_days_)?;
        }
        if allowed_methods_.is_some() {
            obj.set("allowedMethods", allowed_methods_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if interest_rate_.is_some() {
            obj.set("interestRate", interest_rate_)?;
        }
        if minimum_payment_.is_some() {
            obj.set("minimumPayment", minimum_payment_)?;
        }
        if is_deleted_.is_some() {
            obj.set("isDeleted", is_deleted_)?;
        }
        if currency_code_.is_some() {
            obj.set("currencyCode", currency_code_)?;
        }
        if discount_rate_.is_some() {
            obj.set("discountRate", discount_rate_)?;
        }
        if is_active_.is_some() {
            obj.set("isActive", is_active_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if penalty_rate_.is_some() {
            obj.set("penaltyRate", penalty_rate_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for PaymentTerms {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let type_: Option<PaymentTerm> = obj.get("type")?;
        let country_specific_terms_: Option<Vec<String>> = obj
            .get("countrySpecificTerms")?;
        let discount_days_: Option<f64> = obj.get("discountDays")?;
        let permitted_client_classes_: Option<Vec<String>> = obj
            .get("permittedClientClasses")?;
        let due_days_: Option<f64> = obj.get("dueDays")?;
        let created_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("createdDate")?;
        let last_updated_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("lastUpdatedDate")?;
        let language_support_: Option<Vec<String>> = obj.get("languageSupport")?;
        let currency_formatting_: Option<String> = obj.get("currencyFormatting")?;
        let notes_: Option<String> = obj.get("notes")?;
        let grace_period_days_: Option<f64> = obj.get("gracePeriodDays")?;
        let allowed_methods_: Option<Vec<String>> = obj.get("allowedMethods")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let interest_rate_: Option<f64> = obj.get("interestRate")?;
        let minimum_payment_: Option<f64> = obj.get("minimumPayment")?;
        let is_deleted_: Option<bool> = obj.get("isDeleted")?;
        let currency_code_: Option<String> = obj.get("currencyCode")?;
        let discount_rate_: Option<f64> = obj.get("discountRate")?;
        let is_active_: Option<bool> = obj.get("isActive")?;
        let id_: Option<String> = obj.get("id")?;
        let description_: Option<String> = obj.get("description")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let penalty_rate_: Option<f64> = obj.get("penaltyRate")?;
        let val = Self {
            r#type: type_,
            country_specific_terms: country_specific_terms_,
            discount_days: discount_days_,
            permitted_client_classes: permitted_client_classes_,
            due_days: due_days_,
            created_date: created_date_,
            last_updated_date: last_updated_date_,
            language_support: language_support_,
            currency_formatting: currency_formatting_,
            notes: notes_,
            grace_period_days: grace_period_days_,
            allowed_methods: allowed_methods_,
            updated_at: updated_at_,
            interest_rate: interest_rate_,
            minimum_payment: minimum_payment_,
            is_deleted: is_deleted_,
            currency_code: currency_code_,
            discount_rate: discount_rate_,
            is_active: is_active_,
            id: id_,
            description: description_,
            created_at: created_at_,
            penalty_rate: penalty_rate_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PaymentTerms {}
pub struct InvoiceAdjustments {
    pub applied_to_invoice_item_id: Option<String>,
    pub active: Option<bool>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub metadata: Option<Metadata>,
    pub description: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub id: Option<String>,
    pub r#type: Option<InvoiceAdjustmentType>,
    pub amount: Option<f64>,
    pub currency: Option<Currency>,
}
impl napi::bindgen_prelude::TypeName for InvoiceAdjustments {
    fn type_name() -> &'static str {
        "InvoiceAdjustments"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for InvoiceAdjustments {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: InvoiceAdjustments,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            applied_to_invoice_item_id: applied_to_invoice_item_id_,
            active: active_,
            updated_at: updated_at_,
            metadata: metadata_,
            description: description_,
            created_at: created_at_,
            deleted: deleted_,
            id: id_,
            r#type: type_,
            amount: amount_,
            currency: currency_,
        } = val;
        if applied_to_invoice_item_id_.is_some() {
            obj.set("appliedToInvoiceItemId", applied_to_invoice_item_id_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for InvoiceAdjustments {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let applied_to_invoice_item_id_: Option<String> = obj
            .get("appliedToInvoiceItemId")?;
        let active_: Option<bool> = obj.get("active")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let description_: Option<String> = obj.get("description")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let id_: Option<String> = obj.get("id")?;
        let type_: Option<InvoiceAdjustmentType> = obj.get("type")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let val = Self {
            applied_to_invoice_item_id: applied_to_invoice_item_id_,
            active: active_,
            updated_at: updated_at_,
            metadata: metadata_,
            description: description_,
            created_at: created_at_,
            deleted: deleted_,
            id: id_,
            r#type: type_,
            amount: amount_,
            currency: currency_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for InvoiceAdjustments {}
pub struct TaxRates {
    pub id: Option<String>,
    pub tax_number: Option<String>,
    pub currency: Option<Currency>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub shipping_included: Option<bool>,
    pub name: Option<String>,
    pub tax_provider: Option<String>,
    pub tax_type: Option<GlobalTaxType>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub modify_token: Option<String>,
    pub applicable_items: Option<Vec<String>>,
    pub country: Option<String>,
    pub region: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
    pub description: Option<String>,
    pub percentage: Option<f64>,
    pub compound: Option<bool>,
    pub deleted: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for TaxRates {
    fn type_name() -> &'static str {
        "TaxRates"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for TaxRates {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: TaxRates,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            id: id_,
            tax_number: tax_number_,
            currency: currency_,
            updated_at: updated_at_,
            shipping_included: shipping_included_,
            name: name_,
            tax_provider: tax_provider_,
            tax_type: tax_type_,
            custom_fields: custom_fields_,
            modify_token: modify_token_,
            applicable_items: applicable_items_,
            country: country_,
            region: region_,
            created_at: created_at_,
            active: active_,
            description: description_,
            percentage: percentage_,
            compound: compound_,
            deleted: deleted_,
        } = val;
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if tax_number_.is_some() {
            obj.set("taxNumber", tax_number_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if shipping_included_.is_some() {
            obj.set("shippingIncluded", shipping_included_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if tax_provider_.is_some() {
            obj.set("taxProvider", tax_provider_)?;
        }
        if tax_type_.is_some() {
            obj.set("taxType", tax_type_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if applicable_items_.is_some() {
            obj.set("applicableItems", applicable_items_)?;
        }
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if region_.is_some() {
            obj.set("region", region_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if percentage_.is_some() {
            obj.set("percentage", percentage_)?;
        }
        if compound_.is_some() {
            obj.set("compound", compound_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for TaxRates {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let id_: Option<String> = obj.get("id")?;
        let tax_number_: Option<String> = obj.get("taxNumber")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let shipping_included_: Option<bool> = obj.get("shippingIncluded")?;
        let name_: Option<String> = obj.get("name")?;
        let tax_provider_: Option<String> = obj.get("taxProvider")?;
        let tax_type_: Option<GlobalTaxType> = obj.get("taxType")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let applicable_items_: Option<Vec<String>> = obj.get("applicableItems")?;
        let country_: Option<String> = obj.get("country")?;
        let region_: Option<String> = obj.get("region")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let description_: Option<String> = obj.get("description")?;
        let percentage_: Option<f64> = obj.get("percentage")?;
        let compound_: Option<bool> = obj.get("compound")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let val = Self {
            id: id_,
            tax_number: tax_number_,
            currency: currency_,
            updated_at: updated_at_,
            shipping_included: shipping_included_,
            name: name_,
            tax_provider: tax_provider_,
            tax_type: tax_type_,
            custom_fields: custom_fields_,
            modify_token: modify_token_,
            applicable_items: applicable_items_,
            country: country_,
            region: region_,
            created_at: created_at_,
            active: active_,
            description: description_,
            percentage: percentage_,
            compound: compound_,
            deleted: deleted_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TaxRates {}
pub struct CreditNoteLines {
    pub id: Option<String>,
    pub unit_price: Option<f64>,
    pub total: Option<f64>,
    pub quantity: Option<f64>,
    pub tax_rate: Option<f64>,
    pub account: Option<String>,
    pub product: Option<Products>,
    pub description: Option<String>,
}
impl napi::bindgen_prelude::TypeName for CreditNoteLines {
    fn type_name() -> &'static str {
        "CreditNoteLines"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for CreditNoteLines {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: CreditNoteLines,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            id: id_,
            unit_price: unit_price_,
            total: total_,
            quantity: quantity_,
            tax_rate: tax_rate_,
            account: account_,
            product: product_,
            description: description_,
        } = val;
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if unit_price_.is_some() {
            obj.set("unitPrice", unit_price_)?;
        }
        if total_.is_some() {
            obj.set("total", total_)?;
        }
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        if tax_rate_.is_some() {
            obj.set("taxRate", tax_rate_)?;
        }
        if account_.is_some() {
            obj.set("account", account_)?;
        }
        if product_.is_some() {
            obj.set("product", product_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for CreditNoteLines {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let id_: Option<String> = obj.get("id")?;
        let unit_price_: Option<f64> = obj.get("unitPrice")?;
        let total_: Option<f64> = obj.get("total")?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let tax_rate_: Option<f64> = obj.get("taxRate")?;
        let account_: Option<String> = obj.get("account")?;
        let product_: Option<Products> = obj.get("product")?;
        let description_: Option<String> = obj.get("description")?;
        let val = Self {
            id: id_,
            unit_price: unit_price_,
            total: total_,
            quantity: quantity_,
            tax_rate: tax_rate_,
            account: account_,
            product: product_,
            description: description_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CreditNoteLines {}
pub struct CreditNotes {
    pub company_name: Option<String>,
    pub metadata: Option<Metadata>,
    pub lines: Option<Vec<CreditNoteLines>>,
    pub currency: Option<Currency>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub modify_token: Option<String>,
    pub number: Option<String>,
    pub attachments: Option<Vec<Attachments>>,
    pub vat_number: Option<String>,
    pub customer: Option<Customers>,
    pub issued_date: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    pub memo: Option<String>,
    pub description: Option<String>,
    pub credit_type: Option<CreditType>,
    pub billing_address: Option<Addresses>,
    pub adjustment: Option<f64>,
    pub shipping_address: Option<Addresses>,
    pub tax_amount: Option<f64>,
    pub status: Option<CreditNoteStatus>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
    pub deleted: Option<bool>,
    pub reason: Option<String>,
    pub vat_name: Option<String>,
    pub payments: Option<Vec<Payments>>,
    pub tax_rate: Option<f64>,
    pub amount: Option<f64>,
    pub company_id: Option<String>,
    pub discounts: Option<Vec<f64>>,
}
impl napi::bindgen_prelude::TypeName for CreditNotes {
    fn type_name() -> &'static str {
        "CreditNotes"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for CreditNotes {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: CreditNotes,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            company_name: company_name_,
            metadata: metadata_,
            lines: lines_,
            currency: currency_,
            created_at: created_at_,
            modify_token: modify_token_,
            number: number_,
            attachments: attachments_,
            vat_number: vat_number_,
            customer: customer_,
            issued_date: issued_date_,
            id: id_,
            memo: memo_,
            description: description_,
            credit_type: credit_type_,
            billing_address: billing_address_,
            adjustment: adjustment_,
            shipping_address: shipping_address_,
            tax_amount: tax_amount_,
            status: status_,
            updated_at: updated_at_,
            active: active_,
            deleted: deleted_,
            reason: reason_,
            vat_name: vat_name_,
            payments: payments_,
            tax_rate: tax_rate_,
            amount: amount_,
            company_id: company_id_,
            discounts: discounts_,
        } = val;
        if company_name_.is_some() {
            obj.set("companyName", company_name_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if lines_.is_some() {
            obj.set("lines", lines_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if number_.is_some() {
            obj.set("number", number_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if vat_number_.is_some() {
            obj.set("vatNumber", vat_number_)?;
        }
        if customer_.is_some() {
            obj.set("customer", customer_)?;
        }
        if issued_date_.is_some() {
            obj.set("issuedDate", issued_date_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if memo_.is_some() {
            obj.set("memo", memo_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if credit_type_.is_some() {
            obj.set("creditType", credit_type_)?;
        }
        if billing_address_.is_some() {
            obj.set("billingAddress", billing_address_)?;
        }
        if adjustment_.is_some() {
            obj.set("adjustment", adjustment_)?;
        }
        if shipping_address_.is_some() {
            obj.set("shippingAddress", shipping_address_)?;
        }
        if tax_amount_.is_some() {
            obj.set("taxAmount", tax_amount_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if reason_.is_some() {
            obj.set("reason", reason_)?;
        }
        if vat_name_.is_some() {
            obj.set("vatName", vat_name_)?;
        }
        if payments_.is_some() {
            obj.set("payments", payments_)?;
        }
        if tax_rate_.is_some() {
            obj.set("taxRate", tax_rate_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if company_id_.is_some() {
            obj.set("companyId", company_id_)?;
        }
        if discounts_.is_some() {
            obj.set("discounts", discounts_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for CreditNotes {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let company_name_: Option<String> = obj.get("companyName")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let lines_: Option<Vec<CreditNoteLines>> = obj.get("lines")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let number_: Option<String> = obj.get("number")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let vat_number_: Option<String> = obj.get("vatNumber")?;
        let customer_: Option<Customers> = obj.get("customer")?;
        let issued_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("issuedDate")?;
        let id_: Option<String> = obj.get("id")?;
        let memo_: Option<String> = obj.get("memo")?;
        let description_: Option<String> = obj.get("description")?;
        let credit_type_: Option<CreditType> = obj.get("creditType")?;
        let billing_address_: Option<Addresses> = obj.get("billingAddress")?;
        let adjustment_: Option<f64> = obj.get("adjustment")?;
        let shipping_address_: Option<Addresses> = obj.get("shippingAddress")?;
        let tax_amount_: Option<f64> = obj.get("taxAmount")?;
        let status_: Option<CreditNoteStatus> = obj.get("status")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let reason_: Option<String> = obj.get("reason")?;
        let vat_name_: Option<String> = obj.get("vatName")?;
        let payments_: Option<Vec<Payments>> = obj.get("payments")?;
        let tax_rate_: Option<f64> = obj.get("taxRate")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let company_id_: Option<String> = obj.get("companyId")?;
        let discounts_: Option<Vec<f64>> = obj.get("discounts")?;
        let val = Self {
            company_name: company_name_,
            metadata: metadata_,
            lines: lines_,
            currency: currency_,
            created_at: created_at_,
            modify_token: modify_token_,
            number: number_,
            attachments: attachments_,
            vat_number: vat_number_,
            customer: customer_,
            issued_date: issued_date_,
            id: id_,
            memo: memo_,
            description: description_,
            credit_type: credit_type_,
            billing_address: billing_address_,
            adjustment: adjustment_,
            shipping_address: shipping_address_,
            tax_amount: tax_amount_,
            status: status_,
            updated_at: updated_at_,
            active: active_,
            deleted: deleted_,
            reason: reason_,
            vat_name: vat_name_,
            payments: payments_,
            tax_rate: tax_rate_,
            amount: amount_,
            company_id: company_id_,
            discounts: discounts_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CreditNotes {}
pub struct ExpenseCategories {
    pub description: Option<String>,
    pub id: Option<String>,
    pub name: Option<String>,
}
impl napi::bindgen_prelude::TypeName for ExpenseCategories {
    fn type_name() -> &'static str {
        "ExpenseCategories"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for ExpenseCategories {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: ExpenseCategories,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { description: description_, id: id_, name: name_ } = val;
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for ExpenseCategories {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let description_: Option<String> = obj.get("description")?;
        let id_: Option<String> = obj.get("id")?;
        let name_: Option<String> = obj.get("name")?;
        let val = Self {
            description: description_,
            id: id_,
            name: name_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ExpenseCategories {}
pub struct Expenses {
    pub category: Option<ExpenseCategories>,
    pub note: Option<String>,
    pub tags: Option<Vec<String>>,
    pub report_id: Option<String>,
    pub created_by_user_id: Option<String>,
    pub approved_by_user_id: Option<String>,
    pub deleted: Option<bool>,
    pub tax: Option<Vec<Taxes>>,
    pub currency_code: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub id: Option<String>,
    pub line_items: Option<Vec<Items>>,
    pub transaction_id: Option<String>,
    pub status: Option<ExpenseApprovalStatus>,
    pub description: Option<String>,
    pub merchant: Option<String>,
    pub date_incurred: Option<chrono::DateTime<chrono::Utc>>,
    pub location: Option<Addresses>,
    pub active: Option<bool>,
    pub account_id: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub payment_method: Option<PaymentMethods>,
    pub attachments: Option<Vec<Attachments>>,
    pub receipt_urls: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub amount: Option<f64>,
    pub modify_token: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Expenses {
    fn type_name() -> &'static str {
        "Expenses"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Expenses {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Expenses,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            category: category_,
            note: note_,
            tags: tags_,
            report_id: report_id_,
            created_by_user_id: created_by_user_id_,
            approved_by_user_id: approved_by_user_id_,
            deleted: deleted_,
            tax: tax_,
            currency_code: currency_code_,
            custom_fields: custom_fields_,
            id: id_,
            line_items: line_items_,
            transaction_id: transaction_id_,
            status: status_,
            description: description_,
            merchant: merchant_,
            date_incurred: date_incurred_,
            location: location_,
            active: active_,
            account_id: account_id_,
            created_at: created_at_,
            payment_method: payment_method_,
            attachments: attachments_,
            receipt_urls: receipt_urls_,
            updated_at: updated_at_,
            amount: amount_,
            modify_token: modify_token_,
        } = val;
        if category_.is_some() {
            obj.set("category", category_)?;
        }
        if note_.is_some() {
            obj.set("note", note_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if report_id_.is_some() {
            obj.set("reportId", report_id_)?;
        }
        if created_by_user_id_.is_some() {
            obj.set("createdByUserId", created_by_user_id_)?;
        }
        if approved_by_user_id_.is_some() {
            obj.set("approvedByUserId", approved_by_user_id_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if tax_.is_some() {
            obj.set("tax", tax_)?;
        }
        if currency_code_.is_some() {
            obj.set("currencyCode", currency_code_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if line_items_.is_some() {
            obj.set("lineItems", line_items_)?;
        }
        if transaction_id_.is_some() {
            obj.set("transactionId", transaction_id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if merchant_.is_some() {
            obj.set("merchant", merchant_)?;
        }
        if date_incurred_.is_some() {
            obj.set("dateIncurred", date_incurred_)?;
        }
        if location_.is_some() {
            obj.set("location", location_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if account_id_.is_some() {
            obj.set("accountId", account_id_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if payment_method_.is_some() {
            obj.set("paymentMethod", payment_method_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if receipt_urls_.is_some() {
            obj.set("receiptUrls", receipt_urls_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Expenses {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let category_: Option<ExpenseCategories> = obj.get("category")?;
        let note_: Option<String> = obj.get("note")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let report_id_: Option<String> = obj.get("reportId")?;
        let created_by_user_id_: Option<String> = obj.get("createdByUserId")?;
        let approved_by_user_id_: Option<String> = obj.get("approvedByUserId")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let tax_: Option<Vec<Taxes>> = obj.get("tax")?;
        let currency_code_: Option<String> = obj.get("currencyCode")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let id_: Option<String> = obj.get("id")?;
        let line_items_: Option<Vec<Items>> = obj.get("lineItems")?;
        let transaction_id_: Option<String> = obj.get("transactionId")?;
        let status_: Option<ExpenseApprovalStatus> = obj.get("status")?;
        let description_: Option<String> = obj.get("description")?;
        let merchant_: Option<String> = obj.get("merchant")?;
        let date_incurred_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("dateIncurred")?;
        let location_: Option<Addresses> = obj.get("location")?;
        let active_: Option<bool> = obj.get("active")?;
        let account_id_: Option<String> = obj.get("accountId")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let payment_method_: Option<PaymentMethods> = obj.get("paymentMethod")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let receipt_urls_: Option<Vec<String>> = obj.get("receiptUrls")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let val = Self {
            category: category_,
            note: note_,
            tags: tags_,
            report_id: report_id_,
            created_by_user_id: created_by_user_id_,
            approved_by_user_id: approved_by_user_id_,
            deleted: deleted_,
            tax: tax_,
            currency_code: currency_code_,
            custom_fields: custom_fields_,
            id: id_,
            line_items: line_items_,
            transaction_id: transaction_id_,
            status: status_,
            description: description_,
            merchant: merchant_,
            date_incurred: date_incurred_,
            location: location_,
            active: active_,
            account_id: account_id_,
            created_at: created_at_,
            payment_method: payment_method_,
            attachments: attachments_,
            receipt_urls: receipt_urls_,
            updated_at: updated_at_,
            amount: amount_,
            modify_token: modify_token_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Expenses {}
pub struct Transactions {
    pub exchange_rate: Option<f64>,
    pub account_id: Option<String>,
    pub tax_amount: Option<f64>,
    pub refund: Option<Refunds>,
    pub transaction_category: Option<TransactionType>,
    pub amount: Option<f64>,
    pub tags: Option<Vec<String>>,
    pub status: Option<FinancialTransactionStatus>,
    pub payment_method: Option<PaymentMethods>,
    pub transaction_method: Option<TransactionMethod>,
    pub invoice_id: Option<String>,
    pub contact: Option<Contacts>,
    pub shipping: Option<ShippingDetails>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub modify_token: Option<String>,
    pub items: Option<Vec<Items>>,
    pub sender: Option<Customers>,
    pub billing_details: Option<BillingDetails>,
    pub description: Option<String>,
    pub r#type: Option<FinancialTransactionType>,
    pub payment_intent: Option<String>,
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub order_id: Option<String>,
    pub application_fee: Option<f64>,
    pub recipient: Option<Customers>,
    pub deleted: Option<bool>,
    pub currency: Option<Currency>,
    pub check_number: Option<String>,
    pub dispute: Option<Disputes>,
    pub id: Option<String>,
    pub account_name: Option<String>,
    pub metadata: Option<Metadata>,
}
impl napi::bindgen_prelude::TypeName for Transactions {
    fn type_name() -> &'static str {
        "Transactions"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Transactions {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Transactions,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            exchange_rate: exchange_rate_,
            account_id: account_id_,
            tax_amount: tax_amount_,
            refund: refund_,
            transaction_category: transaction_category_,
            amount: amount_,
            tags: tags_,
            status: status_,
            payment_method: payment_method_,
            transaction_method: transaction_method_,
            invoice_id: invoice_id_,
            contact: contact_,
            shipping: shipping_,
            updated_at: updated_at_,
            modify_token: modify_token_,
            items: items_,
            sender: sender_,
            billing_details: billing_details_,
            description: description_,
            r#type: type_,
            payment_intent: payment_intent_,
            date: date_,
            created_at: created_at_,
            order_id: order_id_,
            application_fee: application_fee_,
            recipient: recipient_,
            deleted: deleted_,
            currency: currency_,
            check_number: check_number_,
            dispute: dispute_,
            id: id_,
            account_name: account_name_,
            metadata: metadata_,
        } = val;
        if exchange_rate_.is_some() {
            obj.set("exchangeRate", exchange_rate_)?;
        }
        if account_id_.is_some() {
            obj.set("accountId", account_id_)?;
        }
        if tax_amount_.is_some() {
            obj.set("taxAmount", tax_amount_)?;
        }
        if refund_.is_some() {
            obj.set("refund", refund_)?;
        }
        if transaction_category_.is_some() {
            obj.set("transactionCategory", transaction_category_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if payment_method_.is_some() {
            obj.set("paymentMethod", payment_method_)?;
        }
        if transaction_method_.is_some() {
            obj.set("transactionMethod", transaction_method_)?;
        }
        if invoice_id_.is_some() {
            obj.set("invoiceId", invoice_id_)?;
        }
        if contact_.is_some() {
            obj.set("contact", contact_)?;
        }
        if shipping_.is_some() {
            obj.set("shipping", shipping_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if items_.is_some() {
            obj.set("items", items_)?;
        }
        if sender_.is_some() {
            obj.set("sender", sender_)?;
        }
        if billing_details_.is_some() {
            obj.set("billingDetails", billing_details_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if payment_intent_.is_some() {
            obj.set("paymentIntent", payment_intent_)?;
        }
        if date_.is_some() {
            obj.set("date", date_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if order_id_.is_some() {
            obj.set("orderId", order_id_)?;
        }
        if application_fee_.is_some() {
            obj.set("applicationFee", application_fee_)?;
        }
        if recipient_.is_some() {
            obj.set("recipient", recipient_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if check_number_.is_some() {
            obj.set("checkNumber", check_number_)?;
        }
        if dispute_.is_some() {
            obj.set("dispute", dispute_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if account_name_.is_some() {
            obj.set("accountName", account_name_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Transactions {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let exchange_rate_: Option<f64> = obj.get("exchangeRate")?;
        let account_id_: Option<String> = obj.get("accountId")?;
        let tax_amount_: Option<f64> = obj.get("taxAmount")?;
        let refund_: Option<Refunds> = obj.get("refund")?;
        let transaction_category_: Option<TransactionType> = obj
            .get("transactionCategory")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let status_: Option<FinancialTransactionStatus> = obj.get("status")?;
        let payment_method_: Option<PaymentMethods> = obj.get("paymentMethod")?;
        let transaction_method_: Option<TransactionMethod> = obj
            .get("transactionMethod")?;
        let invoice_id_: Option<String> = obj.get("invoiceId")?;
        let contact_: Option<Contacts> = obj.get("contact")?;
        let shipping_: Option<ShippingDetails> = obj.get("shipping")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let items_: Option<Vec<Items>> = obj.get("items")?;
        let sender_: Option<Customers> = obj.get("sender")?;
        let billing_details_: Option<BillingDetails> = obj.get("billingDetails")?;
        let description_: Option<String> = obj.get("description")?;
        let type_: Option<FinancialTransactionType> = obj.get("type")?;
        let payment_intent_: Option<String> = obj.get("paymentIntent")?;
        let date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("date")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let order_id_: Option<String> = obj.get("orderId")?;
        let application_fee_: Option<f64> = obj.get("applicationFee")?;
        let recipient_: Option<Customers> = obj.get("recipient")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let check_number_: Option<String> = obj.get("checkNumber")?;
        let dispute_: Option<Disputes> = obj.get("dispute")?;
        let id_: Option<String> = obj.get("id")?;
        let account_name_: Option<String> = obj.get("accountName")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let val = Self {
            exchange_rate: exchange_rate_,
            account_id: account_id_,
            tax_amount: tax_amount_,
            refund: refund_,
            transaction_category: transaction_category_,
            amount: amount_,
            tags: tags_,
            status: status_,
            payment_method: payment_method_,
            transaction_method: transaction_method_,
            invoice_id: invoice_id_,
            contact: contact_,
            shipping: shipping_,
            updated_at: updated_at_,
            modify_token: modify_token_,
            items: items_,
            sender: sender_,
            billing_details: billing_details_,
            description: description_,
            r#type: type_,
            payment_intent: payment_intent_,
            date: date_,
            created_at: created_at_,
            order_id: order_id_,
            application_fee: application_fee_,
            recipient: recipient_,
            deleted: deleted_,
            currency: currency_,
            check_number: check_number_,
            dispute: dispute_,
            id: id_,
            account_name: account_name_,
            metadata: metadata_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Transactions {}
pub struct PurchaseOrderLineItems {
    pub quantity: Option<f64>,
    pub unit_of_measure: Option<String>,
    pub discount: Option<f64>,
    pub unit_price: Option<f64>,
    pub id: Option<String>,
    pub total_price: Option<f64>,
    pub description: Option<String>,
    pub delivery_date: Option<chrono::DateTime<chrono::Utc>>,
    pub s_k_u: Option<String>,
    pub product_id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for PurchaseOrderLineItems {
    fn type_name() -> &'static str {
        "PurchaseOrderLineItems"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for PurchaseOrderLineItems {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: PurchaseOrderLineItems,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            quantity: quantity_,
            unit_of_measure: unit_of_measure_,
            discount: discount_,
            unit_price: unit_price_,
            id: id_,
            total_price: total_price_,
            description: description_,
            delivery_date: delivery_date_,
            s_k_u: s_k_u_,
            product_id: product_id_,
        } = val;
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        if unit_of_measure_.is_some() {
            obj.set("unitOfMeasure", unit_of_measure_)?;
        }
        if discount_.is_some() {
            obj.set("discount", discount_)?;
        }
        if unit_price_.is_some() {
            obj.set("unitPrice", unit_price_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if total_price_.is_some() {
            obj.set("totalPrice", total_price_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if delivery_date_.is_some() {
            obj.set("deliveryDate", delivery_date_)?;
        }
        if s_k_u_.is_some() {
            obj.set("sKU", s_k_u_)?;
        }
        if product_id_.is_some() {
            obj.set("productId", product_id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for PurchaseOrderLineItems {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let unit_of_measure_: Option<String> = obj.get("unitOfMeasure")?;
        let discount_: Option<f64> = obj.get("discount")?;
        let unit_price_: Option<f64> = obj.get("unitPrice")?;
        let id_: Option<String> = obj.get("id")?;
        let total_price_: Option<f64> = obj.get("totalPrice")?;
        let description_: Option<String> = obj.get("description")?;
        let delivery_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("deliveryDate")?;
        let s_k_u_: Option<String> = obj.get("sKU")?;
        let product_id_: Option<String> = obj.get("productId")?;
        let val = Self {
            quantity: quantity_,
            unit_of_measure: unit_of_measure_,
            discount: discount_,
            unit_price: unit_price_,
            id: id_,
            total_price: total_price_,
            description: description_,
            delivery_date: delivery_date_,
            s_k_u: s_k_u_,
            product_id: product_id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PurchaseOrderLineItems {}
pub struct Accounts {
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub interest_rate: Option<f64>,
    pub overdraft_protection: Option<bool>,
    pub title: Option<String>,
    pub branch: Option<String>,
    pub notes: Option<String>,
    pub active: Option<bool>,
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub id: Option<String>,
    pub status: Option<FinancialAccountStatus>,
    pub balance: Option<f64>,
    pub account_type: Option<AccountType>,
    pub currency: Option<Currency>,
    pub owner: Option<Customers>,
    pub modify_token: Option<String>,
    pub name: Option<String>,
    pub transactions: Option<Vec<Transactions>>,
    pub description: Option<String>,
    pub account_number: Option<String>,
    pub overdraft_limit: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for Accounts {
    fn type_name() -> &'static str {
        "Accounts"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Accounts {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Accounts,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            updated_at: updated_at_,
            interest_rate: interest_rate_,
            overdraft_protection: overdraft_protection_,
            title: title_,
            branch: branch_,
            notes: notes_,
            active: active_,
            closed_at: closed_at_,
            created_at: created_at_,
            deleted: deleted_,
            id: id_,
            status: status_,
            balance: balance_,
            account_type: account_type_,
            currency: currency_,
            owner: owner_,
            modify_token: modify_token_,
            name: name_,
            transactions: transactions_,
            description: description_,
            account_number: account_number_,
            overdraft_limit: overdraft_limit_,
        } = val;
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if interest_rate_.is_some() {
            obj.set("interestRate", interest_rate_)?;
        }
        if overdraft_protection_.is_some() {
            obj.set("overdraftProtection", overdraft_protection_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if branch_.is_some() {
            obj.set("branch", branch_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if closed_at_.is_some() {
            obj.set("closedAt", closed_at_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if balance_.is_some() {
            obj.set("balance", balance_)?;
        }
        if account_type_.is_some() {
            obj.set("accountType", account_type_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if owner_.is_some() {
            obj.set("owner", owner_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if transactions_.is_some() {
            obj.set("transactions", transactions_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if account_number_.is_some() {
            obj.set("accountNumber", account_number_)?;
        }
        if overdraft_limit_.is_some() {
            obj.set("overdraftLimit", overdraft_limit_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Accounts {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let interest_rate_: Option<f64> = obj.get("interestRate")?;
        let overdraft_protection_: Option<bool> = obj.get("overdraftProtection")?;
        let title_: Option<String> = obj.get("title")?;
        let branch_: Option<String> = obj.get("branch")?;
        let notes_: Option<String> = obj.get("notes")?;
        let active_: Option<bool> = obj.get("active")?;
        let closed_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("closedAt")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let id_: Option<String> = obj.get("id")?;
        let status_: Option<FinancialAccountStatus> = obj.get("status")?;
        let balance_: Option<f64> = obj.get("balance")?;
        let account_type_: Option<AccountType> = obj.get("accountType")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let owner_: Option<Customers> = obj.get("owner")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let name_: Option<String> = obj.get("name")?;
        let transactions_: Option<Vec<Transactions>> = obj.get("transactions")?;
        let description_: Option<String> = obj.get("description")?;
        let account_number_: Option<String> = obj.get("accountNumber")?;
        let overdraft_limit_: Option<f64> = obj.get("overdraftLimit")?;
        let val = Self {
            updated_at: updated_at_,
            interest_rate: interest_rate_,
            overdraft_protection: overdraft_protection_,
            title: title_,
            branch: branch_,
            notes: notes_,
            active: active_,
            closed_at: closed_at_,
            created_at: created_at_,
            deleted: deleted_,
            id: id_,
            status: status_,
            balance: balance_,
            account_type: account_type_,
            currency: currency_,
            owner: owner_,
            modify_token: modify_token_,
            name: name_,
            transactions: transactions_,
            description: description_,
            account_number: account_number_,
            overdraft_limit: overdraft_limit_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Accounts {}
pub struct PurchaseOrders {
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub vendor: Option<Vendors>,
    pub shipping_costs: Option<f64>,
    pub line_items: Option<Vec<PurchaseOrderLineItems>>,
    pub taxes: Option<f64>,
    pub notes: Option<String>,
    pub expected_delivery_date: Option<chrono::DateTime<chrono::Utc>>,
    pub order_number: Option<String>,
    pub payment_terms: Option<String>,
    pub id: Option<String>,
    pub status: Option<OrderStatus>,
    pub ship_to: Option<Addresses>,
    pub bill_to: Option<Addresses>,
    pub total: Option<f64>,
    pub currency: Option<Currency>,
    pub modify_token: Option<String>,
    pub subtotal: Option<f64>,
    pub account_id: Option<String>,
    pub order_date: Option<chrono::DateTime<chrono::Utc>>,
    pub attachments: Option<Vec<Attachments>>,
    pub active: Option<bool>,
    pub deleted: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for PurchaseOrders {
    fn type_name() -> &'static str {
        "PurchaseOrders"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for PurchaseOrders {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: PurchaseOrders,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            created_at: created_at_,
            updated_at: updated_at_,
            vendor: vendor_,
            shipping_costs: shipping_costs_,
            line_items: line_items_,
            taxes: taxes_,
            notes: notes_,
            expected_delivery_date: expected_delivery_date_,
            order_number: order_number_,
            payment_terms: payment_terms_,
            id: id_,
            status: status_,
            ship_to: ship_to_,
            bill_to: bill_to_,
            total: total_,
            currency: currency_,
            modify_token: modify_token_,
            subtotal: subtotal_,
            account_id: account_id_,
            order_date: order_date_,
            attachments: attachments_,
            active: active_,
            deleted: deleted_,
        } = val;
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if vendor_.is_some() {
            obj.set("vendor", vendor_)?;
        }
        if shipping_costs_.is_some() {
            obj.set("shippingCosts", shipping_costs_)?;
        }
        if line_items_.is_some() {
            obj.set("lineItems", line_items_)?;
        }
        if taxes_.is_some() {
            obj.set("taxes", taxes_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if expected_delivery_date_.is_some() {
            obj.set("expectedDeliveryDate", expected_delivery_date_)?;
        }
        if order_number_.is_some() {
            obj.set("orderNumber", order_number_)?;
        }
        if payment_terms_.is_some() {
            obj.set("paymentTerms", payment_terms_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if ship_to_.is_some() {
            obj.set("shipTo", ship_to_)?;
        }
        if bill_to_.is_some() {
            obj.set("billTo", bill_to_)?;
        }
        if total_.is_some() {
            obj.set("total", total_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if subtotal_.is_some() {
            obj.set("subtotal", subtotal_)?;
        }
        if account_id_.is_some() {
            obj.set("accountId", account_id_)?;
        }
        if order_date_.is_some() {
            obj.set("orderDate", order_date_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for PurchaseOrders {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let vendor_: Option<Vendors> = obj.get("vendor")?;
        let shipping_costs_: Option<f64> = obj.get("shippingCosts")?;
        let line_items_: Option<Vec<PurchaseOrderLineItems>> = obj.get("lineItems")?;
        let taxes_: Option<f64> = obj.get("taxes")?;
        let notes_: Option<String> = obj.get("notes")?;
        let expected_delivery_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("expectedDeliveryDate")?;
        let order_number_: Option<String> = obj.get("orderNumber")?;
        let payment_terms_: Option<String> = obj.get("paymentTerms")?;
        let id_: Option<String> = obj.get("id")?;
        let status_: Option<OrderStatus> = obj.get("status")?;
        let ship_to_: Option<Addresses> = obj.get("shipTo")?;
        let bill_to_: Option<Addresses> = obj.get("billTo")?;
        let total_: Option<f64> = obj.get("total")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let subtotal_: Option<f64> = obj.get("subtotal")?;
        let account_id_: Option<String> = obj.get("accountId")?;
        let order_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("orderDate")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let active_: Option<bool> = obj.get("active")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let val = Self {
            created_at: created_at_,
            updated_at: updated_at_,
            vendor: vendor_,
            shipping_costs: shipping_costs_,
            line_items: line_items_,
            taxes: taxes_,
            notes: notes_,
            expected_delivery_date: expected_delivery_date_,
            order_number: order_number_,
            payment_terms: payment_terms_,
            id: id_,
            status: status_,
            ship_to: ship_to_,
            bill_to: bill_to_,
            total: total_,
            currency: currency_,
            modify_token: modify_token_,
            subtotal: subtotal_,
            account_id: account_id_,
            order_date: order_date_,
            attachments: attachments_,
            active: active_,
            deleted: deleted_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PurchaseOrders {}
pub struct AdditionalCharges {
    pub description: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    pub amount: Option<f64>,
    pub r#type: Option<FinancialChargeType>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for AdditionalCharges {
    fn type_name() -> &'static str {
        "AdditionalCharges"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for AdditionalCharges {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: AdditionalCharges,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            description: description_,
            updated_at: updated_at_,
            id: id_,
            amount: amount_,
            r#type: type_,
            created_at: created_at_,
        } = val;
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for AdditionalCharges {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let description_: Option<String> = obj.get("description")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let id_: Option<String> = obj.get("id")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let type_: Option<FinancialChargeType> = obj.get("type")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let val = Self {
            description: description_,
            updated_at: updated_at_,
            id: id_,
            amount: amount_,
            r#type: type_,
            created_at: created_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AdditionalCharges {}
pub struct Refunds {
    pub reason: Option<String>,
    pub status: Option<TransactionStatus>,
    pub id: Option<String>,
    pub payment_id: Option<String>,
    pub amount: Option<f64>,
    pub currency: Option<Currency>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Refunds {
    fn type_name() -> &'static str {
        "Refunds"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Refunds {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Refunds,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            reason: reason_,
            status: status_,
            id: id_,
            payment_id: payment_id_,
            amount: amount_,
            currency: currency_,
            created_at: created_at_,
            updated_at: updated_at_,
        } = val;
        if reason_.is_some() {
            obj.set("reason", reason_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if payment_id_.is_some() {
            obj.set("paymentId", payment_id_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Refunds {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let reason_: Option<String> = obj.get("reason")?;
        let status_: Option<TransactionStatus> = obj.get("status")?;
        let id_: Option<String> = obj.get("id")?;
        let payment_id_: Option<String> = obj.get("paymentId")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let val = Self {
            reason: reason_,
            status: status_,
            id: id_,
            payment_id: payment_id_,
            amount: amount_,
            currency: currency_,
            created_at: created_at_,
            updated_at: updated_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Refunds {}
pub struct Payments {
    pub order_id: Option<String>,
    pub amount: Option<f64>,
    pub payment_intent: Option<String>,
    pub receipt_email: Option<String>,
    pub status: Option<PaymentStatus>,
    pub payment_capture_method: Option<String>,
    pub billing_details: Option<BillingDetails>,
    pub payment_processor: Option<String>,
    pub description: Option<String>,
    pub webhook_url: Option<String>,
    pub modify_token: Option<String>,
    pub invoice: Option<Invoices>,
    pub shipping_details: Option<ShippingDetails>,
    pub payment_method: Option<PaymentMethods>,
    pub refund: Option<Refunds>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    pub transaction_id: Option<String>,
    pub notes: Option<String>,
    pub customer: Option<Customers>,
    pub currency: Option<Currency>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub metadata: Option<Metadata>,
    pub active: Option<bool>,
    pub deleted: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Payments {
    fn type_name() -> &'static str {
        "Payments"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Payments {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Payments,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            order_id: order_id_,
            amount: amount_,
            payment_intent: payment_intent_,
            receipt_email: receipt_email_,
            status: status_,
            payment_capture_method: payment_capture_method_,
            billing_details: billing_details_,
            payment_processor: payment_processor_,
            description: description_,
            webhook_url: webhook_url_,
            modify_token: modify_token_,
            invoice: invoice_,
            shipping_details: shipping_details_,
            payment_method: payment_method_,
            refund: refund_,
            updated_at: updated_at_,
            id: id_,
            date: date_,
            transaction_id: transaction_id_,
            notes: notes_,
            customer: customer_,
            currency: currency_,
            created_at: created_at_,
            metadata: metadata_,
            active: active_,
            deleted: deleted_,
        } = val;
        if order_id_.is_some() {
            obj.set("orderId", order_id_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if payment_intent_.is_some() {
            obj.set("paymentIntent", payment_intent_)?;
        }
        if receipt_email_.is_some() {
            obj.set("receiptEmail", receipt_email_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if payment_capture_method_.is_some() {
            obj.set("paymentCaptureMethod", payment_capture_method_)?;
        }
        if billing_details_.is_some() {
            obj.set("billingDetails", billing_details_)?;
        }
        if payment_processor_.is_some() {
            obj.set("paymentProcessor", payment_processor_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if webhook_url_.is_some() {
            obj.set("webhookUrl", webhook_url_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if invoice_.is_some() {
            obj.set("invoice", invoice_)?;
        }
        if shipping_details_.is_some() {
            obj.set("shippingDetails", shipping_details_)?;
        }
        if payment_method_.is_some() {
            obj.set("paymentMethod", payment_method_)?;
        }
        if refund_.is_some() {
            obj.set("refund", refund_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if date_.is_some() {
            obj.set("date", date_)?;
        }
        if transaction_id_.is_some() {
            obj.set("transactionId", transaction_id_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if customer_.is_some() {
            obj.set("customer", customer_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Payments {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let order_id_: Option<String> = obj.get("orderId")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let payment_intent_: Option<String> = obj.get("paymentIntent")?;
        let receipt_email_: Option<String> = obj.get("receiptEmail")?;
        let status_: Option<PaymentStatus> = obj.get("status")?;
        let payment_capture_method_: Option<String> = obj.get("paymentCaptureMethod")?;
        let billing_details_: Option<BillingDetails> = obj.get("billingDetails")?;
        let payment_processor_: Option<String> = obj.get("paymentProcessor")?;
        let description_: Option<String> = obj.get("description")?;
        let webhook_url_: Option<String> = obj.get("webhookUrl")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let invoice_: Option<Invoices> = obj.get("invoice")?;
        let shipping_details_: Option<ShippingDetails> = obj.get("shippingDetails")?;
        let payment_method_: Option<PaymentMethods> = obj.get("paymentMethod")?;
        let refund_: Option<Refunds> = obj.get("refund")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let id_: Option<String> = obj.get("id")?;
        let date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("date")?;
        let transaction_id_: Option<String> = obj.get("transactionId")?;
        let notes_: Option<String> = obj.get("notes")?;
        let customer_: Option<Customers> = obj.get("customer")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let active_: Option<bool> = obj.get("active")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let val = Self {
            order_id: order_id_,
            amount: amount_,
            payment_intent: payment_intent_,
            receipt_email: receipt_email_,
            status: status_,
            payment_capture_method: payment_capture_method_,
            billing_details: billing_details_,
            payment_processor: payment_processor_,
            description: description_,
            webhook_url: webhook_url_,
            modify_token: modify_token_,
            invoice: invoice_,
            shipping_details: shipping_details_,
            payment_method: payment_method_,
            refund: refund_,
            updated_at: updated_at_,
            id: id_,
            date: date_,
            transaction_id: transaction_id_,
            notes: notes_,
            customer: customer_,
            currency: currency_,
            created_at: created_at_,
            metadata: metadata_,
            active: active_,
            deleted: deleted_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Payments {}
pub struct Bills {
    pub amount_remaining: Option<f64>,
    pub notes: Option<String>,
    pub amount_due: Option<f64>,
    pub currency_code: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub id: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub customer: Option<Customers>,
    pub attachments: Option<Vec<Attachments>>,
    pub issue_date: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<BillingStatus>,
    pub due_date: Option<chrono::DateTime<chrono::Utc>>,
    pub modify_token: Option<String>,
    pub vendor: Option<Vendors>,
    pub amount_paid: Option<f64>,
    pub terms: Option<String>,
    pub line_items: Option<Vec<Items>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Bills {
    fn type_name() -> &'static str {
        "Bills"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Bills {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Bills,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            amount_remaining: amount_remaining_,
            notes: notes_,
            amount_due: amount_due_,
            currency_code: currency_code_,
            custom_fields: custom_fields_,
            id: id_,
            created_at: created_at_,
            deleted: deleted_,
            customer: customer_,
            attachments: attachments_,
            issue_date: issue_date_,
            status: status_,
            due_date: due_date_,
            modify_token: modify_token_,
            vendor: vendor_,
            amount_paid: amount_paid_,
            terms: terms_,
            line_items: line_items_,
            updated_at: updated_at_,
            active: active_,
        } = val;
        if amount_remaining_.is_some() {
            obj.set("amountRemaining", amount_remaining_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if amount_due_.is_some() {
            obj.set("amountDue", amount_due_)?;
        }
        if currency_code_.is_some() {
            obj.set("currencyCode", currency_code_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if customer_.is_some() {
            obj.set("customer", customer_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if issue_date_.is_some() {
            obj.set("issueDate", issue_date_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if due_date_.is_some() {
            obj.set("dueDate", due_date_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if vendor_.is_some() {
            obj.set("vendor", vendor_)?;
        }
        if amount_paid_.is_some() {
            obj.set("amountPaid", amount_paid_)?;
        }
        if terms_.is_some() {
            obj.set("terms", terms_)?;
        }
        if line_items_.is_some() {
            obj.set("lineItems", line_items_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Bills {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let amount_remaining_: Option<f64> = obj.get("amountRemaining")?;
        let notes_: Option<String> = obj.get("notes")?;
        let amount_due_: Option<f64> = obj.get("amountDue")?;
        let currency_code_: Option<String> = obj.get("currencyCode")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let id_: Option<String> = obj.get("id")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let customer_: Option<Customers> = obj.get("customer")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let issue_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("issueDate")?;
        let status_: Option<BillingStatus> = obj.get("status")?;
        let due_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("dueDate")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let vendor_: Option<Vendors> = obj.get("vendor")?;
        let amount_paid_: Option<f64> = obj.get("amountPaid")?;
        let terms_: Option<String> = obj.get("terms")?;
        let line_items_: Option<Vec<Items>> = obj.get("lineItems")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let val = Self {
            amount_remaining: amount_remaining_,
            notes: notes_,
            amount_due: amount_due_,
            currency_code: currency_code_,
            custom_fields: custom_fields_,
            id: id_,
            created_at: created_at_,
            deleted: deleted_,
            customer: customer_,
            attachments: attachments_,
            issue_date: issue_date_,
            status: status_,
            due_date: due_date_,
            modify_token: modify_token_,
            vendor: vendor_,
            amount_paid: amount_paid_,
            terms: terms_,
            line_items: line_items_,
            updated_at: updated_at_,
            active: active_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Bills {}
pub struct Vendors {
    pub contact_name: Option<String>,
    pub address: Option<Addresses>,
    pub overdue_balance: Option<f64>,
    pub contact_email: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub modify_token: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub account_number: Option<String>,
    pub is1099: Option<bool>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub id: Option<String>,
    pub outstanding_balance: Option<f64>,
    pub website: Option<String>,
    pub deleted: Option<bool>,
    pub currency_code: Option<String>,
    pub company_name: Option<String>,
    pub note: Option<String>,
    pub tax: Option<Vec<Taxes>>,
    pub contact_phone: Option<String>,
    pub active: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Vendors {
    fn type_name() -> &'static str {
        "Vendors"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Vendors {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Vendors,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            contact_name: contact_name_,
            address: address_,
            overdue_balance: overdue_balance_,
            contact_email: contact_email_,
            created_at: created_at_,
            modify_token: modify_token_,
            updated_at: updated_at_,
            account_number: account_number_,
            is1099: is1099_,
            custom_fields: custom_fields_,
            id: id_,
            outstanding_balance: outstanding_balance_,
            website: website_,
            deleted: deleted_,
            currency_code: currency_code_,
            company_name: company_name_,
            note: note_,
            tax: tax_,
            contact_phone: contact_phone_,
            active: active_,
        } = val;
        if contact_name_.is_some() {
            obj.set("contactName", contact_name_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if overdue_balance_.is_some() {
            obj.set("overdueBalance", overdue_balance_)?;
        }
        if contact_email_.is_some() {
            obj.set("contactEmail", contact_email_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if account_number_.is_some() {
            obj.set("accountNumber", account_number_)?;
        }
        if is1099_.is_some() {
            obj.set("is1099", is1099_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if outstanding_balance_.is_some() {
            obj.set("outstandingBalance", outstanding_balance_)?;
        }
        if website_.is_some() {
            obj.set("website", website_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if currency_code_.is_some() {
            obj.set("currencyCode", currency_code_)?;
        }
        if company_name_.is_some() {
            obj.set("companyName", company_name_)?;
        }
        if note_.is_some() {
            obj.set("note", note_)?;
        }
        if tax_.is_some() {
            obj.set("tax", tax_)?;
        }
        if contact_phone_.is_some() {
            obj.set("contactPhone", contact_phone_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Vendors {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let contact_name_: Option<String> = obj.get("contactName")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let overdue_balance_: Option<f64> = obj.get("overdueBalance")?;
        let contact_email_: Option<String> = obj.get("contactEmail")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let account_number_: Option<String> = obj.get("accountNumber")?;
        let is1099_: Option<bool> = obj.get("is1099")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let id_: Option<String> = obj.get("id")?;
        let outstanding_balance_: Option<f64> = obj.get("outstandingBalance")?;
        let website_: Option<String> = obj.get("website")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let currency_code_: Option<String> = obj.get("currencyCode")?;
        let company_name_: Option<String> = obj.get("companyName")?;
        let note_: Option<String> = obj.get("note")?;
        let tax_: Option<Vec<Taxes>> = obj.get("tax")?;
        let contact_phone_: Option<String> = obj.get("contactPhone")?;
        let active_: Option<bool> = obj.get("active")?;
        let val = Self {
            contact_name: contact_name_,
            address: address_,
            overdue_balance: overdue_balance_,
            contact_email: contact_email_,
            created_at: created_at_,
            modify_token: modify_token_,
            updated_at: updated_at_,
            account_number: account_number_,
            is1099: is1099_,
            custom_fields: custom_fields_,
            id: id_,
            outstanding_balance: outstanding_balance_,
            website: website_,
            deleted: deleted_,
            currency_code: currency_code_,
            company_name: company_name_,
            note: note_,
            tax: tax_,
            contact_phone: contact_phone_,
            active: active_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Vendors {}
pub struct AuditInformation {
    pub audit_opinion: Option<AuditOpinionType>,
    pub notes: Option<String>,
    pub auditor_name: Option<String>,
    pub audit_date: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for AuditInformation {
    fn type_name() -> &'static str {
        "AuditInformation"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for AuditInformation {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: AuditInformation,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            audit_opinion: audit_opinion_,
            notes: notes_,
            auditor_name: auditor_name_,
            audit_date: audit_date_,
        } = val;
        if audit_opinion_.is_some() {
            obj.set("auditOpinion", audit_opinion_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if auditor_name_.is_some() {
            obj.set("auditorName", auditor_name_)?;
        }
        if audit_date_.is_some() {
            obj.set("auditDate", audit_date_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for AuditInformation {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let audit_opinion_: Option<AuditOpinionType> = obj.get("auditOpinion")?;
        let notes_: Option<String> = obj.get("notes")?;
        let auditor_name_: Option<String> = obj.get("auditorName")?;
        let audit_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("auditDate")?;
        let val = Self {
            audit_opinion: audit_opinion_,
            notes: notes_,
            auditor_name: auditor_name_,
            audit_date: audit_date_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AuditInformation {}
pub struct BalanceSheets {
    pub inventory: Option<f64>,
    pub non_current_liabilities: Option<f64>,
    pub retained_earnings: Option<f64>,
    pub current_portion_of_long_term_debt: Option<f64>,
    pub current_liabilities: Option<f64>,
    pub modify_token: Option<String>,
    pub deferred_revenue: Option<f64>,
    pub other_current_liabilities: Option<f64>,
    pub fixed_assets: Option<f64>,
    pub common_stock: Option<f64>,
    pub minority_interest: Option<f64>,
    pub preferred_stock: Option<f64>,
    pub total_liabilities: Option<f64>,
    pub accounts_receivable: Option<f64>,
    pub notes: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub balance_date: Option<chrono::DateTime<chrono::Utc>>,
    pub short_term_investments: Option<f64>,
    pub accumulated_depreciation: Option<f64>,
    pub other_non_current_assets: Option<f64>,
    pub notes_payable: Option<f64>,
    pub active: Option<bool>,
    pub currency: Option<Currency>,
    pub other_non_current_liabilities: Option<f64>,
    pub long_term_debt: Option<f64>,
    pub short_term_debt: Option<f64>,
    pub additional_paid_in_capital: Option<f64>,
    pub total_liabilities_and_equity: Option<f64>,
    pub non_current_assets: Option<f64>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub property_plant_equipment: Option<f64>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub intangible_assets: Option<f64>,
    pub prepaid_expenses: Option<f64>,
    pub other_current_assets: Option<f64>,
    pub treasury_stock: Option<f64>,
    pub audit_info: Option<AuditInformation>,
    pub deleted: Option<bool>,
    pub current_assets: Option<f64>,
    pub cash_and_cash_equivalents: Option<f64>,
    pub tax_liabilities: Option<f64>,
    pub equity: Option<f64>,
    pub account_summary: Option<Vec<KeyValues>>,
    pub accounts_payable: Option<f64>,
    pub accrued_liabilities: Option<f64>,
    pub id: Option<String>,
    pub stockholders_equity: Option<f64>,
    pub total_assets: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for BalanceSheets {
    fn type_name() -> &'static str {
        "BalanceSheets"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for BalanceSheets {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: BalanceSheets,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            inventory: inventory_,
            non_current_liabilities: non_current_liabilities_,
            retained_earnings: retained_earnings_,
            current_portion_of_long_term_debt: current_portion_of_long_term_debt_,
            current_liabilities: current_liabilities_,
            modify_token: modify_token_,
            deferred_revenue: deferred_revenue_,
            other_current_liabilities: other_current_liabilities_,
            fixed_assets: fixed_assets_,
            common_stock: common_stock_,
            minority_interest: minority_interest_,
            preferred_stock: preferred_stock_,
            total_liabilities: total_liabilities_,
            accounts_receivable: accounts_receivable_,
            notes: notes_,
            updated_at: updated_at_,
            balance_date: balance_date_,
            short_term_investments: short_term_investments_,
            accumulated_depreciation: accumulated_depreciation_,
            other_non_current_assets: other_non_current_assets_,
            notes_payable: notes_payable_,
            active: active_,
            currency: currency_,
            other_non_current_liabilities: other_non_current_liabilities_,
            long_term_debt: long_term_debt_,
            short_term_debt: short_term_debt_,
            additional_paid_in_capital: additional_paid_in_capital_,
            total_liabilities_and_equity: total_liabilities_and_equity_,
            non_current_assets: non_current_assets_,
            created_at: created_at_,
            property_plant_equipment: property_plant_equipment_,
            custom_fields: custom_fields_,
            intangible_assets: intangible_assets_,
            prepaid_expenses: prepaid_expenses_,
            other_current_assets: other_current_assets_,
            treasury_stock: treasury_stock_,
            audit_info: audit_info_,
            deleted: deleted_,
            current_assets: current_assets_,
            cash_and_cash_equivalents: cash_and_cash_equivalents_,
            tax_liabilities: tax_liabilities_,
            equity: equity_,
            account_summary: account_summary_,
            accounts_payable: accounts_payable_,
            accrued_liabilities: accrued_liabilities_,
            id: id_,
            stockholders_equity: stockholders_equity_,
            total_assets: total_assets_,
        } = val;
        if inventory_.is_some() {
            obj.set("inventory", inventory_)?;
        }
        if non_current_liabilities_.is_some() {
            obj.set("nonCurrentLiabilities", non_current_liabilities_)?;
        }
        if retained_earnings_.is_some() {
            obj.set("retainedEarnings", retained_earnings_)?;
        }
        if current_portion_of_long_term_debt_.is_some() {
            obj.set("currentPortionOfLongTermDebt", current_portion_of_long_term_debt_)?;
        }
        if current_liabilities_.is_some() {
            obj.set("currentLiabilities", current_liabilities_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if deferred_revenue_.is_some() {
            obj.set("deferredRevenue", deferred_revenue_)?;
        }
        if other_current_liabilities_.is_some() {
            obj.set("otherCurrentLiabilities", other_current_liabilities_)?;
        }
        if fixed_assets_.is_some() {
            obj.set("fixedAssets", fixed_assets_)?;
        }
        if common_stock_.is_some() {
            obj.set("commonStock", common_stock_)?;
        }
        if minority_interest_.is_some() {
            obj.set("minorityInterest", minority_interest_)?;
        }
        if preferred_stock_.is_some() {
            obj.set("preferredStock", preferred_stock_)?;
        }
        if total_liabilities_.is_some() {
            obj.set("totalLiabilities", total_liabilities_)?;
        }
        if accounts_receivable_.is_some() {
            obj.set("accountsReceivable", accounts_receivable_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if balance_date_.is_some() {
            obj.set("balanceDate", balance_date_)?;
        }
        if short_term_investments_.is_some() {
            obj.set("shortTermInvestments", short_term_investments_)?;
        }
        if accumulated_depreciation_.is_some() {
            obj.set("accumulatedDepreciation", accumulated_depreciation_)?;
        }
        if other_non_current_assets_.is_some() {
            obj.set("otherNonCurrentAssets", other_non_current_assets_)?;
        }
        if notes_payable_.is_some() {
            obj.set("notesPayable", notes_payable_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if other_non_current_liabilities_.is_some() {
            obj.set("otherNonCurrentLiabilities", other_non_current_liabilities_)?;
        }
        if long_term_debt_.is_some() {
            obj.set("longTermDebt", long_term_debt_)?;
        }
        if short_term_debt_.is_some() {
            obj.set("shortTermDebt", short_term_debt_)?;
        }
        if additional_paid_in_capital_.is_some() {
            obj.set("additionalPaidInCapital", additional_paid_in_capital_)?;
        }
        if total_liabilities_and_equity_.is_some() {
            obj.set("totalLiabilitiesAndEquity", total_liabilities_and_equity_)?;
        }
        if non_current_assets_.is_some() {
            obj.set("nonCurrentAssets", non_current_assets_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if property_plant_equipment_.is_some() {
            obj.set("propertyPlantEquipment", property_plant_equipment_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if intangible_assets_.is_some() {
            obj.set("intangibleAssets", intangible_assets_)?;
        }
        if prepaid_expenses_.is_some() {
            obj.set("prepaidExpenses", prepaid_expenses_)?;
        }
        if other_current_assets_.is_some() {
            obj.set("otherCurrentAssets", other_current_assets_)?;
        }
        if treasury_stock_.is_some() {
            obj.set("treasuryStock", treasury_stock_)?;
        }
        if audit_info_.is_some() {
            obj.set("auditInfo", audit_info_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if current_assets_.is_some() {
            obj.set("currentAssets", current_assets_)?;
        }
        if cash_and_cash_equivalents_.is_some() {
            obj.set("cashAndCashEquivalents", cash_and_cash_equivalents_)?;
        }
        if tax_liabilities_.is_some() {
            obj.set("taxLiabilities", tax_liabilities_)?;
        }
        if equity_.is_some() {
            obj.set("equity", equity_)?;
        }
        if account_summary_.is_some() {
            obj.set("accountSummary", account_summary_)?;
        }
        if accounts_payable_.is_some() {
            obj.set("accountsPayable", accounts_payable_)?;
        }
        if accrued_liabilities_.is_some() {
            obj.set("accruedLiabilities", accrued_liabilities_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if stockholders_equity_.is_some() {
            obj.set("stockholdersEquity", stockholders_equity_)?;
        }
        if total_assets_.is_some() {
            obj.set("totalAssets", total_assets_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for BalanceSheets {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let inventory_: Option<f64> = obj.get("inventory")?;
        let non_current_liabilities_: Option<f64> = obj.get("nonCurrentLiabilities")?;
        let retained_earnings_: Option<f64> = obj.get("retainedEarnings")?;
        let current_portion_of_long_term_debt_: Option<f64> = obj
            .get("currentPortionOfLongTermDebt")?;
        let current_liabilities_: Option<f64> = obj.get("currentLiabilities")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let deferred_revenue_: Option<f64> = obj.get("deferredRevenue")?;
        let other_current_liabilities_: Option<f64> = obj
            .get("otherCurrentLiabilities")?;
        let fixed_assets_: Option<f64> = obj.get("fixedAssets")?;
        let common_stock_: Option<f64> = obj.get("commonStock")?;
        let minority_interest_: Option<f64> = obj.get("minorityInterest")?;
        let preferred_stock_: Option<f64> = obj.get("preferredStock")?;
        let total_liabilities_: Option<f64> = obj.get("totalLiabilities")?;
        let accounts_receivable_: Option<f64> = obj.get("accountsReceivable")?;
        let notes_: Option<String> = obj.get("notes")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let balance_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("balanceDate")?;
        let short_term_investments_: Option<f64> = obj.get("shortTermInvestments")?;
        let accumulated_depreciation_: Option<f64> = obj.get("accumulatedDepreciation")?;
        let other_non_current_assets_: Option<f64> = obj.get("otherNonCurrentAssets")?;
        let notes_payable_: Option<f64> = obj.get("notesPayable")?;
        let active_: Option<bool> = obj.get("active")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let other_non_current_liabilities_: Option<f64> = obj
            .get("otherNonCurrentLiabilities")?;
        let long_term_debt_: Option<f64> = obj.get("longTermDebt")?;
        let short_term_debt_: Option<f64> = obj.get("shortTermDebt")?;
        let additional_paid_in_capital_: Option<f64> = obj
            .get("additionalPaidInCapital")?;
        let total_liabilities_and_equity_: Option<f64> = obj
            .get("totalLiabilitiesAndEquity")?;
        let non_current_assets_: Option<f64> = obj.get("nonCurrentAssets")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let property_plant_equipment_: Option<f64> = obj.get("propertyPlantEquipment")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let intangible_assets_: Option<f64> = obj.get("intangibleAssets")?;
        let prepaid_expenses_: Option<f64> = obj.get("prepaidExpenses")?;
        let other_current_assets_: Option<f64> = obj.get("otherCurrentAssets")?;
        let treasury_stock_: Option<f64> = obj.get("treasuryStock")?;
        let audit_info_: Option<AuditInformation> = obj.get("auditInfo")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let current_assets_: Option<f64> = obj.get("currentAssets")?;
        let cash_and_cash_equivalents_: Option<f64> = obj.get("cashAndCashEquivalents")?;
        let tax_liabilities_: Option<f64> = obj.get("taxLiabilities")?;
        let equity_: Option<f64> = obj.get("equity")?;
        let account_summary_: Option<Vec<KeyValues>> = obj.get("accountSummary")?;
        let accounts_payable_: Option<f64> = obj.get("accountsPayable")?;
        let accrued_liabilities_: Option<f64> = obj.get("accruedLiabilities")?;
        let id_: Option<String> = obj.get("id")?;
        let stockholders_equity_: Option<f64> = obj.get("stockholdersEquity")?;
        let total_assets_: Option<f64> = obj.get("totalAssets")?;
        let val = Self {
            inventory: inventory_,
            non_current_liabilities: non_current_liabilities_,
            retained_earnings: retained_earnings_,
            current_portion_of_long_term_debt: current_portion_of_long_term_debt_,
            current_liabilities: current_liabilities_,
            modify_token: modify_token_,
            deferred_revenue: deferred_revenue_,
            other_current_liabilities: other_current_liabilities_,
            fixed_assets: fixed_assets_,
            common_stock: common_stock_,
            minority_interest: minority_interest_,
            preferred_stock: preferred_stock_,
            total_liabilities: total_liabilities_,
            accounts_receivable: accounts_receivable_,
            notes: notes_,
            updated_at: updated_at_,
            balance_date: balance_date_,
            short_term_investments: short_term_investments_,
            accumulated_depreciation: accumulated_depreciation_,
            other_non_current_assets: other_non_current_assets_,
            notes_payable: notes_payable_,
            active: active_,
            currency: currency_,
            other_non_current_liabilities: other_non_current_liabilities_,
            long_term_debt: long_term_debt_,
            short_term_debt: short_term_debt_,
            additional_paid_in_capital: additional_paid_in_capital_,
            total_liabilities_and_equity: total_liabilities_and_equity_,
            non_current_assets: non_current_assets_,
            created_at: created_at_,
            property_plant_equipment: property_plant_equipment_,
            custom_fields: custom_fields_,
            intangible_assets: intangible_assets_,
            prepaid_expenses: prepaid_expenses_,
            other_current_assets: other_current_assets_,
            treasury_stock: treasury_stock_,
            audit_info: audit_info_,
            deleted: deleted_,
            current_assets: current_assets_,
            cash_and_cash_equivalents: cash_and_cash_equivalents_,
            tax_liabilities: tax_liabilities_,
            equity: equity_,
            account_summary: account_summary_,
            accounts_payable: accounts_payable_,
            accrued_liabilities: accrued_liabilities_,
            id: id_,
            stockholders_equity: stockholders_equity_,
            total_assets: total_assets_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for BalanceSheets {}
pub struct IncomeStatements {
    pub exchange_rate: Option<f64>,
    pub cost_of_goods_sold: Option<f64>,
    pub profit_margins: Option<f64>,
    pub modify_token: Option<String>,
    pub revenue: Option<RevenueDetails>,
    pub currency: Option<Currency>,
    pub operating_income: Option<f64>,
    pub depreciation_and_amortization: Option<f64>,
    pub income_tax_expense: Option<IncomeTaxExpenseDetails>,
    pub account_summary: Option<Vec<KeyValues>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub id: Option<String>,
    pub shareholder_equity: Option<ShareholderEquityDetails>,
    pub income_before_tax: Option<f64>,
    pub net_income: Option<f64>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub ebitda: Option<f64>,
    pub interest_expense: Option<f64>,
    pub operating_expenses: Option<OperatingExpensesDetails>,
    pub period: Option<String>,
    pub gross_profit: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for IncomeStatements {
    fn type_name() -> &'static str {
        "IncomeStatements"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for IncomeStatements {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: IncomeStatements,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            exchange_rate: exchange_rate_,
            cost_of_goods_sold: cost_of_goods_sold_,
            profit_margins: profit_margins_,
            modify_token: modify_token_,
            revenue: revenue_,
            currency: currency_,
            operating_income: operating_income_,
            depreciation_and_amortization: depreciation_and_amortization_,
            income_tax_expense: income_tax_expense_,
            account_summary: account_summary_,
            created_at: created_at_,
            id: id_,
            shareholder_equity: shareholder_equity_,
            income_before_tax: income_before_tax_,
            net_income: net_income_,
            updated_at: updated_at_,
            ebitda: ebitda_,
            interest_expense: interest_expense_,
            operating_expenses: operating_expenses_,
            period: period_,
            gross_profit: gross_profit_,
        } = val;
        if exchange_rate_.is_some() {
            obj.set("exchangeRate", exchange_rate_)?;
        }
        if cost_of_goods_sold_.is_some() {
            obj.set("costOfGoodsSold", cost_of_goods_sold_)?;
        }
        if profit_margins_.is_some() {
            obj.set("profitMargins", profit_margins_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if revenue_.is_some() {
            obj.set("revenue", revenue_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if operating_income_.is_some() {
            obj.set("operatingIncome", operating_income_)?;
        }
        if depreciation_and_amortization_.is_some() {
            obj.set("depreciationAndAmortization", depreciation_and_amortization_)?;
        }
        if income_tax_expense_.is_some() {
            obj.set("incomeTaxExpense", income_tax_expense_)?;
        }
        if account_summary_.is_some() {
            obj.set("accountSummary", account_summary_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if shareholder_equity_.is_some() {
            obj.set("shareholderEquity", shareholder_equity_)?;
        }
        if income_before_tax_.is_some() {
            obj.set("incomeBeforeTax", income_before_tax_)?;
        }
        if net_income_.is_some() {
            obj.set("netIncome", net_income_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if ebitda_.is_some() {
            obj.set("ebitda", ebitda_)?;
        }
        if interest_expense_.is_some() {
            obj.set("interestExpense", interest_expense_)?;
        }
        if operating_expenses_.is_some() {
            obj.set("operatingExpenses", operating_expenses_)?;
        }
        if period_.is_some() {
            obj.set("period", period_)?;
        }
        if gross_profit_.is_some() {
            obj.set("grossProfit", gross_profit_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for IncomeStatements {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let exchange_rate_: Option<f64> = obj.get("exchangeRate")?;
        let cost_of_goods_sold_: Option<f64> = obj.get("costOfGoodsSold")?;
        let profit_margins_: Option<f64> = obj.get("profitMargins")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let revenue_: Option<RevenueDetails> = obj.get("revenue")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let operating_income_: Option<f64> = obj.get("operatingIncome")?;
        let depreciation_and_amortization_: Option<f64> = obj
            .get("depreciationAndAmortization")?;
        let income_tax_expense_: Option<IncomeTaxExpenseDetails> = obj
            .get("incomeTaxExpense")?;
        let account_summary_: Option<Vec<KeyValues>> = obj.get("accountSummary")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let id_: Option<String> = obj.get("id")?;
        let shareholder_equity_: Option<ShareholderEquityDetails> = obj
            .get("shareholderEquity")?;
        let income_before_tax_: Option<f64> = obj.get("incomeBeforeTax")?;
        let net_income_: Option<f64> = obj.get("netIncome")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let ebitda_: Option<f64> = obj.get("ebitda")?;
        let interest_expense_: Option<f64> = obj.get("interestExpense")?;
        let operating_expenses_: Option<OperatingExpensesDetails> = obj
            .get("operatingExpenses")?;
        let period_: Option<String> = obj.get("period")?;
        let gross_profit_: Option<f64> = obj.get("grossProfit")?;
        let val = Self {
            exchange_rate: exchange_rate_,
            cost_of_goods_sold: cost_of_goods_sold_,
            profit_margins: profit_margins_,
            modify_token: modify_token_,
            revenue: revenue_,
            currency: currency_,
            operating_income: operating_income_,
            depreciation_and_amortization: depreciation_and_amortization_,
            income_tax_expense: income_tax_expense_,
            account_summary: account_summary_,
            created_at: created_at_,
            id: id_,
            shareholder_equity: shareholder_equity_,
            income_before_tax: income_before_tax_,
            net_income: net_income_,
            updated_at: updated_at_,
            ebitda: ebitda_,
            interest_expense: interest_expense_,
            operating_expenses: operating_expenses_,
            period: period_,
            gross_profit: gross_profit_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for IncomeStatements {}
pub struct Invoices {
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub notes: Option<String>,
    pub billing_address: Option<Addresses>,
    pub shipping_address: Option<Addresses>,
    pub discount_percentage: Option<f64>,
    pub items: Option<Vec<InvoiceItems>>,
    pub footer: Option<String>,
    pub id: Option<String>,
    pub active: Option<bool>,
    pub currency: Option<Currency>,
    pub payment_terms: Option<PaymentTerms>,
    pub issued_date: Option<chrono::DateTime<chrono::Utc>>,
    pub tax_total: Option<f64>,
    pub header: Option<String>,
    pub exchange_rate: Option<f64>,
    pub vat_number: Option<String>,
    pub modify_token: Option<String>,
    pub status: Option<PaymentStatus>,
    pub discount_total: Option<f64>,
    pub due_date: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub subtotal: Option<f64>,
    pub adjustments: Option<Vec<InvoiceAdjustments>>,
    pub paid_amount: Option<f64>,
    pub payments: Option<Vec<Payments>>,
    pub attachments: Option<Vec<Attachments>>,
    pub total: Option<f64>,
    pub vat_name: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub customer: Option<Customers>,
    pub balance_due: Option<f64>,
    pub invoice_number: Option<String>,
    pub terms: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Invoices {
    fn type_name() -> &'static str {
        "Invoices"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Invoices {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Invoices,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            updated_at: updated_at_,
            notes: notes_,
            billing_address: billing_address_,
            shipping_address: shipping_address_,
            discount_percentage: discount_percentage_,
            items: items_,
            footer: footer_,
            id: id_,
            active: active_,
            currency: currency_,
            payment_terms: payment_terms_,
            issued_date: issued_date_,
            tax_total: tax_total_,
            header: header_,
            exchange_rate: exchange_rate_,
            vat_number: vat_number_,
            modify_token: modify_token_,
            status: status_,
            discount_total: discount_total_,
            due_date: due_date_,
            deleted: deleted_,
            subtotal: subtotal_,
            adjustments: adjustments_,
            paid_amount: paid_amount_,
            payments: payments_,
            attachments: attachments_,
            total: total_,
            vat_name: vat_name_,
            created_at: created_at_,
            customer: customer_,
            balance_due: balance_due_,
            invoice_number: invoice_number_,
            terms: terms_,
        } = val;
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if billing_address_.is_some() {
            obj.set("billingAddress", billing_address_)?;
        }
        if shipping_address_.is_some() {
            obj.set("shippingAddress", shipping_address_)?;
        }
        if discount_percentage_.is_some() {
            obj.set("discountPercentage", discount_percentage_)?;
        }
        if items_.is_some() {
            obj.set("items", items_)?;
        }
        if footer_.is_some() {
            obj.set("footer", footer_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if payment_terms_.is_some() {
            obj.set("paymentTerms", payment_terms_)?;
        }
        if issued_date_.is_some() {
            obj.set("issuedDate", issued_date_)?;
        }
        if tax_total_.is_some() {
            obj.set("taxTotal", tax_total_)?;
        }
        if header_.is_some() {
            obj.set("header", header_)?;
        }
        if exchange_rate_.is_some() {
            obj.set("exchangeRate", exchange_rate_)?;
        }
        if vat_number_.is_some() {
            obj.set("vatNumber", vat_number_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if discount_total_.is_some() {
            obj.set("discountTotal", discount_total_)?;
        }
        if due_date_.is_some() {
            obj.set("dueDate", due_date_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if subtotal_.is_some() {
            obj.set("subtotal", subtotal_)?;
        }
        if adjustments_.is_some() {
            obj.set("adjustments", adjustments_)?;
        }
        if paid_amount_.is_some() {
            obj.set("paidAmount", paid_amount_)?;
        }
        if payments_.is_some() {
            obj.set("payments", payments_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if total_.is_some() {
            obj.set("total", total_)?;
        }
        if vat_name_.is_some() {
            obj.set("vatName", vat_name_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if customer_.is_some() {
            obj.set("customer", customer_)?;
        }
        if balance_due_.is_some() {
            obj.set("balanceDue", balance_due_)?;
        }
        if invoice_number_.is_some() {
            obj.set("invoiceNumber", invoice_number_)?;
        }
        if terms_.is_some() {
            obj.set("terms", terms_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Invoices {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let notes_: Option<String> = obj.get("notes")?;
        let billing_address_: Option<Addresses> = obj.get("billingAddress")?;
        let shipping_address_: Option<Addresses> = obj.get("shippingAddress")?;
        let discount_percentage_: Option<f64> = obj.get("discountPercentage")?;
        let items_: Option<Vec<InvoiceItems>> = obj.get("items")?;
        let footer_: Option<String> = obj.get("footer")?;
        let id_: Option<String> = obj.get("id")?;
        let active_: Option<bool> = obj.get("active")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let payment_terms_: Option<PaymentTerms> = obj.get("paymentTerms")?;
        let issued_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("issuedDate")?;
        let tax_total_: Option<f64> = obj.get("taxTotal")?;
        let header_: Option<String> = obj.get("header")?;
        let exchange_rate_: Option<f64> = obj.get("exchangeRate")?;
        let vat_number_: Option<String> = obj.get("vatNumber")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let status_: Option<PaymentStatus> = obj.get("status")?;
        let discount_total_: Option<f64> = obj.get("discountTotal")?;
        let due_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("dueDate")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let subtotal_: Option<f64> = obj.get("subtotal")?;
        let adjustments_: Option<Vec<InvoiceAdjustments>> = obj.get("adjustments")?;
        let paid_amount_: Option<f64> = obj.get("paidAmount")?;
        let payments_: Option<Vec<Payments>> = obj.get("payments")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let total_: Option<f64> = obj.get("total")?;
        let vat_name_: Option<String> = obj.get("vatName")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let customer_: Option<Customers> = obj.get("customer")?;
        let balance_due_: Option<f64> = obj.get("balanceDue")?;
        let invoice_number_: Option<String> = obj.get("invoiceNumber")?;
        let terms_: Option<String> = obj.get("terms")?;
        let val = Self {
            updated_at: updated_at_,
            notes: notes_,
            billing_address: billing_address_,
            shipping_address: shipping_address_,
            discount_percentage: discount_percentage_,
            items: items_,
            footer: footer_,
            id: id_,
            active: active_,
            currency: currency_,
            payment_terms: payment_terms_,
            issued_date: issued_date_,
            tax_total: tax_total_,
            header: header_,
            exchange_rate: exchange_rate_,
            vat_number: vat_number_,
            modify_token: modify_token_,
            status: status_,
            discount_total: discount_total_,
            due_date: due_date_,
            deleted: deleted_,
            subtotal: subtotal_,
            adjustments: adjustments_,
            paid_amount: paid_amount_,
            payments: payments_,
            attachments: attachments_,
            total: total_,
            vat_name: vat_name_,
            created_at: created_at_,
            customer: customer_,
            balance_due: balance_due_,
            invoice_number: invoice_number_,
            terms: terms_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Invoices {}
pub struct JournalEntries {
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<JournalEntryStatus>,
    pub name: Option<String>,
    pub deleted: Option<bool>,
    pub total_amount: Option<f64>,
    pub currency: Option<Currency>,
    pub r#type: Option<String>,
    pub description: Option<String>,
    pub line_items: Option<Vec<JournalEntryLines>>,
    pub entry_number: Option<String>,
    pub created_by: Option<String>,
    pub updated_by: Option<String>,
    pub id: Option<String>,
    pub memo: Option<String>,
    pub is_reconciled: Option<bool>,
    pub exchange_rate: Option<f64>,
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    pub reference: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub modify_token: Option<String>,
    pub active: Option<bool>,
    pub attachments: Option<Vec<Attachments>>,
}
impl napi::bindgen_prelude::TypeName for JournalEntries {
    fn type_name() -> &'static str {
        "JournalEntries"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for JournalEntries {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: JournalEntries,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            updated_at: updated_at_,
            status: status_,
            name: name_,
            deleted: deleted_,
            total_amount: total_amount_,
            currency: currency_,
            r#type: type_,
            description: description_,
            line_items: line_items_,
            entry_number: entry_number_,
            created_by: created_by_,
            updated_by: updated_by_,
            id: id_,
            memo: memo_,
            is_reconciled: is_reconciled_,
            exchange_rate: exchange_rate_,
            date: date_,
            reference: reference_,
            created_at: created_at_,
            modify_token: modify_token_,
            active: active_,
            attachments: attachments_,
        } = val;
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if total_amount_.is_some() {
            obj.set("totalAmount", total_amount_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if line_items_.is_some() {
            obj.set("lineItems", line_items_)?;
        }
        if entry_number_.is_some() {
            obj.set("entryNumber", entry_number_)?;
        }
        if created_by_.is_some() {
            obj.set("createdBy", created_by_)?;
        }
        if updated_by_.is_some() {
            obj.set("updatedBy", updated_by_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if memo_.is_some() {
            obj.set("memo", memo_)?;
        }
        if is_reconciled_.is_some() {
            obj.set("isReconciled", is_reconciled_)?;
        }
        if exchange_rate_.is_some() {
            obj.set("exchangeRate", exchange_rate_)?;
        }
        if date_.is_some() {
            obj.set("date", date_)?;
        }
        if reference_.is_some() {
            obj.set("reference", reference_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for JournalEntries {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let status_: Option<JournalEntryStatus> = obj.get("status")?;
        let name_: Option<String> = obj.get("name")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let total_amount_: Option<f64> = obj.get("totalAmount")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let type_: Option<String> = obj.get("type")?;
        let description_: Option<String> = obj.get("description")?;
        let line_items_: Option<Vec<JournalEntryLines>> = obj.get("lineItems")?;
        let entry_number_: Option<String> = obj.get("entryNumber")?;
        let created_by_: Option<String> = obj.get("createdBy")?;
        let updated_by_: Option<String> = obj.get("updatedBy")?;
        let id_: Option<String> = obj.get("id")?;
        let memo_: Option<String> = obj.get("memo")?;
        let is_reconciled_: Option<bool> = obj.get("isReconciled")?;
        let exchange_rate_: Option<f64> = obj.get("exchangeRate")?;
        let date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("date")?;
        let reference_: Option<String> = obj.get("reference")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let active_: Option<bool> = obj.get("active")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let val = Self {
            updated_at: updated_at_,
            status: status_,
            name: name_,
            deleted: deleted_,
            total_amount: total_amount_,
            currency: currency_,
            r#type: type_,
            description: description_,
            line_items: line_items_,
            entry_number: entry_number_,
            created_by: created_by_,
            updated_by: updated_by_,
            id: id_,
            memo: memo_,
            is_reconciled: is_reconciled_,
            exchange_rate: exchange_rate_,
            date: date_,
            reference: reference_,
            created_at: created_at_,
            modify_token: modify_token_,
            active: active_,
            attachments: attachments_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for JournalEntries {}
pub struct JournalEntryLines {
    pub tax_code: Option<String>,
    pub debit: Option<f64>,
    pub description: Option<String>,
    pub credit: Option<f64>,
    pub account_id: Option<String>,
    pub quantity: Option<f64>,
    pub tracking: Option<FinancialTrackingCategories>,
    pub id: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for JournalEntryLines {
    fn type_name() -> &'static str {
        "JournalEntryLines"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for JournalEntryLines {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: JournalEntryLines,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            tax_code: tax_code_,
            debit: debit_,
            description: description_,
            credit: credit_,
            account_id: account_id_,
            quantity: quantity_,
            tracking: tracking_,
            id: id_,
        } = val;
        if tax_code_.is_some() {
            obj.set("taxCode", tax_code_)?;
        }
        if debit_.is_some() {
            obj.set("debit", debit_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if credit_.is_some() {
            obj.set("credit", credit_)?;
        }
        if account_id_.is_some() {
            obj.set("accountId", account_id_)?;
        }
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        if tracking_.is_some() {
            obj.set("tracking", tracking_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for JournalEntryLines {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let tax_code_: Option<String> = obj.get("taxCode")?;
        let debit_: Option<f64> = obj.get("debit")?;
        let description_: Option<String> = obj.get("description")?;
        let credit_: Option<f64> = obj.get("credit")?;
        let account_id_: Option<String> = obj.get("accountId")?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let tracking_: Option<FinancialTrackingCategories> = obj.get("tracking")?;
        let id_: Option<f64> = obj.get("id")?;
        let val = Self {
            tax_code: tax_code_,
            debit: debit_,
            description: description_,
            credit: credit_,
            account_id: account_id_,
            quantity: quantity_,
            tracking: tracking_,
            id: id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for JournalEntryLines {}
pub struct InvoiceItems {
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    pub is_available: Option<bool>,
    pub options: Option<Vec<ProductOptions>>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub availability_date: Option<chrono::DateTime<chrono::Utc>>,
    pub gallery: Option<Vec<Images>>,
    pub id: Option<String>,
    pub variants: Option<Vec<Variants>>,
    pub reviews: Option<Vec<RatingsReviews>>,
    pub rating_count: Option<f64>,
    pub dimensions: Option<Dimensions>,
    pub sku: Option<String>,
    pub condition: Option<ItemCondition>,
    pub upc: Option<String>,
    pub inventory_quantity: Option<f64>,
    pub mpn: Option<String>,
    pub price: Option<f64>,
    pub rating: Option<f64>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub on_sale: Option<bool>,
    pub tags: Option<Vec<String>>,
    pub isbn: Option<String>,
    pub description: Option<String>,
    pub discount: Option<f64>,
    pub active: Option<bool>,
    pub weight: Option<f64>,
    pub image_url: Option<String>,
    pub brand: Option<String>,
    pub inventory_status: Option<ProductAvailabilityStatus>,
    pub ean: Option<String>,
    pub name: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub currency: Option<Currency>,
}
impl napi::bindgen_prelude::TypeName for InvoiceItems {
    fn type_name() -> &'static str {
        "InvoiceItems"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for InvoiceItems {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: InvoiceItems,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            deleted_at: deleted_at_,
            is_available: is_available_,
            options: options_,
            custom_fields: custom_fields_,
            availability_date: availability_date_,
            gallery: gallery_,
            id: id_,
            variants: variants_,
            reviews: reviews_,
            rating_count: rating_count_,
            dimensions: dimensions_,
            sku: sku_,
            condition: condition_,
            upc: upc_,
            inventory_quantity: inventory_quantity_,
            mpn: mpn_,
            price: price_,
            rating: rating_,
            created_at: created_at_,
            on_sale: on_sale_,
            tags: tags_,
            isbn: isbn_,
            description: description_,
            discount: discount_,
            active: active_,
            weight: weight_,
            image_url: image_url_,
            brand: brand_,
            inventory_status: inventory_status_,
            ean: ean_,
            name: name_,
            updated_at: updated_at_,
            currency: currency_,
        } = val;
        if deleted_at_.is_some() {
            obj.set("deletedAt", deleted_at_)?;
        }
        if is_available_.is_some() {
            obj.set("isAvailable", is_available_)?;
        }
        if options_.is_some() {
            obj.set("options", options_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if availability_date_.is_some() {
            obj.set("availabilityDate", availability_date_)?;
        }
        if gallery_.is_some() {
            obj.set("gallery", gallery_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if variants_.is_some() {
            obj.set("variants", variants_)?;
        }
        if reviews_.is_some() {
            obj.set("reviews", reviews_)?;
        }
        if rating_count_.is_some() {
            obj.set("ratingCount", rating_count_)?;
        }
        if dimensions_.is_some() {
            obj.set("dimensions", dimensions_)?;
        }
        if sku_.is_some() {
            obj.set("sku", sku_)?;
        }
        if condition_.is_some() {
            obj.set("condition", condition_)?;
        }
        if upc_.is_some() {
            obj.set("upc", upc_)?;
        }
        if inventory_quantity_.is_some() {
            obj.set("inventoryQuantity", inventory_quantity_)?;
        }
        if mpn_.is_some() {
            obj.set("mpn", mpn_)?;
        }
        if price_.is_some() {
            obj.set("price", price_)?;
        }
        if rating_.is_some() {
            obj.set("rating", rating_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if on_sale_.is_some() {
            obj.set("onSale", on_sale_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if isbn_.is_some() {
            obj.set("isbn", isbn_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if discount_.is_some() {
            obj.set("discount", discount_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if weight_.is_some() {
            obj.set("weight", weight_)?;
        }
        if image_url_.is_some() {
            obj.set("imageUrl", image_url_)?;
        }
        if brand_.is_some() {
            obj.set("brand", brand_)?;
        }
        if inventory_status_.is_some() {
            obj.set("inventoryStatus", inventory_status_)?;
        }
        if ean_.is_some() {
            obj.set("ean", ean_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for InvoiceItems {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let deleted_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("deletedAt")?;
        let is_available_: Option<bool> = obj.get("isAvailable")?;
        let options_: Option<Vec<ProductOptions>> = obj.get("options")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let availability_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("availabilityDate")?;
        let gallery_: Option<Vec<Images>> = obj.get("gallery")?;
        let id_: Option<String> = obj.get("id")?;
        let variants_: Option<Vec<Variants>> = obj.get("variants")?;
        let reviews_: Option<Vec<RatingsReviews>> = obj.get("reviews")?;
        let rating_count_: Option<f64> = obj.get("ratingCount")?;
        let dimensions_: Option<Dimensions> = obj.get("dimensions")?;
        let sku_: Option<String> = obj.get("sku")?;
        let condition_: Option<ItemCondition> = obj.get("condition")?;
        let upc_: Option<String> = obj.get("upc")?;
        let inventory_quantity_: Option<f64> = obj.get("inventoryQuantity")?;
        let mpn_: Option<String> = obj.get("mpn")?;
        let price_: Option<f64> = obj.get("price")?;
        let rating_: Option<f64> = obj.get("rating")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let on_sale_: Option<bool> = obj.get("onSale")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let isbn_: Option<String> = obj.get("isbn")?;
        let description_: Option<String> = obj.get("description")?;
        let discount_: Option<f64> = obj.get("discount")?;
        let active_: Option<bool> = obj.get("active")?;
        let weight_: Option<f64> = obj.get("weight")?;
        let image_url_: Option<String> = obj.get("imageUrl")?;
        let brand_: Option<String> = obj.get("brand")?;
        let inventory_status_: Option<ProductAvailabilityStatus> = obj
            .get("inventoryStatus")?;
        let ean_: Option<String> = obj.get("ean")?;
        let name_: Option<String> = obj.get("name")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let val = Self {
            deleted_at: deleted_at_,
            is_available: is_available_,
            options: options_,
            custom_fields: custom_fields_,
            availability_date: availability_date_,
            gallery: gallery_,
            id: id_,
            variants: variants_,
            reviews: reviews_,
            rating_count: rating_count_,
            dimensions: dimensions_,
            sku: sku_,
            condition: condition_,
            upc: upc_,
            inventory_quantity: inventory_quantity_,
            mpn: mpn_,
            price: price_,
            rating: rating_,
            created_at: created_at_,
            on_sale: on_sale_,
            tags: tags_,
            isbn: isbn_,
            description: description_,
            discount: discount_,
            active: active_,
            weight: weight_,
            image_url: image_url_,
            brand: brand_,
            inventory_status: inventory_status_,
            ean: ean_,
            name: name_,
            updated_at: updated_at_,
            currency: currency_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for InvoiceItems {}
pub struct Tickets {
    pub attachments: Option<Vec<Attachments>>,
    pub reporter: Option<Contacts>,
    pub id: Option<String>,
    pub description: Option<String>,
    pub status: Option<IssueLifecycleStatus>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub tags: Option<Vec<String>>,
    pub r#type: Option<SupportQueryType>,
    pub due_date: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub comments: Option<Vec<Comments>>,
    pub priority: Option<SupportTicketPriority>,
    pub notes: Option<Vec<Notes>>,
    pub modify_token: Option<String>,
    pub title: Option<String>,
    pub assignee: Option<Users>,
}
impl napi::bindgen_prelude::TypeName for Tickets {
    fn type_name() -> &'static str {
        "Tickets"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Tickets {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Tickets,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            attachments: attachments_,
            reporter: reporter_,
            id: id_,
            description: description_,
            status: status_,
            updated_at: updated_at_,
            custom_fields: custom_fields_,
            tags: tags_,
            r#type: type_,
            due_date: due_date_,
            created_at: created_at_,
            comments: comments_,
            priority: priority_,
            notes: notes_,
            modify_token: modify_token_,
            title: title_,
            assignee: assignee_,
        } = val;
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if reporter_.is_some() {
            obj.set("reporter", reporter_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if due_date_.is_some() {
            obj.set("dueDate", due_date_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if comments_.is_some() {
            obj.set("comments", comments_)?;
        }
        if priority_.is_some() {
            obj.set("priority", priority_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if assignee_.is_some() {
            obj.set("assignee", assignee_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Tickets {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let reporter_: Option<Contacts> = obj.get("reporter")?;
        let id_: Option<String> = obj.get("id")?;
        let description_: Option<String> = obj.get("description")?;
        let status_: Option<IssueLifecycleStatus> = obj.get("status")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let type_: Option<SupportQueryType> = obj.get("type")?;
        let due_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("dueDate")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let comments_: Option<Vec<Comments>> = obj.get("comments")?;
        let priority_: Option<SupportTicketPriority> = obj.get("priority")?;
        let notes_: Option<Vec<Notes>> = obj.get("notes")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let title_: Option<String> = obj.get("title")?;
        let assignee_: Option<Users> = obj.get("assignee")?;
        let val = Self {
            attachments: attachments_,
            reporter: reporter_,
            id: id_,
            description: description_,
            status: status_,
            updated_at: updated_at_,
            custom_fields: custom_fields_,
            tags: tags_,
            r#type: type_,
            due_date: due_date_,
            created_at: created_at_,
            comments: comments_,
            priority: priority_,
            notes: notes_,
            modify_token: modify_token_,
            title: title_,
            assignee: assignee_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Tickets {}
pub struct WorkExperiences {
    pub company: Option<String>,
    pub position: Option<String>,
    pub description: Option<String>,
    pub start_date: Option<chrono::DateTime<chrono::Utc>>,
    pub end_date: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for WorkExperiences {
    fn type_name() -> &'static str {
        "WorkExperiences"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for WorkExperiences {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: WorkExperiences,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            company: company_,
            position: position_,
            description: description_,
            start_date: start_date_,
            end_date: end_date_,
        } = val;
        if company_.is_some() {
            obj.set("company", company_)?;
        }
        if position_.is_some() {
            obj.set("position", position_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if start_date_.is_some() {
            obj.set("startDate", start_date_)?;
        }
        if end_date_.is_some() {
            obj.set("endDate", end_date_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for WorkExperiences {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let company_: Option<String> = obj.get("company")?;
        let position_: Option<String> = obj.get("position")?;
        let description_: Option<String> = obj.get("description")?;
        let start_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("startDate")?;
        let end_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("endDate")?;
        let val = Self {
            company: company_,
            position: position_,
            description: description_,
            start_date: start_date_,
            end_date: end_date_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for WorkExperiences {}
pub struct Educations {
    pub institution: Option<String>,
    pub degree: Option<String>,
    pub field_of_study: Option<String>,
    pub start_date: Option<chrono::DateTime<chrono::Utc>>,
    pub end_date: Option<chrono::DateTime<chrono::Utc>>,
    pub gpa: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for Educations {
    fn type_name() -> &'static str {
        "Educations"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Educations {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Educations,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            institution: institution_,
            degree: degree_,
            field_of_study: field_of_study_,
            start_date: start_date_,
            end_date: end_date_,
            gpa: gpa_,
        } = val;
        if institution_.is_some() {
            obj.set("institution", institution_)?;
        }
        if degree_.is_some() {
            obj.set("degree", degree_)?;
        }
        if field_of_study_.is_some() {
            obj.set("fieldOfStudy", field_of_study_)?;
        }
        if start_date_.is_some() {
            obj.set("startDate", start_date_)?;
        }
        if end_date_.is_some() {
            obj.set("endDate", end_date_)?;
        }
        if gpa_.is_some() {
            obj.set("gpa", gpa_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Educations {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let institution_: Option<String> = obj.get("institution")?;
        let degree_: Option<String> = obj.get("degree")?;
        let field_of_study_: Option<String> = obj.get("fieldOfStudy")?;
        let start_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("startDate")?;
        let end_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("endDate")?;
        let gpa_: Option<f64> = obj.get("gpa")?;
        let val = Self {
            institution: institution_,
            degree: degree_,
            field_of_study: field_of_study_,
            start_date: start_date_,
            end_date: end_date_,
            gpa: gpa_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Educations {}
pub struct References {
    pub name: Option<String>,
    pub position: Option<String>,
    pub relationship: Option<String>,
    pub company: Option<String>,
    pub email: Option<String>,
    pub phone_number: Option<String>,
}
impl napi::bindgen_prelude::TypeName for References {
    fn type_name() -> &'static str {
        "References"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for References {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: References,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            name: name_,
            position: position_,
            relationship: relationship_,
            company: company_,
            email: email_,
            phone_number: phone_number_,
        } = val;
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if position_.is_some() {
            obj.set("position", position_)?;
        }
        if relationship_.is_some() {
            obj.set("relationship", relationship_)?;
        }
        if company_.is_some() {
            obj.set("company", company_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if phone_number_.is_some() {
            obj.set("phoneNumber", phone_number_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for References {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let name_: Option<String> = obj.get("name")?;
        let position_: Option<String> = obj.get("position")?;
        let relationship_: Option<String> = obj.get("relationship")?;
        let company_: Option<String> = obj.get("company")?;
        let email_: Option<String> = obj.get("email")?;
        let phone_number_: Option<String> = obj.get("phoneNumber")?;
        let val = Self {
            name: name_,
            position: position_,
            relationship: relationship_,
            company: company_,
            email: email_,
            phone_number: phone_number_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for References {}
pub struct Candidates {
    pub first_name: Option<String>,
    pub phone_number: Option<String>,
    pub id: Option<String>,
    pub references: Option<Vec<References>>,
    pub email: Option<String>,
    pub role: Option<String>,
    pub languages: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub certifications: Option<Vec<String>>,
    pub profile_picture: Option<Images>,
    pub work_experiences: Option<Vec<WorkExperiences>>,
    pub last_name: Option<String>,
    pub resume: Option<Attachments>,
    pub educations: Option<Vec<Educations>>,
    pub availability: Option<chrono::DateTime<chrono::Utc>>,
    pub job_id: Option<String>,
    pub websites: Option<Vec<String>>,
    pub preferred_work_location: Option<String>,
    pub status: Option<EmploymentAndCandidateStatus>,
    pub cover_letter: Option<Attachments>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub notes: Option<Vec<Notes>>,
    pub skills: Option<Vec<String>>,
    pub modify_token: Option<String>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Candidates {
    fn type_name() -> &'static str {
        "Candidates"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Candidates {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Candidates,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            first_name: first_name_,
            phone_number: phone_number_,
            id: id_,
            references: references_,
            email: email_,
            role: role_,
            languages: languages_,
            updated_at: updated_at_,
            certifications: certifications_,
            profile_picture: profile_picture_,
            work_experiences: work_experiences_,
            last_name: last_name_,
            resume: resume_,
            educations: educations_,
            availability: availability_,
            job_id: job_id_,
            websites: websites_,
            preferred_work_location: preferred_work_location_,
            status: status_,
            cover_letter: cover_letter_,
            custom_fields: custom_fields_,
            notes: notes_,
            skills: skills_,
            modify_token: modify_token_,
            social_profiles: social_profiles_,
            created_at: created_at_,
        } = val;
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if phone_number_.is_some() {
            obj.set("phoneNumber", phone_number_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if references_.is_some() {
            obj.set("references", references_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if role_.is_some() {
            obj.set("role", role_)?;
        }
        if languages_.is_some() {
            obj.set("languages", languages_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if certifications_.is_some() {
            obj.set("certifications", certifications_)?;
        }
        if profile_picture_.is_some() {
            obj.set("profilePicture", profile_picture_)?;
        }
        if work_experiences_.is_some() {
            obj.set("workExperiences", work_experiences_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        if resume_.is_some() {
            obj.set("resume", resume_)?;
        }
        if educations_.is_some() {
            obj.set("educations", educations_)?;
        }
        if availability_.is_some() {
            obj.set("availability", availability_)?;
        }
        if job_id_.is_some() {
            obj.set("jobId", job_id_)?;
        }
        if websites_.is_some() {
            obj.set("websites", websites_)?;
        }
        if preferred_work_location_.is_some() {
            obj.set("preferredWorkLocation", preferred_work_location_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if cover_letter_.is_some() {
            obj.set("coverLetter", cover_letter_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if skills_.is_some() {
            obj.set("skills", skills_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Candidates {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let phone_number_: Option<String> = obj.get("phoneNumber")?;
        let id_: Option<String> = obj.get("id")?;
        let references_: Option<Vec<References>> = obj.get("references")?;
        let email_: Option<String> = obj.get("email")?;
        let role_: Option<String> = obj.get("role")?;
        let languages_: Option<Vec<String>> = obj.get("languages")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let certifications_: Option<Vec<String>> = obj.get("certifications")?;
        let profile_picture_: Option<Images> = obj.get("profilePicture")?;
        let work_experiences_: Option<Vec<WorkExperiences>> = obj
            .get("workExperiences")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let resume_: Option<Attachments> = obj.get("resume")?;
        let educations_: Option<Vec<Educations>> = obj.get("educations")?;
        let availability_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("availability")?;
        let job_id_: Option<String> = obj.get("jobId")?;
        let websites_: Option<Vec<String>> = obj.get("websites")?;
        let preferred_work_location_: Option<String> = obj.get("preferredWorkLocation")?;
        let status_: Option<EmploymentAndCandidateStatus> = obj.get("status")?;
        let cover_letter_: Option<Attachments> = obj.get("coverLetter")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let notes_: Option<Vec<Notes>> = obj.get("notes")?;
        let skills_: Option<Vec<String>> = obj.get("skills")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let val = Self {
            first_name: first_name_,
            phone_number: phone_number_,
            id: id_,
            references: references_,
            email: email_,
            role: role_,
            languages: languages_,
            updated_at: updated_at_,
            certifications: certifications_,
            profile_picture: profile_picture_,
            work_experiences: work_experiences_,
            last_name: last_name_,
            resume: resume_,
            educations: educations_,
            availability: availability_,
            job_id: job_id_,
            websites: websites_,
            preferred_work_location: preferred_work_location_,
            status: status_,
            cover_letter: cover_letter_,
            custom_fields: custom_fields_,
            notes: notes_,
            skills: skills_,
            modify_token: modify_token_,
            social_profiles: social_profiles_,
            created_at: created_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Candidates {}
pub struct Contacts {
    pub addresses: Option<Vec<Addresses>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub modify_token: Option<String>,
    pub phones: Option<Vec<Phones>>,
    pub company: Option<String>,
    pub websites: Option<Vec<String>>,
    pub first_name: Option<String>,
    pub address: Option<Addresses>,
    pub is_active: Option<bool>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub tags: Option<Vec<String>>,
    pub birthday: Option<chrono::DateTime<chrono::Utc>>,
    pub notes: Option<Notes>,
    pub relationship: Option<String>,
    pub emails: Option<Vec<Emails>>,
    pub id: Option<String>,
    pub lead_id: Option<String>,
    pub default_email: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub note: Option<String>,
    pub last_name: Option<String>,
    pub default_phone: Option<String>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
}
impl napi::bindgen_prelude::TypeName for Contacts {
    fn type_name() -> &'static str {
        "Contacts"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Contacts {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Contacts,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            addresses: addresses_,
            updated_at: updated_at_,
            modify_token: modify_token_,
            phones: phones_,
            company: company_,
            websites: websites_,
            first_name: first_name_,
            address: address_,
            is_active: is_active_,
            custom_fields: custom_fields_,
            tags: tags_,
            birthday: birthday_,
            notes: notes_,
            relationship: relationship_,
            emails: emails_,
            id: id_,
            lead_id: lead_id_,
            default_email: default_email_,
            created_at: created_at_,
            note: note_,
            last_name: last_name_,
            default_phone: default_phone_,
            social_profiles: social_profiles_,
        } = val;
        if addresses_.is_some() {
            obj.set("addresses", addresses_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if phones_.is_some() {
            obj.set("phones", phones_)?;
        }
        if company_.is_some() {
            obj.set("company", company_)?;
        }
        if websites_.is_some() {
            obj.set("websites", websites_)?;
        }
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if is_active_.is_some() {
            obj.set("isActive", is_active_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if birthday_.is_some() {
            obj.set("birthday", birthday_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if relationship_.is_some() {
            obj.set("relationship", relationship_)?;
        }
        if emails_.is_some() {
            obj.set("emails", emails_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if lead_id_.is_some() {
            obj.set("leadId", lead_id_)?;
        }
        if default_email_.is_some() {
            obj.set("defaultEmail", default_email_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if note_.is_some() {
            obj.set("note", note_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        if default_phone_.is_some() {
            obj.set("defaultPhone", default_phone_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Contacts {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let addresses_: Option<Vec<Addresses>> = obj.get("addresses")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let phones_: Option<Vec<Phones>> = obj.get("phones")?;
        let company_: Option<String> = obj.get("company")?;
        let websites_: Option<Vec<String>> = obj.get("websites")?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let is_active_: Option<bool> = obj.get("isActive")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let birthday_: Option<chrono::DateTime<chrono::Utc>> = obj.get("birthday")?;
        let notes_: Option<Notes> = obj.get("notes")?;
        let relationship_: Option<String> = obj.get("relationship")?;
        let emails_: Option<Vec<Emails>> = obj.get("emails")?;
        let id_: Option<String> = obj.get("id")?;
        let lead_id_: Option<String> = obj.get("leadId")?;
        let default_email_: Option<String> = obj.get("defaultEmail")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let note_: Option<String> = obj.get("note")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let default_phone_: Option<String> = obj.get("defaultPhone")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let val = Self {
            addresses: addresses_,
            updated_at: updated_at_,
            modify_token: modify_token_,
            phones: phones_,
            company: company_,
            websites: websites_,
            first_name: first_name_,
            address: address_,
            is_active: is_active_,
            custom_fields: custom_fields_,
            tags: tags_,
            birthday: birthday_,
            notes: notes_,
            relationship: relationship_,
            emails: emails_,
            id: id_,
            lead_id: lead_id_,
            default_email: default_email_,
            created_at: created_at_,
            note: note_,
            last_name: last_name_,
            default_phone: default_phone_,
            social_profiles: social_profiles_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Contacts {}
pub struct Jobs {
    pub description: Option<String>,
    pub occupational_category: Option<String>,
    pub job_start_date: Option<chrono::DateTime<chrono::Utc>>,
    pub languages_spoken: Option<Vec<String>>,
    pub job_trial_period: Option<String>,
    pub employment_type: Option<EmploymentType>,
    pub id: Option<String>,
    pub job_flexible_hours: Option<bool>,
    pub job_location_type: Option<String>,
    pub incentive_compensation: Option<String>,
    pub education_requirements: Option<String>,
    pub location: Option<Addresses>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub job_immediate_start: Option<bool>,
    pub incentives: Option<String>,
    pub benefits: Option<Vec<String>>,
    pub work_hours: Option<String>,
    pub company: Option<Companies>,
    pub remote: Option<bool>,
    pub qualifications: Option<String>,
    pub industry: Option<String>,
    pub salary_currency: Option<String>,
    pub base_salary: Option<Salaries>,
    pub job_benefits: Option<String>,
    pub experience_requirements: Option<String>,
    pub responsibilities: Option<String>,
    pub title: Option<String>,
    pub skills: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub employment_unit: Option<EmploymentUnits>,
    pub job_training_provided: Option<bool>,
    pub job_shifts: Option<Vec<String>>,
    pub valid_until: Option<chrono::DateTime<chrono::Utc>>,
    pub work_from_home: Option<bool>,
    pub modify_token: Option<String>,
    pub application_deadline: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Jobs {
    fn type_name() -> &'static str {
        "Jobs"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Jobs {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Jobs,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            description: description_,
            occupational_category: occupational_category_,
            job_start_date: job_start_date_,
            languages_spoken: languages_spoken_,
            job_trial_period: job_trial_period_,
            employment_type: employment_type_,
            id: id_,
            job_flexible_hours: job_flexible_hours_,
            job_location_type: job_location_type_,
            incentive_compensation: incentive_compensation_,
            education_requirements: education_requirements_,
            location: location_,
            created_at: created_at_,
            job_immediate_start: job_immediate_start_,
            incentives: incentives_,
            benefits: benefits_,
            work_hours: work_hours_,
            company: company_,
            remote: remote_,
            qualifications: qualifications_,
            industry: industry_,
            salary_currency: salary_currency_,
            base_salary: base_salary_,
            job_benefits: job_benefits_,
            experience_requirements: experience_requirements_,
            responsibilities: responsibilities_,
            title: title_,
            skills: skills_,
            updated_at: updated_at_,
            employment_unit: employment_unit_,
            job_training_provided: job_training_provided_,
            job_shifts: job_shifts_,
            valid_until: valid_until_,
            work_from_home: work_from_home_,
            modify_token: modify_token_,
            application_deadline: application_deadline_,
        } = val;
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if occupational_category_.is_some() {
            obj.set("occupationalCategory", occupational_category_)?;
        }
        if job_start_date_.is_some() {
            obj.set("jobStartDate", job_start_date_)?;
        }
        if languages_spoken_.is_some() {
            obj.set("languagesSpoken", languages_spoken_)?;
        }
        if job_trial_period_.is_some() {
            obj.set("jobTrialPeriod", job_trial_period_)?;
        }
        if employment_type_.is_some() {
            obj.set("employmentType", employment_type_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if job_flexible_hours_.is_some() {
            obj.set("jobFlexibleHours", job_flexible_hours_)?;
        }
        if job_location_type_.is_some() {
            obj.set("jobLocationType", job_location_type_)?;
        }
        if incentive_compensation_.is_some() {
            obj.set("incentiveCompensation", incentive_compensation_)?;
        }
        if education_requirements_.is_some() {
            obj.set("educationRequirements", education_requirements_)?;
        }
        if location_.is_some() {
            obj.set("location", location_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if job_immediate_start_.is_some() {
            obj.set("jobImmediateStart", job_immediate_start_)?;
        }
        if incentives_.is_some() {
            obj.set("incentives", incentives_)?;
        }
        if benefits_.is_some() {
            obj.set("benefits", benefits_)?;
        }
        if work_hours_.is_some() {
            obj.set("workHours", work_hours_)?;
        }
        if company_.is_some() {
            obj.set("company", company_)?;
        }
        if remote_.is_some() {
            obj.set("remote", remote_)?;
        }
        if qualifications_.is_some() {
            obj.set("qualifications", qualifications_)?;
        }
        if industry_.is_some() {
            obj.set("industry", industry_)?;
        }
        if salary_currency_.is_some() {
            obj.set("salaryCurrency", salary_currency_)?;
        }
        if base_salary_.is_some() {
            obj.set("baseSalary", base_salary_)?;
        }
        if job_benefits_.is_some() {
            obj.set("jobBenefits", job_benefits_)?;
        }
        if experience_requirements_.is_some() {
            obj.set("experienceRequirements", experience_requirements_)?;
        }
        if responsibilities_.is_some() {
            obj.set("responsibilities", responsibilities_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if skills_.is_some() {
            obj.set("skills", skills_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if employment_unit_.is_some() {
            obj.set("employmentUnit", employment_unit_)?;
        }
        if job_training_provided_.is_some() {
            obj.set("jobTrainingProvided", job_training_provided_)?;
        }
        if job_shifts_.is_some() {
            obj.set("jobShifts", job_shifts_)?;
        }
        if valid_until_.is_some() {
            obj.set("validUntil", valid_until_)?;
        }
        if work_from_home_.is_some() {
            obj.set("workFromHome", work_from_home_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if application_deadline_.is_some() {
            obj.set("applicationDeadline", application_deadline_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Jobs {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let description_: Option<String> = obj.get("description")?;
        let occupational_category_: Option<String> = obj.get("occupationalCategory")?;
        let job_start_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("jobStartDate")?;
        let languages_spoken_: Option<Vec<String>> = obj.get("languagesSpoken")?;
        let job_trial_period_: Option<String> = obj.get("jobTrialPeriod")?;
        let employment_type_: Option<EmploymentType> = obj.get("employmentType")?;
        let id_: Option<String> = obj.get("id")?;
        let job_flexible_hours_: Option<bool> = obj.get("jobFlexibleHours")?;
        let job_location_type_: Option<String> = obj.get("jobLocationType")?;
        let incentive_compensation_: Option<String> = obj.get("incentiveCompensation")?;
        let education_requirements_: Option<String> = obj.get("educationRequirements")?;
        let location_: Option<Addresses> = obj.get("location")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let job_immediate_start_: Option<bool> = obj.get("jobImmediateStart")?;
        let incentives_: Option<String> = obj.get("incentives")?;
        let benefits_: Option<Vec<String>> = obj.get("benefits")?;
        let work_hours_: Option<String> = obj.get("workHours")?;
        let company_: Option<Companies> = obj.get("company")?;
        let remote_: Option<bool> = obj.get("remote")?;
        let qualifications_: Option<String> = obj.get("qualifications")?;
        let industry_: Option<String> = obj.get("industry")?;
        let salary_currency_: Option<String> = obj.get("salaryCurrency")?;
        let base_salary_: Option<Salaries> = obj.get("baseSalary")?;
        let job_benefits_: Option<String> = obj.get("jobBenefits")?;
        let experience_requirements_: Option<String> = obj
            .get("experienceRequirements")?;
        let responsibilities_: Option<String> = obj.get("responsibilities")?;
        let title_: Option<String> = obj.get("title")?;
        let skills_: Option<Vec<String>> = obj.get("skills")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let employment_unit_: Option<EmploymentUnits> = obj.get("employmentUnit")?;
        let job_training_provided_: Option<bool> = obj.get("jobTrainingProvided")?;
        let job_shifts_: Option<Vec<String>> = obj.get("jobShifts")?;
        let valid_until_: Option<chrono::DateTime<chrono::Utc>> = obj.get("validUntil")?;
        let work_from_home_: Option<bool> = obj.get("workFromHome")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let application_deadline_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("applicationDeadline")?;
        let val = Self {
            description: description_,
            occupational_category: occupational_category_,
            job_start_date: job_start_date_,
            languages_spoken: languages_spoken_,
            job_trial_period: job_trial_period_,
            employment_type: employment_type_,
            id: id_,
            job_flexible_hours: job_flexible_hours_,
            job_location_type: job_location_type_,
            incentive_compensation: incentive_compensation_,
            education_requirements: education_requirements_,
            location: location_,
            created_at: created_at_,
            job_immediate_start: job_immediate_start_,
            incentives: incentives_,
            benefits: benefits_,
            work_hours: work_hours_,
            company: company_,
            remote: remote_,
            qualifications: qualifications_,
            industry: industry_,
            salary_currency: salary_currency_,
            base_salary: base_salary_,
            job_benefits: job_benefits_,
            experience_requirements: experience_requirements_,
            responsibilities: responsibilities_,
            title: title_,
            skills: skills_,
            updated_at: updated_at_,
            employment_unit: employment_unit_,
            job_training_provided: job_training_provided_,
            job_shifts: job_shifts_,
            valid_until: valid_until_,
            work_from_home: work_from_home_,
            modify_token: modify_token_,
            application_deadline: application_deadline_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Jobs {}
pub struct Salaries {
    pub payment_period: Option<TimeCycle>,
    pub value: Option<f64>,
    pub currency: Option<Currency>,
}
impl napi::bindgen_prelude::TypeName for Salaries {
    fn type_name() -> &'static str {
        "Salaries"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Salaries {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Salaries,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            payment_period: payment_period_,
            value: value_,
            currency: currency_,
        } = val;
        if payment_period_.is_some() {
            obj.set("paymentPeriod", payment_period_)?;
        }
        if value_.is_some() {
            obj.set("value", value_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Salaries {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let payment_period_: Option<TimeCycle> = obj.get("paymentPeriod")?;
        let value_: Option<f64> = obj.get("value")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let val = Self {
            payment_period: payment_period_,
            value: value_,
            currency: currency_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Salaries {}
pub struct HiringOrganizations {
    pub size: Option<String>,
    pub locations: Option<Vec<Addresses>>,
    pub name: Option<String>,
    pub industry: Option<String>,
    pub description: Option<String>,
}
impl napi::bindgen_prelude::TypeName for HiringOrganizations {
    fn type_name() -> &'static str {
        "HiringOrganizations"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for HiringOrganizations {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: HiringOrganizations,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            size: size_,
            locations: locations_,
            name: name_,
            industry: industry_,
            description: description_,
        } = val;
        if size_.is_some() {
            obj.set("size", size_)?;
        }
        if locations_.is_some() {
            obj.set("locations", locations_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if industry_.is_some() {
            obj.set("industry", industry_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for HiringOrganizations {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let size_: Option<String> = obj.get("size")?;
        let locations_: Option<Vec<Addresses>> = obj.get("locations")?;
        let name_: Option<String> = obj.get("name")?;
        let industry_: Option<String> = obj.get("industry")?;
        let description_: Option<String> = obj.get("description")?;
        let val = Self {
            size: size_,
            locations: locations_,
            name: name_,
            industry: industry_,
            description: description_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for HiringOrganizations {}
pub struct EmploymentUnits {
    pub description: Option<String>,
    pub name: Option<String>,
}
impl napi::bindgen_prelude::TypeName for EmploymentUnits {
    fn type_name() -> &'static str {
        "EmploymentUnits"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for EmploymentUnits {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: EmploymentUnits,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { description: description_, name: name_ } = val;
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for EmploymentUnits {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let description_: Option<String> = obj.get("description")?;
        let name_: Option<String> = obj.get("name")?;
        let val = Self {
            description: description_,
            name: name_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for EmploymentUnits {}
pub struct TimeSession {
    pub close_time: Option<String>,
    pub open_time: Option<String>,
}
impl napi::bindgen_prelude::TypeName for TimeSession {
    fn type_name() -> &'static str {
        "TimeSession"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for TimeSession {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: TimeSession,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { close_time: close_time_, open_time: open_time_ } = val;
        if close_time_.is_some() {
            obj.set("closeTime", close_time_)?;
        }
        if open_time_.is_some() {
            obj.set("openTime", open_time_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for TimeSession {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let close_time_: Option<String> = obj.get("closeTime")?;
        let open_time_: Option<String> = obj.get("openTime")?;
        let val = Self {
            close_time: close_time_,
            open_time: open_time_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TimeSession {}
pub struct UserOrGroup {
    pub identifier: Option<String>,
    pub display_name: Option<String>,
    pub r#type: Option<ParticipantType>,
}
impl napi::bindgen_prelude::TypeName for UserOrGroup {
    fn type_name() -> &'static str {
        "UserOrGroup"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for UserOrGroup {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: UserOrGroup,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            identifier: identifier_,
            display_name: display_name_,
            r#type: type_,
        } = val;
        if identifier_.is_some() {
            obj.set("identifier", identifier_)?;
        }
        if display_name_.is_some() {
            obj.set("displayName", display_name_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for UserOrGroup {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let identifier_: Option<String> = obj.get("identifier")?;
        let display_name_: Option<String> = obj.get("displayName")?;
        let type_: Option<ParticipantType> = obj.get("type")?;
        let val = Self {
            identifier: identifier_,
            display_name: display_name_,
            r#type: type_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for UserOrGroup {}
pub struct Permissions {
    pub can_edit: Option<Vec<String>>,
    pub roles: Option<Vec<String>>,
    pub assignee_details: Option<UserOrGroup>,
    pub can_view: Option<Vec<String>>,
    pub access_control_type: Option<AccessControlModel>,
    pub can_delete: Option<Vec<String>>,
    pub identifier_type: Option<UniversalIdentifierType>,
}
impl napi::bindgen_prelude::TypeName for Permissions {
    fn type_name() -> &'static str {
        "Permissions"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Permissions {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Permissions,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            can_edit: can_edit_,
            roles: roles_,
            assignee_details: assignee_details_,
            can_view: can_view_,
            access_control_type: access_control_type_,
            can_delete: can_delete_,
            identifier_type: identifier_type_,
        } = val;
        if can_edit_.is_some() {
            obj.set("canEdit", can_edit_)?;
        }
        if roles_.is_some() {
            obj.set("roles", roles_)?;
        }
        if assignee_details_.is_some() {
            obj.set("assigneeDetails", assignee_details_)?;
        }
        if can_view_.is_some() {
            obj.set("canView", can_view_)?;
        }
        if access_control_type_.is_some() {
            obj.set("accessControlType", access_control_type_)?;
        }
        if can_delete_.is_some() {
            obj.set("canDelete", can_delete_)?;
        }
        if identifier_type_.is_some() {
            obj.set("identifierType", identifier_type_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Permissions {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let can_edit_: Option<Vec<String>> = obj.get("canEdit")?;
        let roles_: Option<Vec<String>> = obj.get("roles")?;
        let assignee_details_: Option<UserOrGroup> = obj.get("assigneeDetails")?;
        let can_view_: Option<Vec<String>> = obj.get("canView")?;
        let access_control_type_: Option<AccessControlModel> = obj
            .get("accessControlType")?;
        let can_delete_: Option<Vec<String>> = obj.get("canDelete")?;
        let identifier_type_: Option<UniversalIdentifierType> = obj
            .get("identifierType")?;
        let val = Self {
            can_edit: can_edit_,
            roles: roles_,
            assignee_details: assignee_details_,
            can_view: can_view_,
            access_control_type: access_control_type_,
            can_delete: can_delete_,
            identifier_type: identifier_type_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Permissions {}
pub struct Phones {
    pub phone: Option<String>,
    pub country: Option<String>,
    pub country_code: Option<String>,
    pub r#type: Option<DeviceUsageType>,
}
impl napi::bindgen_prelude::TypeName for Phones {
    fn type_name() -> &'static str {
        "Phones"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Phones {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Phones,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            phone: phone_,
            country: country_,
            country_code: country_code_,
            r#type: type_,
        } = val;
        if phone_.is_some() {
            obj.set("phone", phone_)?;
        }
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if country_code_.is_some() {
            obj.set("countryCode", country_code_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Phones {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let phone_: Option<String> = obj.get("phone")?;
        let country_: Option<String> = obj.get("country")?;
        let country_code_: Option<String> = obj.get("countryCode")?;
        let type_: Option<DeviceUsageType> = obj.get("type")?;
        let val = Self {
            phone: phone_,
            country: country_,
            country_code: country_code_,
            r#type: type_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Phones {}
pub struct Emails {
    pub r#type: Option<EmailCategoryType>,
    pub email: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Emails {
    fn type_name() -> &'static str {
        "Emails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Emails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Emails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { r#type: type_, email: email_ } = val;
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Emails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let type_: Option<EmailCategoryType> = obj.get("type")?;
        let email_: Option<String> = obj.get("email")?;
        let val = Self {
            r#type: type_,
            email: email_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Emails {}
pub struct Entity {
    pub attributes: Option<Vec<String>>,
    pub entity_type: Option<EntityCategory>,
    pub entity_id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Entity {
    fn type_name() -> &'static str {
        "Entity"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Entity {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Entity,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            attributes: attributes_,
            entity_type: entity_type_,
            entity_id: entity_id_,
        } = val;
        if attributes_.is_some() {
            obj.set("attributes", attributes_)?;
        }
        if entity_type_.is_some() {
            obj.set("entityType", entity_type_)?;
        }
        if entity_id_.is_some() {
            obj.set("entityId", entity_id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Entity {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let attributes_: Option<Vec<String>> = obj.get("attributes")?;
        let entity_type_: Option<EntityCategory> = obj.get("entityType")?;
        let entity_id_: Option<String> = obj.get("entityId")?;
        let val = Self {
            attributes: attributes_,
            entity_type: entity_type_,
            entity_id: entity_id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Entity {}
pub struct Notifications {
    pub deleted: Option<bool>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub attachments: Option<Vec<Attachments>>,
    pub notification_id: Option<String>,
    pub priority: Option<PriorityLevel>,
    pub status: Option<String>,
    pub message: Option<String>,
    pub channel: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub recipient: Option<Users>,
    pub title: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
    pub r#type: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Notifications {
    fn type_name() -> &'static str {
        "Notifications"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Notifications {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Notifications,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            deleted: deleted_,
            custom_fields: custom_fields_,
            attachments: attachments_,
            notification_id: notification_id_,
            priority: priority_,
            status: status_,
            message: message_,
            channel: channel_,
            created_at: created_at_,
            recipient: recipient_,
            title: title_,
            updated_at: updated_at_,
            active: active_,
            r#type: type_,
        } = val;
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if notification_id_.is_some() {
            obj.set("notificationId", notification_id_)?;
        }
        if priority_.is_some() {
            obj.set("priority", priority_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if message_.is_some() {
            obj.set("message", message_)?;
        }
        if channel_.is_some() {
            obj.set("channel", channel_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if recipient_.is_some() {
            obj.set("recipient", recipient_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Notifications {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let notification_id_: Option<String> = obj.get("notificationId")?;
        let priority_: Option<PriorityLevel> = obj.get("priority")?;
        let status_: Option<String> = obj.get("status")?;
        let message_: Option<String> = obj.get("message")?;
        let channel_: Option<String> = obj.get("channel")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let recipient_: Option<Users> = obj.get("recipient")?;
        let title_: Option<String> = obj.get("title")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let type_: Option<String> = obj.get("type")?;
        let val = Self {
            deleted: deleted_,
            custom_fields: custom_fields_,
            attachments: attachments_,
            notification_id: notification_id_,
            priority: priority_,
            status: status_,
            message: message_,
            channel: channel_,
            created_at: created_at_,
            recipient: recipient_,
            title: title_,
            updated_at: updated_at_,
            active: active_,
            r#type: type_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Notifications {}
pub struct Comments {
    pub text: Option<String>,
    pub comment_id: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub flagged: Option<bool>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub author: Option<Users>,
    pub parent_id: Option<String>,
    pub likes: Option<f64>,
    pub metadata: Option<Vec<Metadata>>,
    pub deleted: Option<bool>,
    pub active: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Comments {
    fn type_name() -> &'static str {
        "Comments"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Comments {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Comments,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            text: text_,
            comment_id: comment_id_,
            updated_at: updated_at_,
            flagged: flagged_,
            created_at: created_at_,
            author: author_,
            parent_id: parent_id_,
            likes: likes_,
            metadata: metadata_,
            deleted: deleted_,
            active: active_,
        } = val;
        if text_.is_some() {
            obj.set("text", text_)?;
        }
        if comment_id_.is_some() {
            obj.set("commentId", comment_id_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if flagged_.is_some() {
            obj.set("flagged", flagged_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if author_.is_some() {
            obj.set("author", author_)?;
        }
        if parent_id_.is_some() {
            obj.set("parentId", parent_id_)?;
        }
        if likes_.is_some() {
            obj.set("likes", likes_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Comments {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let text_: Option<String> = obj.get("text")?;
        let comment_id_: Option<String> = obj.get("commentId")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let flagged_: Option<bool> = obj.get("flagged")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let author_: Option<Users> = obj.get("author")?;
        let parent_id_: Option<String> = obj.get("parentId")?;
        let likes_: Option<f64> = obj.get("likes")?;
        let metadata_: Option<Vec<Metadata>> = obj.get("metadata")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let active_: Option<bool> = obj.get("active")?;
        let val = Self {
            text: text_,
            comment_id: comment_id_,
            updated_at: updated_at_,
            flagged: flagged_,
            created_at: created_at_,
            author: author_,
            parent_id: parent_id_,
            likes: likes_,
            metadata: metadata_,
            deleted: deleted_,
            active: active_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Comments {}
pub struct Metadata {
    pub id: Option<String>,
    pub value: Option<String>,
    pub entity_type: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub key: Option<String>,
    pub r#type: Option<DataType>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub entity_id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Metadata {
    fn type_name() -> &'static str {
        "Metadata"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Metadata {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Metadata,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            id: id_,
            value: value_,
            entity_type: entity_type_,
            updated_at: updated_at_,
            key: key_,
            r#type: type_,
            created_at: created_at_,
            entity_id: entity_id_,
        } = val;
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if value_.is_some() {
            obj.set("value", value_)?;
        }
        if entity_type_.is_some() {
            obj.set("entityType", entity_type_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if key_.is_some() {
            obj.set("key", key_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if entity_id_.is_some() {
            obj.set("entityId", entity_id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Metadata {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let id_: Option<String> = obj.get("id")?;
        let value_: Option<String> = obj.get("value")?;
        let entity_type_: Option<String> = obj.get("entityType")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let key_: Option<String> = obj.get("key")?;
        let type_: Option<DataType> = obj.get("type")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let entity_id_: Option<String> = obj.get("entityId")?;
        let val = Self {
            id: id_,
            value: value_,
            entity_type: entity_type_,
            updated_at: updated_at_,
            key: key_,
            r#type: type_,
            created_at: created_at_,
            entity_id: entity_id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Metadata {}
pub struct Tasks {
    pub related_to_task_id: Option<Vec<String>>,
    pub modify_token: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<TaskStatus>,
    pub parent_task_id: Option<String>,
    pub repeat: Option<String>,
    pub notifications: Option<Vec<Notifications>>,
    pub time_estimate: Option<String>,
    pub title: Option<String>,
    pub labels: Option<Vec<String>>,
    pub id: Option<String>,
    pub depend_on_task_ids: Option<Vec<String>>,
    pub due_date: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub attachments: Option<Vec<Attachments>>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub watchers: Option<Vec<Users>>,
    pub time_logged: Option<String>,
    pub sub_task_ids: Option<Vec<String>>,
    pub assignee: Option<Users>,
    pub comments: Option<Vec<Comments>>,
    pub description: Option<String>,
    pub due_timezone: Option<String>,
    pub completion_percentage: Option<f64>,
    pub priority: Option<PriorityLevel>,
    pub created_by: Option<Users>,
}
impl napi::bindgen_prelude::TypeName for Tasks {
    fn type_name() -> &'static str {
        "Tasks"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Tasks {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Tasks,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            related_to_task_id: related_to_task_id_,
            modify_token: modify_token_,
            updated_at: updated_at_,
            status: status_,
            parent_task_id: parent_task_id_,
            repeat: repeat_,
            notifications: notifications_,
            time_estimate: time_estimate_,
            title: title_,
            labels: labels_,
            id: id_,
            depend_on_task_ids: depend_on_task_ids_,
            due_date: due_date_,
            created_at: created_at_,
            attachments: attachments_,
            custom_fields: custom_fields_,
            watchers: watchers_,
            time_logged: time_logged_,
            sub_task_ids: sub_task_ids_,
            assignee: assignee_,
            comments: comments_,
            description: description_,
            due_timezone: due_timezone_,
            completion_percentage: completion_percentage_,
            priority: priority_,
            created_by: created_by_,
        } = val;
        if related_to_task_id_.is_some() {
            obj.set("relatedToTaskId", related_to_task_id_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if parent_task_id_.is_some() {
            obj.set("parentTaskId", parent_task_id_)?;
        }
        if repeat_.is_some() {
            obj.set("repeat", repeat_)?;
        }
        if notifications_.is_some() {
            obj.set("notifications", notifications_)?;
        }
        if time_estimate_.is_some() {
            obj.set("timeEstimate", time_estimate_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if labels_.is_some() {
            obj.set("labels", labels_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if depend_on_task_ids_.is_some() {
            obj.set("dependOnTaskIds", depend_on_task_ids_)?;
        }
        if due_date_.is_some() {
            obj.set("dueDate", due_date_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if watchers_.is_some() {
            obj.set("watchers", watchers_)?;
        }
        if time_logged_.is_some() {
            obj.set("timeLogged", time_logged_)?;
        }
        if sub_task_ids_.is_some() {
            obj.set("subTaskIds", sub_task_ids_)?;
        }
        if assignee_.is_some() {
            obj.set("assignee", assignee_)?;
        }
        if comments_.is_some() {
            obj.set("comments", comments_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if due_timezone_.is_some() {
            obj.set("dueTimezone", due_timezone_)?;
        }
        if completion_percentage_.is_some() {
            obj.set("completionPercentage", completion_percentage_)?;
        }
        if priority_.is_some() {
            obj.set("priority", priority_)?;
        }
        if created_by_.is_some() {
            obj.set("createdBy", created_by_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Tasks {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let related_to_task_id_: Option<Vec<String>> = obj.get("relatedToTaskId")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let status_: Option<TaskStatus> = obj.get("status")?;
        let parent_task_id_: Option<String> = obj.get("parentTaskId")?;
        let repeat_: Option<String> = obj.get("repeat")?;
        let notifications_: Option<Vec<Notifications>> = obj.get("notifications")?;
        let time_estimate_: Option<String> = obj.get("timeEstimate")?;
        let title_: Option<String> = obj.get("title")?;
        let labels_: Option<Vec<String>> = obj.get("labels")?;
        let id_: Option<String> = obj.get("id")?;
        let depend_on_task_ids_: Option<Vec<String>> = obj.get("dependOnTaskIds")?;
        let due_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("dueDate")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let watchers_: Option<Vec<Users>> = obj.get("watchers")?;
        let time_logged_: Option<String> = obj.get("timeLogged")?;
        let sub_task_ids_: Option<Vec<String>> = obj.get("subTaskIds")?;
        let assignee_: Option<Users> = obj.get("assignee")?;
        let comments_: Option<Vec<Comments>> = obj.get("comments")?;
        let description_: Option<String> = obj.get("description")?;
        let due_timezone_: Option<String> = obj.get("dueTimezone")?;
        let completion_percentage_: Option<f64> = obj.get("completionPercentage")?;
        let priority_: Option<PriorityLevel> = obj.get("priority")?;
        let created_by_: Option<Users> = obj.get("createdBy")?;
        let val = Self {
            related_to_task_id: related_to_task_id_,
            modify_token: modify_token_,
            updated_at: updated_at_,
            status: status_,
            parent_task_id: parent_task_id_,
            repeat: repeat_,
            notifications: notifications_,
            time_estimate: time_estimate_,
            title: title_,
            labels: labels_,
            id: id_,
            depend_on_task_ids: depend_on_task_ids_,
            due_date: due_date_,
            created_at: created_at_,
            attachments: attachments_,
            custom_fields: custom_fields_,
            watchers: watchers_,
            time_logged: time_logged_,
            sub_task_ids: sub_task_ids_,
            assignee: assignee_,
            comments: comments_,
            description: description_,
            due_timezone: due_timezone_,
            completion_percentage: completion_percentage_,
            priority: priority_,
            created_by: created_by_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Tasks {}
pub struct Stores {
    pub features: Option<Vec<String>>,
    pub name: Option<String>,
    pub phone: Option<String>,
    pub currency: Option<Currency>,
    pub owner: Option<Users>,
    pub email: Option<String>,
    pub category: Option<String>,
    pub latitude: Option<f64>,
    pub country_code: Option<String>,
    pub language: Option<String>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub timezone: Option<String>,
    pub id: Option<String>,
    pub country: Option<String>,
    pub longitude: Option<f64>,
    pub website_url: Option<String>,
    pub address: Option<Addresses>,
    pub is_operating: Option<bool>,
    pub ratings: Option<RatingsReviews>,
    pub payment_methods: Option<Vec<String>>,
    pub logo_url: Option<String>,
    pub store_area: Option<f64>,
    pub description: Option<String>,
    pub business_hours: Option<Vec<BusinessHours>>,
    pub related_stores: Option<Vec<Stores>>,
    pub manager: Option<Staff>,
}
impl napi::bindgen_prelude::TypeName for Stores {
    fn type_name() -> &'static str {
        "Stores"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Stores {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Stores,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            features: features_,
            name: name_,
            phone: phone_,
            currency: currency_,
            owner: owner_,
            email: email_,
            category: category_,
            latitude: latitude_,
            country_code: country_code_,
            language: language_,
            social_profiles: social_profiles_,
            created_at: created_at_,
            updated_at: updated_at_,
            timezone: timezone_,
            id: id_,
            country: country_,
            longitude: longitude_,
            website_url: website_url_,
            address: address_,
            is_operating: is_operating_,
            ratings: ratings_,
            payment_methods: payment_methods_,
            logo_url: logo_url_,
            store_area: store_area_,
            description: description_,
            business_hours: business_hours_,
            related_stores: related_stores_,
            manager: manager_,
        } = val;
        if features_.is_some() {
            obj.set("features", features_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if phone_.is_some() {
            obj.set("phone", phone_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if owner_.is_some() {
            obj.set("owner", owner_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if category_.is_some() {
            obj.set("category", category_)?;
        }
        if latitude_.is_some() {
            obj.set("latitude", latitude_)?;
        }
        if country_code_.is_some() {
            obj.set("countryCode", country_code_)?;
        }
        if language_.is_some() {
            obj.set("language", language_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if timezone_.is_some() {
            obj.set("timezone", timezone_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if longitude_.is_some() {
            obj.set("longitude", longitude_)?;
        }
        if website_url_.is_some() {
            obj.set("websiteUrl", website_url_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if is_operating_.is_some() {
            obj.set("isOperating", is_operating_)?;
        }
        if ratings_.is_some() {
            obj.set("ratings", ratings_)?;
        }
        if payment_methods_.is_some() {
            obj.set("paymentMethods", payment_methods_)?;
        }
        if logo_url_.is_some() {
            obj.set("logoUrl", logo_url_)?;
        }
        if store_area_.is_some() {
            obj.set("storeArea", store_area_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if business_hours_.is_some() {
            obj.set("businessHours", business_hours_)?;
        }
        if related_stores_.is_some() {
            obj.set("relatedStores", related_stores_)?;
        }
        if manager_.is_some() {
            obj.set("manager", manager_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Stores {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let features_: Option<Vec<String>> = obj.get("features")?;
        let name_: Option<String> = obj.get("name")?;
        let phone_: Option<String> = obj.get("phone")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let owner_: Option<Users> = obj.get("owner")?;
        let email_: Option<String> = obj.get("email")?;
        let category_: Option<String> = obj.get("category")?;
        let latitude_: Option<f64> = obj.get("latitude")?;
        let country_code_: Option<String> = obj.get("countryCode")?;
        let language_: Option<String> = obj.get("language")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let timezone_: Option<String> = obj.get("timezone")?;
        let id_: Option<String> = obj.get("id")?;
        let country_: Option<String> = obj.get("country")?;
        let longitude_: Option<f64> = obj.get("longitude")?;
        let website_url_: Option<String> = obj.get("websiteUrl")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let is_operating_: Option<bool> = obj.get("isOperating")?;
        let ratings_: Option<RatingsReviews> = obj.get("ratings")?;
        let payment_methods_: Option<Vec<String>> = obj.get("paymentMethods")?;
        let logo_url_: Option<String> = obj.get("logoUrl")?;
        let store_area_: Option<f64> = obj.get("storeArea")?;
        let description_: Option<String> = obj.get("description")?;
        let business_hours_: Option<Vec<BusinessHours>> = obj.get("businessHours")?;
        let related_stores_: Option<Vec<Stores>> = obj.get("relatedStores")?;
        let manager_: Option<Staff> = obj.get("manager")?;
        let val = Self {
            features: features_,
            name: name_,
            phone: phone_,
            currency: currency_,
            owner: owner_,
            email: email_,
            category: category_,
            latitude: latitude_,
            country_code: country_code_,
            language: language_,
            social_profiles: social_profiles_,
            created_at: created_at_,
            updated_at: updated_at_,
            timezone: timezone_,
            id: id_,
            country: country_,
            longitude: longitude_,
            website_url: website_url_,
            address: address_,
            is_operating: is_operating_,
            ratings: ratings_,
            payment_methods: payment_methods_,
            logo_url: logo_url_,
            store_area: store_area_,
            description: description_,
            business_hours: business_hours_,
            related_stores: related_stores_,
            manager: manager_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Stores {}
pub struct Staff {
    pub role: Option<OrganizationalRole>,
    pub position: Option<String>,
    pub phone: Option<String>,
    pub deleted: Option<bool>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub store_i_d: Option<String>,
    pub id: Option<String>,
    pub first_name: Option<String>,
    pub gender: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<EmploymentAndCandidateStatus>,
    pub photo_url: Option<String>,
    pub date_of_birth: Option<chrono::DateTime<chrono::Utc>>,
    pub addresses: Option<Addresses>,
    pub email: Option<String>,
    pub last_name: Option<String>,
    pub active: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Staff {
    fn type_name() -> &'static str {
        "Staff"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Staff {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Staff,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            role: role_,
            position: position_,
            phone: phone_,
            deleted: deleted_,
            updated_at: updated_at_,
            custom_fields: custom_fields_,
            store_i_d: store_i_d_,
            id: id_,
            first_name: first_name_,
            gender: gender_,
            created_at: created_at_,
            status: status_,
            photo_url: photo_url_,
            date_of_birth: date_of_birth_,
            addresses: addresses_,
            email: email_,
            last_name: last_name_,
            active: active_,
        } = val;
        if role_.is_some() {
            obj.set("role", role_)?;
        }
        if position_.is_some() {
            obj.set("position", position_)?;
        }
        if phone_.is_some() {
            obj.set("phone", phone_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if store_i_d_.is_some() {
            obj.set("storeID", store_i_d_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if gender_.is_some() {
            obj.set("gender", gender_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if photo_url_.is_some() {
            obj.set("photoUrl", photo_url_)?;
        }
        if date_of_birth_.is_some() {
            obj.set("dateOfBirth", date_of_birth_)?;
        }
        if addresses_.is_some() {
            obj.set("addresses", addresses_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Staff {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let role_: Option<OrganizationalRole> = obj.get("role")?;
        let position_: Option<String> = obj.get("position")?;
        let phone_: Option<String> = obj.get("phone")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let store_i_d_: Option<String> = obj.get("storeID")?;
        let id_: Option<String> = obj.get("id")?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let gender_: Option<String> = obj.get("gender")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let status_: Option<EmploymentAndCandidateStatus> = obj.get("status")?;
        let photo_url_: Option<String> = obj.get("photoUrl")?;
        let date_of_birth_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("dateOfBirth")?;
        let addresses_: Option<Addresses> = obj.get("addresses")?;
        let email_: Option<String> = obj.get("email")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let active_: Option<bool> = obj.get("active")?;
        let val = Self {
            role: role_,
            position: position_,
            phone: phone_,
            deleted: deleted_,
            updated_at: updated_at_,
            custom_fields: custom_fields_,
            store_i_d: store_i_d_,
            id: id_,
            first_name: first_name_,
            gender: gender_,
            created_at: created_at_,
            status: status_,
            photo_url: photo_url_,
            date_of_birth: date_of_birth_,
            addresses: addresses_,
            email: email_,
            last_name: last_name_,
            active: active_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Staff {}
pub struct RatingsReviews {
    pub verified_purchase: Option<bool>,
    pub active: Option<bool>,
    pub deleted: Option<bool>,
    pub id: Option<String>,
    pub status: Option<ReviewApprovalStatus>,
    pub store_i_d: Option<String>,
    pub rating: Option<f64>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub locale: Option<String>,
    pub review: Option<String>,
    pub reviewer_name: Option<String>,
    pub metadata: Option<Metadata>,
}
impl napi::bindgen_prelude::TypeName for RatingsReviews {
    fn type_name() -> &'static str {
        "RatingsReviews"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for RatingsReviews {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: RatingsReviews,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            verified_purchase: verified_purchase_,
            active: active_,
            deleted: deleted_,
            id: id_,
            status: status_,
            store_i_d: store_i_d_,
            rating: rating_,
            updated_at: updated_at_,
            created_at: created_at_,
            locale: locale_,
            review: review_,
            reviewer_name: reviewer_name_,
            metadata: metadata_,
        } = val;
        if verified_purchase_.is_some() {
            obj.set("verifiedPurchase", verified_purchase_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if store_i_d_.is_some() {
            obj.set("storeID", store_i_d_)?;
        }
        if rating_.is_some() {
            obj.set("rating", rating_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if locale_.is_some() {
            obj.set("locale", locale_)?;
        }
        if review_.is_some() {
            obj.set("review", review_)?;
        }
        if reviewer_name_.is_some() {
            obj.set("reviewerName", reviewer_name_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for RatingsReviews {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let verified_purchase_: Option<bool> = obj.get("verifiedPurchase")?;
        let active_: Option<bool> = obj.get("active")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let id_: Option<String> = obj.get("id")?;
        let status_: Option<ReviewApprovalStatus> = obj.get("status")?;
        let store_i_d_: Option<String> = obj.get("storeID")?;
        let rating_: Option<f64> = obj.get("rating")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let locale_: Option<String> = obj.get("locale")?;
        let review_: Option<String> = obj.get("review")?;
        let reviewer_name_: Option<String> = obj.get("reviewerName")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let val = Self {
            verified_purchase: verified_purchase_,
            active: active_,
            deleted: deleted_,
            id: id_,
            status: status_,
            store_i_d: store_i_d_,
            rating: rating_,
            updated_at: updated_at_,
            created_at: created_at_,
            locale: locale_,
            review: review_,
            reviewer_name: reviewer_name_,
            metadata: metadata_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for RatingsReviews {}
pub struct ProductOptions {
    pub values: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub product_id: Option<f64>,
    pub id: Option<String>,
    pub name: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for ProductOptions {
    fn type_name() -> &'static str {
        "ProductOptions"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for ProductOptions {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: ProductOptions,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            values: values_,
            updated_at: updated_at_,
            product_id: product_id_,
            id: id_,
            name: name_,
            created_at: created_at_,
        } = val;
        if values_.is_some() {
            obj.set("values", values_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if product_id_.is_some() {
            obj.set("productId", product_id_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for ProductOptions {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let values_: Option<Vec<String>> = obj.get("values")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let product_id_: Option<f64> = obj.get("productId")?;
        let id_: Option<String> = obj.get("id")?;
        let name_: Option<String> = obj.get("name")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let val = Self {
            values: values_,
            updated_at: updated_at_,
            product_id: product_id_,
            id: id_,
            name: name_,
            created_at: created_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ProductOptions {}
pub struct Taxes {
    pub description: Option<String>,
    pub currency: Option<Currency>,
    pub tax_rate: Option<f64>,
    pub active: Option<bool>,
    pub tax_amount: Option<f64>,
    pub taxable: Option<bool>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub tax_details: Option<TaxDetails>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub region: Option<String>,
    pub country: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub tax_code: Option<String>,
    pub deleted: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Taxes {
    fn type_name() -> &'static str {
        "Taxes"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Taxes {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Taxes,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            description: description_,
            currency: currency_,
            tax_rate: tax_rate_,
            active: active_,
            tax_amount: tax_amount_,
            taxable: taxable_,
            custom_fields: custom_fields_,
            tax_details: tax_details_,
            created_at: created_at_,
            region: region_,
            country: country_,
            updated_at: updated_at_,
            tax_code: tax_code_,
            deleted: deleted_,
        } = val;
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if tax_rate_.is_some() {
            obj.set("taxRate", tax_rate_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if tax_amount_.is_some() {
            obj.set("taxAmount", tax_amount_)?;
        }
        if taxable_.is_some() {
            obj.set("taxable", taxable_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if tax_details_.is_some() {
            obj.set("taxDetails", tax_details_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if region_.is_some() {
            obj.set("region", region_)?;
        }
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if tax_code_.is_some() {
            obj.set("taxCode", tax_code_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Taxes {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let description_: Option<String> = obj.get("description")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let tax_rate_: Option<f64> = obj.get("taxRate")?;
        let active_: Option<bool> = obj.get("active")?;
        let tax_amount_: Option<f64> = obj.get("taxAmount")?;
        let taxable_: Option<bool> = obj.get("taxable")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let tax_details_: Option<TaxDetails> = obj.get("taxDetails")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let region_: Option<String> = obj.get("region")?;
        let country_: Option<String> = obj.get("country")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let tax_code_: Option<String> = obj.get("taxCode")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let val = Self {
            description: description_,
            currency: currency_,
            tax_rate: tax_rate_,
            active: active_,
            tax_amount: tax_amount_,
            taxable: taxable_,
            custom_fields: custom_fields_,
            tax_details: tax_details_,
            created_at: created_at_,
            region: region_,
            country: country_,
            updated_at: updated_at_,
            tax_code: tax_code_,
            deleted: deleted_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Taxes {}
pub struct InventoryLocations {
    pub address: Option<Addresses>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub is_active: Option<bool>,
    pub r#type: Option<InventoryStorageType>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub operational_hours: Option<String>,
    pub location_id: Option<String>,
    pub contact_information: Option<Vec<Contacts>>,
    pub name: Option<String>,
    pub quantity: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for InventoryLocations {
    fn type_name() -> &'static str {
        "InventoryLocations"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for InventoryLocations {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: InventoryLocations,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            address: address_,
            updated_at: updated_at_,
            is_active: is_active_,
            r#type: type_,
            created_at: created_at_,
            deleted: deleted_,
            operational_hours: operational_hours_,
            location_id: location_id_,
            contact_information: contact_information_,
            name: name_,
            quantity: quantity_,
        } = val;
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if is_active_.is_some() {
            obj.set("isActive", is_active_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if operational_hours_.is_some() {
            obj.set("operationalHours", operational_hours_)?;
        }
        if location_id_.is_some() {
            obj.set("locationId", location_id_)?;
        }
        if contact_information_.is_some() {
            obj.set("contactInformation", contact_information_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for InventoryLocations {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let address_: Option<Addresses> = obj.get("address")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let is_active_: Option<bool> = obj.get("isActive")?;
        let type_: Option<InventoryStorageType> = obj.get("type")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let operational_hours_: Option<String> = obj.get("operationalHours")?;
        let location_id_: Option<String> = obj.get("locationId")?;
        let contact_information_: Option<Vec<Contacts>> = obj.get("contactInformation")?;
        let name_: Option<String> = obj.get("name")?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let val = Self {
            address: address_,
            updated_at: updated_at_,
            is_active: is_active_,
            r#type: type_,
            created_at: created_at_,
            deleted: deleted_,
            operational_hours: operational_hours_,
            location_id: location_id_,
            contact_information: contact_information_,
            name: name_,
            quantity: quantity_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for InventoryLocations {}
pub struct Prices {
    pub currency: Option<Currency>,
    pub amount: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for Prices {
    fn type_name() -> &'static str {
        "Prices"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Prices {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Prices,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { currency: currency_, amount: amount_ } = val;
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Prices {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let val = Self {
            currency: currency_,
            amount: amount_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Prices {}
pub struct Variants {
    pub status: Option<ItemAvailabilityStatus>,
    pub sku: Option<String>,
    pub image_id: Option<f64>,
    pub deleted: Option<bool>,
    pub dimensions: Option<Dimensions>,
    pub inventory_quantity: Option<f64>,
    pub active: Option<bool>,
    pub id: Option<String>,
    pub compare_at_price: Option<f64>,
    pub taxable: Option<bool>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub price: Option<f64>,
    pub weight: Option<f64>,
    pub title: Option<String>,
    pub barcode: Option<String>,
    pub product_id: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub weight_unit: Option<String>,
    pub requires_shipping: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for Variants {
    fn type_name() -> &'static str {
        "Variants"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Variants {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Variants,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            status: status_,
            sku: sku_,
            image_id: image_id_,
            deleted: deleted_,
            dimensions: dimensions_,
            inventory_quantity: inventory_quantity_,
            active: active_,
            id: id_,
            compare_at_price: compare_at_price_,
            taxable: taxable_,
            created_at: created_at_,
            price: price_,
            weight: weight_,
            title: title_,
            barcode: barcode_,
            product_id: product_id_,
            updated_at: updated_at_,
            weight_unit: weight_unit_,
            requires_shipping: requires_shipping_,
        } = val;
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if sku_.is_some() {
            obj.set("sku", sku_)?;
        }
        if image_id_.is_some() {
            obj.set("imageId", image_id_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if dimensions_.is_some() {
            obj.set("dimensions", dimensions_)?;
        }
        if inventory_quantity_.is_some() {
            obj.set("inventoryQuantity", inventory_quantity_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if compare_at_price_.is_some() {
            obj.set("compareAtPrice", compare_at_price_)?;
        }
        if taxable_.is_some() {
            obj.set("taxable", taxable_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if price_.is_some() {
            obj.set("price", price_)?;
        }
        if weight_.is_some() {
            obj.set("weight", weight_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if barcode_.is_some() {
            obj.set("barcode", barcode_)?;
        }
        if product_id_.is_some() {
            obj.set("productId", product_id_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if weight_unit_.is_some() {
            obj.set("weightUnit", weight_unit_)?;
        }
        if requires_shipping_.is_some() {
            obj.set("requiresShipping", requires_shipping_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Variants {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let status_: Option<ItemAvailabilityStatus> = obj.get("status")?;
        let sku_: Option<String> = obj.get("sku")?;
        let image_id_: Option<f64> = obj.get("imageId")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let dimensions_: Option<Dimensions> = obj.get("dimensions")?;
        let inventory_quantity_: Option<f64> = obj.get("inventoryQuantity")?;
        let active_: Option<bool> = obj.get("active")?;
        let id_: Option<String> = obj.get("id")?;
        let compare_at_price_: Option<f64> = obj.get("compareAtPrice")?;
        let taxable_: Option<bool> = obj.get("taxable")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let price_: Option<f64> = obj.get("price")?;
        let weight_: Option<f64> = obj.get("weight")?;
        let title_: Option<String> = obj.get("title")?;
        let barcode_: Option<String> = obj.get("barcode")?;
        let product_id_: Option<String> = obj.get("productId")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let weight_unit_: Option<String> = obj.get("weightUnit")?;
        let requires_shipping_: Option<bool> = obj.get("requiresShipping")?;
        let val = Self {
            status: status_,
            sku: sku_,
            image_id: image_id_,
            deleted: deleted_,
            dimensions: dimensions_,
            inventory_quantity: inventory_quantity_,
            active: active_,
            id: id_,
            compare_at_price: compare_at_price_,
            taxable: taxable_,
            created_at: created_at_,
            price: price_,
            weight: weight_,
            title: title_,
            barcode: barcode_,
            product_id: product_id_,
            updated_at: updated_at_,
            weight_unit: weight_unit_,
            requires_shipping: requires_shipping_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Variants {}
pub struct Dimensions {
    pub height: Option<f64>,
    pub width: Option<f64>,
    pub length: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for Dimensions {
    fn type_name() -> &'static str {
        "Dimensions"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Dimensions {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Dimensions,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { height: height_, width: width_, length: length_ } = val;
        if height_.is_some() {
            obj.set("height", height_)?;
        }
        if width_.is_some() {
            obj.set("width", width_)?;
        }
        if length_.is_some() {
            obj.set("length", length_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Dimensions {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let height_: Option<f64> = obj.get("height")?;
        let width_: Option<f64> = obj.get("width")?;
        let length_: Option<f64> = obj.get("length")?;
        let val = Self {
            height: height_,
            width: width_,
            length: length_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Dimensions {}
pub struct Products {
    pub description: Option<String>,
    pub id: Option<String>,
    pub images: Option<Vec<Images>>,
    pub options: Option<Vec<ProductOptions>>,
    pub weight: Option<f64>,
    pub inventory_quantity: Option<f64>,
    pub slug: Option<String>,
    pub is_downloadable: Option<bool>,
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    pub meta_title: Option<String>,
    pub status: Option<EntityLifecycleStatus>,
    pub tax: Option<Taxes>,
    pub brand: Option<Brands>,
    pub title: Option<String>,
    pub related_products: Option<Vec<String>>,
    pub r#type: Option<String>,
    pub seo_keywords: Option<Vec<String>>,
    pub download_files: Option<Vec<Attachments>>,
    pub dimensions: Option<Dimensions>,
    pub meta_description: Option<String>,
    pub localizations: Option<Vec<Localizations>>,
    pub tags: Option<Vec<String>>,
    pub available_for_sale: Option<bool>,
    pub sku_validation: Option<SkuValidation>,
    pub vendor: Option<String>,
    pub categories: Option<Vec<String>>,
    pub modify_token: Option<String>,
    pub inventory_location: Option<InventoryLocations>,
    pub prices: Option<Vec<Prices>>,
    pub sku: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub weight_unit: Option<String>,
    pub account_ids: Option<Vec<KeyValues>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub variants: Option<Vec<Variants>>,
}
impl napi::bindgen_prelude::TypeName for Products {
    fn type_name() -> &'static str {
        "Products"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Products {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Products,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            description: description_,
            id: id_,
            images: images_,
            options: options_,
            weight: weight_,
            inventory_quantity: inventory_quantity_,
            slug: slug_,
            is_downloadable: is_downloadable_,
            published_at: published_at_,
            meta_title: meta_title_,
            status: status_,
            tax: tax_,
            brand: brand_,
            title: title_,
            related_products: related_products_,
            r#type: type_,
            seo_keywords: seo_keywords_,
            download_files: download_files_,
            dimensions: dimensions_,
            meta_description: meta_description_,
            localizations: localizations_,
            tags: tags_,
            available_for_sale: available_for_sale_,
            sku_validation: sku_validation_,
            vendor: vendor_,
            categories: categories_,
            modify_token: modify_token_,
            inventory_location: inventory_location_,
            prices: prices_,
            sku: sku_,
            custom_fields: custom_fields_,
            created_at: created_at_,
            weight_unit: weight_unit_,
            account_ids: account_ids_,
            updated_at: updated_at_,
            variants: variants_,
        } = val;
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if images_.is_some() {
            obj.set("images", images_)?;
        }
        if options_.is_some() {
            obj.set("options", options_)?;
        }
        if weight_.is_some() {
            obj.set("weight", weight_)?;
        }
        if inventory_quantity_.is_some() {
            obj.set("inventoryQuantity", inventory_quantity_)?;
        }
        if slug_.is_some() {
            obj.set("slug", slug_)?;
        }
        if is_downloadable_.is_some() {
            obj.set("isDownloadable", is_downloadable_)?;
        }
        if published_at_.is_some() {
            obj.set("publishedAt", published_at_)?;
        }
        if meta_title_.is_some() {
            obj.set("metaTitle", meta_title_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if tax_.is_some() {
            obj.set("tax", tax_)?;
        }
        if brand_.is_some() {
            obj.set("brand", brand_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if related_products_.is_some() {
            obj.set("relatedProducts", related_products_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if seo_keywords_.is_some() {
            obj.set("seoKeywords", seo_keywords_)?;
        }
        if download_files_.is_some() {
            obj.set("downloadFiles", download_files_)?;
        }
        if dimensions_.is_some() {
            obj.set("dimensions", dimensions_)?;
        }
        if meta_description_.is_some() {
            obj.set("metaDescription", meta_description_)?;
        }
        if localizations_.is_some() {
            obj.set("localizations", localizations_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if available_for_sale_.is_some() {
            obj.set("availableForSale", available_for_sale_)?;
        }
        if sku_validation_.is_some() {
            obj.set("skuValidation", sku_validation_)?;
        }
        if vendor_.is_some() {
            obj.set("vendor", vendor_)?;
        }
        if categories_.is_some() {
            obj.set("categories", categories_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if inventory_location_.is_some() {
            obj.set("inventoryLocation", inventory_location_)?;
        }
        if prices_.is_some() {
            obj.set("prices", prices_)?;
        }
        if sku_.is_some() {
            obj.set("sku", sku_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if weight_unit_.is_some() {
            obj.set("weightUnit", weight_unit_)?;
        }
        if account_ids_.is_some() {
            obj.set("accountIds", account_ids_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if variants_.is_some() {
            obj.set("variants", variants_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Products {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let description_: Option<String> = obj.get("description")?;
        let id_: Option<String> = obj.get("id")?;
        let images_: Option<Vec<Images>> = obj.get("images")?;
        let options_: Option<Vec<ProductOptions>> = obj.get("options")?;
        let weight_: Option<f64> = obj.get("weight")?;
        let inventory_quantity_: Option<f64> = obj.get("inventoryQuantity")?;
        let slug_: Option<String> = obj.get("slug")?;
        let is_downloadable_: Option<bool> = obj.get("isDownloadable")?;
        let published_at_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("publishedAt")?;
        let meta_title_: Option<String> = obj.get("metaTitle")?;
        let status_: Option<EntityLifecycleStatus> = obj.get("status")?;
        let tax_: Option<Taxes> = obj.get("tax")?;
        let brand_: Option<Brands> = obj.get("brand")?;
        let title_: Option<String> = obj.get("title")?;
        let related_products_: Option<Vec<String>> = obj.get("relatedProducts")?;
        let type_: Option<String> = obj.get("type")?;
        let seo_keywords_: Option<Vec<String>> = obj.get("seoKeywords")?;
        let download_files_: Option<Vec<Attachments>> = obj.get("downloadFiles")?;
        let dimensions_: Option<Dimensions> = obj.get("dimensions")?;
        let meta_description_: Option<String> = obj.get("metaDescription")?;
        let localizations_: Option<Vec<Localizations>> = obj.get("localizations")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let available_for_sale_: Option<bool> = obj.get("availableForSale")?;
        let sku_validation_: Option<SkuValidation> = obj.get("skuValidation")?;
        let vendor_: Option<String> = obj.get("vendor")?;
        let categories_: Option<Vec<String>> = obj.get("categories")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let inventory_location_: Option<InventoryLocations> = obj
            .get("inventoryLocation")?;
        let prices_: Option<Vec<Prices>> = obj.get("prices")?;
        let sku_: Option<String> = obj.get("sku")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let weight_unit_: Option<String> = obj.get("weightUnit")?;
        let account_ids_: Option<Vec<KeyValues>> = obj.get("accountIds")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let variants_: Option<Vec<Variants>> = obj.get("variants")?;
        let val = Self {
            description: description_,
            id: id_,
            images: images_,
            options: options_,
            weight: weight_,
            inventory_quantity: inventory_quantity_,
            slug: slug_,
            is_downloadable: is_downloadable_,
            published_at: published_at_,
            meta_title: meta_title_,
            status: status_,
            tax: tax_,
            brand: brand_,
            title: title_,
            related_products: related_products_,
            r#type: type_,
            seo_keywords: seo_keywords_,
            download_files: download_files_,
            dimensions: dimensions_,
            meta_description: meta_description_,
            localizations: localizations_,
            tags: tags_,
            available_for_sale: available_for_sale_,
            sku_validation: sku_validation_,
            vendor: vendor_,
            categories: categories_,
            modify_token: modify_token_,
            inventory_location: inventory_location_,
            prices: prices_,
            sku: sku_,
            custom_fields: custom_fields_,
            created_at: created_at_,
            weight_unit: weight_unit_,
            account_ids: account_ids_,
            updated_at: updated_at_,
            variants: variants_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Products {}
pub struct Orders {
    pub payment_methods: Option<Vec<String>>,
    pub tax: Option<f64>,
    pub currency: Option<Currency>,
    pub order_number: Option<String>,
    pub sub_total: Option<f64>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<OrderStatus>,
    pub payment_status: Option<PaymentStatus>,
    pub shipping_address: Option<Addresses>,
    pub billing_address: Option<Addresses>,
    pub items: Option<Vec<Items>>,
    pub tags: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub discounts: Option<Vec<f64>>,
    pub modify_token: Option<String>,
    pub note: Option<String>,
    pub total: Option<f64>,
    pub shipping_cost: Option<f64>,
    pub tracking_info: Option<String>,
    pub id: Option<String>,
    pub customer_i_d: Option<String>,
    pub shipping_method: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Orders {
    fn type_name() -> &'static str {
        "Orders"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Orders {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Orders,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            payment_methods: payment_methods_,
            tax: tax_,
            currency: currency_,
            order_number: order_number_,
            sub_total: sub_total_,
            created_at: created_at_,
            status: status_,
            payment_status: payment_status_,
            shipping_address: shipping_address_,
            billing_address: billing_address_,
            items: items_,
            tags: tags_,
            updated_at: updated_at_,
            discounts: discounts_,
            modify_token: modify_token_,
            note: note_,
            total: total_,
            shipping_cost: shipping_cost_,
            tracking_info: tracking_info_,
            id: id_,
            customer_i_d: customer_i_d_,
            shipping_method: shipping_method_,
        } = val;
        if payment_methods_.is_some() {
            obj.set("paymentMethods", payment_methods_)?;
        }
        if tax_.is_some() {
            obj.set("tax", tax_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if order_number_.is_some() {
            obj.set("orderNumber", order_number_)?;
        }
        if sub_total_.is_some() {
            obj.set("subTotal", sub_total_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if payment_status_.is_some() {
            obj.set("paymentStatus", payment_status_)?;
        }
        if shipping_address_.is_some() {
            obj.set("shippingAddress", shipping_address_)?;
        }
        if billing_address_.is_some() {
            obj.set("billingAddress", billing_address_)?;
        }
        if items_.is_some() {
            obj.set("items", items_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if discounts_.is_some() {
            obj.set("discounts", discounts_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if note_.is_some() {
            obj.set("note", note_)?;
        }
        if total_.is_some() {
            obj.set("total", total_)?;
        }
        if shipping_cost_.is_some() {
            obj.set("shippingCost", shipping_cost_)?;
        }
        if tracking_info_.is_some() {
            obj.set("trackingInfo", tracking_info_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if customer_i_d_.is_some() {
            obj.set("customerID", customer_i_d_)?;
        }
        if shipping_method_.is_some() {
            obj.set("shippingMethod", shipping_method_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Orders {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let payment_methods_: Option<Vec<String>> = obj.get("paymentMethods")?;
        let tax_: Option<f64> = obj.get("tax")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let order_number_: Option<String> = obj.get("orderNumber")?;
        let sub_total_: Option<f64> = obj.get("subTotal")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let status_: Option<OrderStatus> = obj.get("status")?;
        let payment_status_: Option<PaymentStatus> = obj.get("paymentStatus")?;
        let shipping_address_: Option<Addresses> = obj.get("shippingAddress")?;
        let billing_address_: Option<Addresses> = obj.get("billingAddress")?;
        let items_: Option<Vec<Items>> = obj.get("items")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let discounts_: Option<Vec<f64>> = obj.get("discounts")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let note_: Option<String> = obj.get("note")?;
        let total_: Option<f64> = obj.get("total")?;
        let shipping_cost_: Option<f64> = obj.get("shippingCost")?;
        let tracking_info_: Option<String> = obj.get("trackingInfo")?;
        let id_: Option<String> = obj.get("id")?;
        let customer_i_d_: Option<String> = obj.get("customerID")?;
        let shipping_method_: Option<String> = obj.get("shippingMethod")?;
        let val = Self {
            payment_methods: payment_methods_,
            tax: tax_,
            currency: currency_,
            order_number: order_number_,
            sub_total: sub_total_,
            created_at: created_at_,
            status: status_,
            payment_status: payment_status_,
            shipping_address: shipping_address_,
            billing_address: billing_address_,
            items: items_,
            tags: tags_,
            updated_at: updated_at_,
            discounts: discounts_,
            modify_token: modify_token_,
            note: note_,
            total: total_,
            shipping_cost: shipping_cost_,
            tracking_info: tracking_info_,
            id: id_,
            customer_i_d: customer_i_d_,
            shipping_method: shipping_method_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Orders {}
pub struct Opportunities {
    pub amount: Option<f64>,
    pub is_closed: Option<bool>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub lost_reason: Option<String>,
    pub close_date: Option<chrono::DateTime<chrono::Utc>>,
    pub next_step: Option<String>,
    pub title: Option<String>,
    pub campaign: Option<Campaigns>,
    pub entity: Option<Entity>,
    pub r#type: Option<String>,
    pub company_id: Option<String>,
    pub modify_token: Option<String>,
    pub currency: Option<Currency>,
    pub description: Option<String>,
    pub lead_id: Option<String>,
    pub stage: Option<String>,
    pub attachments: Option<Vec<Attachments>>,
    pub probability: Option<f64>,
    pub is_won: Option<bool>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub account: Option<Accounts>,
    pub notes: Option<Vec<String>>,
    pub lead_source: Option<String>,
    pub owner: Option<Users>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub id: Option<String>,
    pub contacts: Option<Vec<Contacts>>,
}
impl napi::bindgen_prelude::TypeName for Opportunities {
    fn type_name() -> &'static str {
        "Opportunities"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Opportunities {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Opportunities,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            amount: amount_,
            is_closed: is_closed_,
            updated_at: updated_at_,
            lost_reason: lost_reason_,
            close_date: close_date_,
            next_step: next_step_,
            title: title_,
            campaign: campaign_,
            entity: entity_,
            r#type: type_,
            company_id: company_id_,
            modify_token: modify_token_,
            currency: currency_,
            description: description_,
            lead_id: lead_id_,
            stage: stage_,
            attachments: attachments_,
            probability: probability_,
            is_won: is_won_,
            created_at: created_at_,
            account: account_,
            notes: notes_,
            lead_source: lead_source_,
            owner: owner_,
            custom_fields: custom_fields_,
            id: id_,
            contacts: contacts_,
        } = val;
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if is_closed_.is_some() {
            obj.set("isClosed", is_closed_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if lost_reason_.is_some() {
            obj.set("lostReason", lost_reason_)?;
        }
        if close_date_.is_some() {
            obj.set("closeDate", close_date_)?;
        }
        if next_step_.is_some() {
            obj.set("nextStep", next_step_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if campaign_.is_some() {
            obj.set("campaign", campaign_)?;
        }
        if entity_.is_some() {
            obj.set("entity", entity_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if company_id_.is_some() {
            obj.set("companyId", company_id_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if lead_id_.is_some() {
            obj.set("leadId", lead_id_)?;
        }
        if stage_.is_some() {
            obj.set("stage", stage_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if probability_.is_some() {
            obj.set("probability", probability_)?;
        }
        if is_won_.is_some() {
            obj.set("isWon", is_won_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if account_.is_some() {
            obj.set("account", account_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if lead_source_.is_some() {
            obj.set("leadSource", lead_source_)?;
        }
        if owner_.is_some() {
            obj.set("owner", owner_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if contacts_.is_some() {
            obj.set("contacts", contacts_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Opportunities {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let amount_: Option<f64> = obj.get("amount")?;
        let is_closed_: Option<bool> = obj.get("isClosed")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let lost_reason_: Option<String> = obj.get("lostReason")?;
        let close_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("closeDate")?;
        let next_step_: Option<String> = obj.get("nextStep")?;
        let title_: Option<String> = obj.get("title")?;
        let campaign_: Option<Campaigns> = obj.get("campaign")?;
        let entity_: Option<Entity> = obj.get("entity")?;
        let type_: Option<String> = obj.get("type")?;
        let company_id_: Option<String> = obj.get("companyId")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let description_: Option<String> = obj.get("description")?;
        let lead_id_: Option<String> = obj.get("leadId")?;
        let stage_: Option<String> = obj.get("stage")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let probability_: Option<f64> = obj.get("probability")?;
        let is_won_: Option<bool> = obj.get("isWon")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let account_: Option<Accounts> = obj.get("account")?;
        let notes_: Option<Vec<String>> = obj.get("notes")?;
        let lead_source_: Option<String> = obj.get("leadSource")?;
        let owner_: Option<Users> = obj.get("owner")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let id_: Option<String> = obj.get("id")?;
        let contacts_: Option<Vec<Contacts>> = obj.get("contacts")?;
        let val = Self {
            amount: amount_,
            is_closed: is_closed_,
            updated_at: updated_at_,
            lost_reason: lost_reason_,
            close_date: close_date_,
            next_step: next_step_,
            title: title_,
            campaign: campaign_,
            entity: entity_,
            r#type: type_,
            company_id: company_id_,
            modify_token: modify_token_,
            currency: currency_,
            description: description_,
            lead_id: lead_id_,
            stage: stage_,
            attachments: attachments_,
            probability: probability_,
            is_won: is_won_,
            created_at: created_at_,
            account: account_,
            notes: notes_,
            lead_source: lead_source_,
            owner: owner_,
            custom_fields: custom_fields_,
            id: id_,
            contacts: contacts_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Opportunities {}
pub struct PaymentMethods {
    pub details: Option<String>,
    pub is_default: Option<bool>,
    pub r#type: Option<PaymentMethod>,
    pub id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for PaymentMethods {
    fn type_name() -> &'static str {
        "PaymentMethods"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for PaymentMethods {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: PaymentMethods,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            details: details_,
            is_default: is_default_,
            r#type: type_,
            id: id_,
        } = val;
        if details_.is_some() {
            obj.set("details", details_)?;
        }
        if is_default_.is_some() {
            obj.set("isDefault", is_default_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for PaymentMethods {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let details_: Option<String> = obj.get("details")?;
        let is_default_: Option<bool> = obj.get("isDefault")?;
        let type_: Option<PaymentMethod> = obj.get("type")?;
        let id_: Option<String> = obj.get("id")?;
        let val = Self {
            details: details_,
            is_default: is_default_,
            r#type: type_,
            id: id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PaymentMethods {}
pub struct SSO {
    pub provider_user_id: Option<String>,
    pub token_type: Option<String>,
    pub profile_url: Option<String>,
    pub provider: Option<IdentityProvider>,
    pub expiry_date: Option<chrono::DateTime<chrono::Utc>>,
    pub scopes: Option<Vec<String>>,
    pub expires_in: Option<f64>,
    pub refresh_token: Option<String>,
    pub deleted: Option<bool>,
    pub active: Option<bool>,
    pub access_token: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for SSO {
    fn type_name() -> &'static str {
        "SSO"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for SSO {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: SSO,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            provider_user_id: provider_user_id_,
            token_type: token_type_,
            profile_url: profile_url_,
            provider: provider_,
            expiry_date: expiry_date_,
            scopes: scopes_,
            expires_in: expires_in_,
            refresh_token: refresh_token_,
            deleted: deleted_,
            active: active_,
            access_token: access_token_,
            created_at: created_at_,
            updated_at: updated_at_,
        } = val;
        if provider_user_id_.is_some() {
            obj.set("providerUserId", provider_user_id_)?;
        }
        if token_type_.is_some() {
            obj.set("tokenType", token_type_)?;
        }
        if profile_url_.is_some() {
            obj.set("profileUrl", profile_url_)?;
        }
        if provider_.is_some() {
            obj.set("provider", provider_)?;
        }
        if expiry_date_.is_some() {
            obj.set("expiryDate", expiry_date_)?;
        }
        if scopes_.is_some() {
            obj.set("scopes", scopes_)?;
        }
        if expires_in_.is_some() {
            obj.set("expiresIn", expires_in_)?;
        }
        if refresh_token_.is_some() {
            obj.set("refreshToken", refresh_token_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if access_token_.is_some() {
            obj.set("accessToken", access_token_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for SSO {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let provider_user_id_: Option<String> = obj.get("providerUserId")?;
        let token_type_: Option<String> = obj.get("tokenType")?;
        let profile_url_: Option<String> = obj.get("profileUrl")?;
        let provider_: Option<IdentityProvider> = obj.get("provider")?;
        let expiry_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("expiryDate")?;
        let scopes_: Option<Vec<String>> = obj.get("scopes")?;
        let expires_in_: Option<f64> = obj.get("expiresIn")?;
        let refresh_token_: Option<String> = obj.get("refreshToken")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let active_: Option<bool> = obj.get("active")?;
        let access_token_: Option<String> = obj.get("accessToken")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let val = Self {
            provider_user_id: provider_user_id_,
            token_type: token_type_,
            profile_url: profile_url_,
            provider: provider_,
            expiry_date: expiry_date_,
            scopes: scopes_,
            expires_in: expires_in_,
            refresh_token: refresh_token_,
            deleted: deleted_,
            active: active_,
            access_token: access_token_,
            created_at: created_at_,
            updated_at: updated_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for SSO {}
pub struct Preferences {
    pub time_zone: Option<String>,
    pub communications: Option<CommunicationMethod>,
    pub language: Option<String>,
    pub id: Option<String>,
    pub currency: Option<Currency>,
}
impl napi::bindgen_prelude::TypeName for Preferences {
    fn type_name() -> &'static str {
        "Preferences"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Preferences {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Preferences,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            time_zone: time_zone_,
            communications: communications_,
            language: language_,
            id: id_,
            currency: currency_,
        } = val;
        if time_zone_.is_some() {
            obj.set("timeZone", time_zone_)?;
        }
        if communications_.is_some() {
            obj.set("communications", communications_)?;
        }
        if language_.is_some() {
            obj.set("language", language_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Preferences {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let time_zone_: Option<String> = obj.get("timeZone")?;
        let communications_: Option<CommunicationMethod> = obj.get("communications")?;
        let language_: Option<String> = obj.get("language")?;
        let id_: Option<String> = obj.get("id")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let val = Self {
            time_zone: time_zone_,
            communications: communications_,
            language: language_,
            id: id_,
            currency: currency_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Preferences {}
pub struct Users {
    pub middle_name: Option<String>,
    pub phone_number: Option<String>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
    pub last_name: Option<String>,
    pub email: Option<String>,
    pub cover_photo: Option<Images>,
    pub gender: Option<Gender>,
    pub first_name: Option<String>,
    pub username: Option<String>,
    pub date_of_birth: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub roles: Option<Vec<Roles>>,
    pub bio: Option<String>,
    pub website: Option<String>,
    pub status: Option<UserStatus>,
    pub is_active: Option<bool>,
    pub preferences: Option<Preferences>,
    pub sso: Option<Vec<SSO>>,
    pub payment_methods: Option<PaymentMethods>,
    pub modify_token: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub profile_picture: Option<Images>,
    pub last_login: Option<chrono::DateTime<chrono::Utc>>,
    pub addresses: Option<Vec<Addresses>>,
    pub id: Option<String>,
    pub password: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Users {
    fn type_name() -> &'static str {
        "Users"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Users {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Users,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            middle_name: middle_name_,
            phone_number: phone_number_,
            social_profiles: social_profiles_,
            last_name: last_name_,
            email: email_,
            cover_photo: cover_photo_,
            gender: gender_,
            first_name: first_name_,
            username: username_,
            date_of_birth: date_of_birth_,
            created_at: created_at_,
            roles: roles_,
            bio: bio_,
            website: website_,
            status: status_,
            is_active: is_active_,
            preferences: preferences_,
            sso: sso_,
            payment_methods: payment_methods_,
            modify_token: modify_token_,
            updated_at: updated_at_,
            profile_picture: profile_picture_,
            last_login: last_login_,
            addresses: addresses_,
            id: id_,
            password: password_,
        } = val;
        if middle_name_.is_some() {
            obj.set("middleName", middle_name_)?;
        }
        if phone_number_.is_some() {
            obj.set("phoneNumber", phone_number_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if cover_photo_.is_some() {
            obj.set("coverPhoto", cover_photo_)?;
        }
        if gender_.is_some() {
            obj.set("gender", gender_)?;
        }
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if username_.is_some() {
            obj.set("username", username_)?;
        }
        if date_of_birth_.is_some() {
            obj.set("dateOfBirth", date_of_birth_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if roles_.is_some() {
            obj.set("roles", roles_)?;
        }
        if bio_.is_some() {
            obj.set("bio", bio_)?;
        }
        if website_.is_some() {
            obj.set("website", website_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if is_active_.is_some() {
            obj.set("isActive", is_active_)?;
        }
        if preferences_.is_some() {
            obj.set("preferences", preferences_)?;
        }
        if sso_.is_some() {
            obj.set("sso", sso_)?;
        }
        if payment_methods_.is_some() {
            obj.set("paymentMethods", payment_methods_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if profile_picture_.is_some() {
            obj.set("profilePicture", profile_picture_)?;
        }
        if last_login_.is_some() {
            obj.set("lastLogin", last_login_)?;
        }
        if addresses_.is_some() {
            obj.set("addresses", addresses_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if password_.is_some() {
            obj.set("password", password_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Users {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let middle_name_: Option<String> = obj.get("middleName")?;
        let phone_number_: Option<String> = obj.get("phoneNumber")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let email_: Option<String> = obj.get("email")?;
        let cover_photo_: Option<Images> = obj.get("coverPhoto")?;
        let gender_: Option<Gender> = obj.get("gender")?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let username_: Option<String> = obj.get("username")?;
        let date_of_birth_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("dateOfBirth")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let roles_: Option<Vec<Roles>> = obj.get("roles")?;
        let bio_: Option<String> = obj.get("bio")?;
        let website_: Option<String> = obj.get("website")?;
        let status_: Option<UserStatus> = obj.get("status")?;
        let is_active_: Option<bool> = obj.get("isActive")?;
        let preferences_: Option<Preferences> = obj.get("preferences")?;
        let sso_: Option<Vec<SSO>> = obj.get("sso")?;
        let payment_methods_: Option<PaymentMethods> = obj.get("paymentMethods")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let profile_picture_: Option<Images> = obj.get("profilePicture")?;
        let last_login_: Option<chrono::DateTime<chrono::Utc>> = obj.get("lastLogin")?;
        let addresses_: Option<Vec<Addresses>> = obj.get("addresses")?;
        let id_: Option<String> = obj.get("id")?;
        let password_: Option<String> = obj.get("password")?;
        let val = Self {
            middle_name: middle_name_,
            phone_number: phone_number_,
            social_profiles: social_profiles_,
            last_name: last_name_,
            email: email_,
            cover_photo: cover_photo_,
            gender: gender_,
            first_name: first_name_,
            username: username_,
            date_of_birth: date_of_birth_,
            created_at: created_at_,
            roles: roles_,
            bio: bio_,
            website: website_,
            status: status_,
            is_active: is_active_,
            preferences: preferences_,
            sso: sso_,
            payment_methods: payment_methods_,
            modify_token: modify_token_,
            updated_at: updated_at_,
            profile_picture: profile_picture_,
            last_login: last_login_,
            addresses: addresses_,
            id: id_,
            password: password_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Users {}
pub struct Notes {
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub color: Option<String>,
    pub tags: Option<Vec<String>>,
    pub shared_with: Option<Vec<Users>>,
    pub author: Option<Users>,
    pub priority: Option<PriorityLevel>,
    pub id: Option<String>,
    pub attachments: Option<Vec<Attachments>>,
    pub title: Option<String>,
    pub modify_token: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub visibility: Option<ContentVisibility>,
    pub last_accessed: Option<chrono::DateTime<chrono::Utc>>,
    pub metadata: Option<Vec<String>>,
    pub content: Option<String>,
    pub reminder: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Notes {
    fn type_name() -> &'static str {
        "Notes"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Notes {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Notes,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            updated_at: updated_at_,
            color: color_,
            tags: tags_,
            shared_with: shared_with_,
            author: author_,
            priority: priority_,
            id: id_,
            attachments: attachments_,
            title: title_,
            modify_token: modify_token_,
            created_at: created_at_,
            visibility: visibility_,
            last_accessed: last_accessed_,
            metadata: metadata_,
            content: content_,
            reminder: reminder_,
        } = val;
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if color_.is_some() {
            obj.set("color", color_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if shared_with_.is_some() {
            obj.set("sharedWith", shared_with_)?;
        }
        if author_.is_some() {
            obj.set("author", author_)?;
        }
        if priority_.is_some() {
            obj.set("priority", priority_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if attachments_.is_some() {
            obj.set("attachments", attachments_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if visibility_.is_some() {
            obj.set("visibility", visibility_)?;
        }
        if last_accessed_.is_some() {
            obj.set("lastAccessed", last_accessed_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if content_.is_some() {
            obj.set("content", content_)?;
        }
        if reminder_.is_some() {
            obj.set("reminder", reminder_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Notes {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let color_: Option<String> = obj.get("color")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let shared_with_: Option<Vec<Users>> = obj.get("sharedWith")?;
        let author_: Option<Users> = obj.get("author")?;
        let priority_: Option<PriorityLevel> = obj.get("priority")?;
        let id_: Option<String> = obj.get("id")?;
        let attachments_: Option<Vec<Attachments>> = obj.get("attachments")?;
        let title_: Option<String> = obj.get("title")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let visibility_: Option<ContentVisibility> = obj.get("visibility")?;
        let last_accessed_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("lastAccessed")?;
        let metadata_: Option<Vec<String>> = obj.get("metadata")?;
        let content_: Option<String> = obj.get("content")?;
        let reminder_: Option<chrono::DateTime<chrono::Utc>> = obj.get("reminder")?;
        let val = Self {
            updated_at: updated_at_,
            color: color_,
            tags: tags_,
            shared_with: shared_with_,
            author: author_,
            priority: priority_,
            id: id_,
            attachments: attachments_,
            title: title_,
            modify_token: modify_token_,
            created_at: created_at_,
            visibility: visibility_,
            last_accessed: last_accessed_,
            metadata: metadata_,
            content: content_,
            reminder: reminder_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Notes {}
pub struct LeadSource {
    pub source_name: Option<String>,
    pub source_id: Option<String>,
    pub details: Option<String>,
}
impl napi::bindgen_prelude::TypeName for LeadSource {
    fn type_name() -> &'static str {
        "LeadSource"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for LeadSource {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: LeadSource,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            source_name: source_name_,
            source_id: source_id_,
            details: details_,
        } = val;
        if source_name_.is_some() {
            obj.set("sourceName", source_name_)?;
        }
        if source_id_.is_some() {
            obj.set("sourceId", source_id_)?;
        }
        if details_.is_some() {
            obj.set("details", details_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for LeadSource {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let source_name_: Option<String> = obj.get("sourceName")?;
        let source_id_: Option<String> = obj.get("sourceId")?;
        let details_: Option<String> = obj.get("details")?;
        let val = Self {
            source_name: source_name_,
            source_id: source_id_,
            details: details_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for LeadSource {}
pub struct TransactionDetails {
    pub amount: Option<f64>,
    pub status: Option<String>,
    pub transaction_id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for TransactionDetails {
    fn type_name() -> &'static str {
        "TransactionDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for TransactionDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: TransactionDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { amount: amount_, status: status_, transaction_id: transaction_id_ } = val;
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if transaction_id_.is_some() {
            obj.set("transactionId", transaction_id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for TransactionDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let amount_: Option<f64> = obj.get("amount")?;
        let status_: Option<String> = obj.get("status")?;
        let transaction_id_: Option<String> = obj.get("transactionId")?;
        let val = Self {
            amount: amount_,
            status: status_,
            transaction_id: transaction_id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TransactionDetails {}
pub struct Leads {
    pub number_of_employees: Option<f64>,
    pub id: Option<String>,
    pub addresses: Option<Vec<Addresses>>,
    pub default_email: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub middle_name: Option<String>,
    pub lead_status: Option<LeadLifecycleStatus>,
    pub notes: Option<Vec<Notes>>,
    pub company_id: Option<String>,
    pub opportunities: Option<Vec<Opportunities>>,
    pub company_name: Option<String>,
    pub website: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
    pub first_name: Option<String>,
    pub entity: Option<Entity>,
    pub job_title: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub last_name: Option<String>,
    pub emails: Option<Vec<Emails>>,
    pub lead_source: Option<LeadSource>,
    pub annual_revenue: Option<f64>,
    pub default_phone: Option<String>,
    pub phones: Option<Vec<Phones>>,
    pub preferred_contact_method: Option<CommunicationMethod>,
    pub modify_token: Option<String>,
    pub name: Option<String>,
    pub industry: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Leads {
    fn type_name() -> &'static str {
        "Leads"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Leads {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Leads,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            number_of_employees: number_of_employees_,
            id: id_,
            addresses: addresses_,
            default_email: default_email_,
            updated_at: updated_at_,
            middle_name: middle_name_,
            lead_status: lead_status_,
            notes: notes_,
            company_id: company_id_,
            opportunities: opportunities_,
            company_name: company_name_,
            website: website_,
            custom_fields: custom_fields_,
            social_profiles: social_profiles_,
            first_name: first_name_,
            entity: entity_,
            job_title: job_title_,
            created_at: created_at_,
            last_name: last_name_,
            emails: emails_,
            lead_source: lead_source_,
            annual_revenue: annual_revenue_,
            default_phone: default_phone_,
            phones: phones_,
            preferred_contact_method: preferred_contact_method_,
            modify_token: modify_token_,
            name: name_,
            industry: industry_,
        } = val;
        if number_of_employees_.is_some() {
            obj.set("numberOfEmployees", number_of_employees_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if addresses_.is_some() {
            obj.set("addresses", addresses_)?;
        }
        if default_email_.is_some() {
            obj.set("defaultEmail", default_email_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if middle_name_.is_some() {
            obj.set("middleName", middle_name_)?;
        }
        if lead_status_.is_some() {
            obj.set("leadStatus", lead_status_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if company_id_.is_some() {
            obj.set("companyId", company_id_)?;
        }
        if opportunities_.is_some() {
            obj.set("opportunities", opportunities_)?;
        }
        if company_name_.is_some() {
            obj.set("companyName", company_name_)?;
        }
        if website_.is_some() {
            obj.set("website", website_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if entity_.is_some() {
            obj.set("entity", entity_)?;
        }
        if job_title_.is_some() {
            obj.set("jobTitle", job_title_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        if emails_.is_some() {
            obj.set("emails", emails_)?;
        }
        if lead_source_.is_some() {
            obj.set("leadSource", lead_source_)?;
        }
        if annual_revenue_.is_some() {
            obj.set("annualRevenue", annual_revenue_)?;
        }
        if default_phone_.is_some() {
            obj.set("defaultPhone", default_phone_)?;
        }
        if phones_.is_some() {
            obj.set("phones", phones_)?;
        }
        if preferred_contact_method_.is_some() {
            obj.set("preferredContactMethod", preferred_contact_method_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if industry_.is_some() {
            obj.set("industry", industry_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Leads {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let number_of_employees_: Option<f64> = obj.get("numberOfEmployees")?;
        let id_: Option<String> = obj.get("id")?;
        let addresses_: Option<Vec<Addresses>> = obj.get("addresses")?;
        let default_email_: Option<String> = obj.get("defaultEmail")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let middle_name_: Option<String> = obj.get("middleName")?;
        let lead_status_: Option<LeadLifecycleStatus> = obj.get("leadStatus")?;
        let notes_: Option<Vec<Notes>> = obj.get("notes")?;
        let company_id_: Option<String> = obj.get("companyId")?;
        let opportunities_: Option<Vec<Opportunities>> = obj.get("opportunities")?;
        let company_name_: Option<String> = obj.get("companyName")?;
        let website_: Option<String> = obj.get("website")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let entity_: Option<Entity> = obj.get("entity")?;
        let job_title_: Option<String> = obj.get("jobTitle")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let emails_: Option<Vec<Emails>> = obj.get("emails")?;
        let lead_source_: Option<LeadSource> = obj.get("leadSource")?;
        let annual_revenue_: Option<f64> = obj.get("annualRevenue")?;
        let default_phone_: Option<String> = obj.get("defaultPhone")?;
        let phones_: Option<Vec<Phones>> = obj.get("phones")?;
        let preferred_contact_method_: Option<CommunicationMethod> = obj
            .get("preferredContactMethod")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let name_: Option<String> = obj.get("name")?;
        let industry_: Option<String> = obj.get("industry")?;
        let val = Self {
            number_of_employees: number_of_employees_,
            id: id_,
            addresses: addresses_,
            default_email: default_email_,
            updated_at: updated_at_,
            middle_name: middle_name_,
            lead_status: lead_status_,
            notes: notes_,
            company_id: company_id_,
            opportunities: opportunities_,
            company_name: company_name_,
            website: website_,
            custom_fields: custom_fields_,
            social_profiles: social_profiles_,
            first_name: first_name_,
            entity: entity_,
            job_title: job_title_,
            created_at: created_at_,
            last_name: last_name_,
            emails: emails_,
            lead_source: lead_source_,
            annual_revenue: annual_revenue_,
            default_phone: default_phone_,
            phones: phones_,
            preferred_contact_method: preferred_contact_method_,
            modify_token: modify_token_,
            name: name_,
            industry: industry_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Leads {}
pub struct FulfillmentReceipts {
    pub transaction_details: Option<TransactionDetails>,
    pub payment_method: Option<PaymentMethod>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub fulfillment_id: Option<String>,
    pub deleted: Option<bool>,
    pub currency: Option<Currency>,
    pub amount: Option<f64>,
    pub status: Option<OrderStatus>,
    pub authorization: Option<String>,
    pub test_case: Option<bool>,
    pub active: Option<bool>,
    pub id: Option<String>,
    pub customer_info: Option<Customers>,
}
impl napi::bindgen_prelude::TypeName for FulfillmentReceipts {
    fn type_name() -> &'static str {
        "FulfillmentReceipts"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for FulfillmentReceipts {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: FulfillmentReceipts,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            transaction_details: transaction_details_,
            payment_method: payment_method_,
            created_at: created_at_,
            updated_at: updated_at_,
            fulfillment_id: fulfillment_id_,
            deleted: deleted_,
            currency: currency_,
            amount: amount_,
            status: status_,
            authorization: authorization_,
            test_case: test_case_,
            active: active_,
            id: id_,
            customer_info: customer_info_,
        } = val;
        if transaction_details_.is_some() {
            obj.set("transactionDetails", transaction_details_)?;
        }
        if payment_method_.is_some() {
            obj.set("paymentMethod", payment_method_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if fulfillment_id_.is_some() {
            obj.set("fulfillmentId", fulfillment_id_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if authorization_.is_some() {
            obj.set("authorization", authorization_)?;
        }
        if test_case_.is_some() {
            obj.set("testCase", test_case_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if customer_info_.is_some() {
            obj.set("customerInfo", customer_info_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for FulfillmentReceipts {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let transaction_details_: Option<TransactionDetails> = obj
            .get("transactionDetails")?;
        let payment_method_: Option<PaymentMethod> = obj.get("paymentMethod")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let fulfillment_id_: Option<String> = obj.get("fulfillmentId")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let status_: Option<OrderStatus> = obj.get("status")?;
        let authorization_: Option<String> = obj.get("authorization")?;
        let test_case_: Option<bool> = obj.get("testCase")?;
        let active_: Option<bool> = obj.get("active")?;
        let id_: Option<String> = obj.get("id")?;
        let customer_info_: Option<Customers> = obj.get("customerInfo")?;
        let val = Self {
            transaction_details: transaction_details_,
            payment_method: payment_method_,
            created_at: created_at_,
            updated_at: updated_at_,
            fulfillment_id: fulfillment_id_,
            deleted: deleted_,
            currency: currency_,
            amount: amount_,
            status: status_,
            authorization: authorization_,
            test_case: test_case_,
            active: active_,
            id: id_,
            customer_info: customer_info_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FulfillmentReceipts {}
pub struct FulfillmentItems {
    pub product_id: Option<String>,
    pub id: Option<String>,
    pub status: Option<OrderStatus>,
    pub variant_id: Option<String>,
    pub weight: Option<f64>,
    pub taxable: Option<bool>,
    pub image_url: Option<String>,
    pub dimensions: Option<Dimensions>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub fulfillment_id: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub sku: Option<String>,
    pub variant_title: Option<String>,
    pub deleted: Option<bool>,
    pub order_id: Option<String>,
    pub title: Option<String>,
    pub price: Option<f64>,
    pub quantity: Option<f64>,
    pub weight_unit: Option<String>,
    pub active: Option<bool>,
    pub requires_shipping: Option<bool>,
    pub custom_attributes: Option<CustomAttributes>,
    pub description: Option<String>,
}
impl napi::bindgen_prelude::TypeName for FulfillmentItems {
    fn type_name() -> &'static str {
        "FulfillmentItems"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for FulfillmentItems {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: FulfillmentItems,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            product_id: product_id_,
            id: id_,
            status: status_,
            variant_id: variant_id_,
            weight: weight_,
            taxable: taxable_,
            image_url: image_url_,
            dimensions: dimensions_,
            created_at: created_at_,
            fulfillment_id: fulfillment_id_,
            updated_at: updated_at_,
            sku: sku_,
            variant_title: variant_title_,
            deleted: deleted_,
            order_id: order_id_,
            title: title_,
            price: price_,
            quantity: quantity_,
            weight_unit: weight_unit_,
            active: active_,
            requires_shipping: requires_shipping_,
            custom_attributes: custom_attributes_,
            description: description_,
        } = val;
        if product_id_.is_some() {
            obj.set("productId", product_id_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if variant_id_.is_some() {
            obj.set("variantId", variant_id_)?;
        }
        if weight_.is_some() {
            obj.set("weight", weight_)?;
        }
        if taxable_.is_some() {
            obj.set("taxable", taxable_)?;
        }
        if image_url_.is_some() {
            obj.set("imageUrl", image_url_)?;
        }
        if dimensions_.is_some() {
            obj.set("dimensions", dimensions_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if fulfillment_id_.is_some() {
            obj.set("fulfillmentId", fulfillment_id_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if sku_.is_some() {
            obj.set("sku", sku_)?;
        }
        if variant_title_.is_some() {
            obj.set("variantTitle", variant_title_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if order_id_.is_some() {
            obj.set("orderId", order_id_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if price_.is_some() {
            obj.set("price", price_)?;
        }
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        if weight_unit_.is_some() {
            obj.set("weightUnit", weight_unit_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if requires_shipping_.is_some() {
            obj.set("requiresShipping", requires_shipping_)?;
        }
        if custom_attributes_.is_some() {
            obj.set("customAttributes", custom_attributes_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for FulfillmentItems {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let product_id_: Option<String> = obj.get("productId")?;
        let id_: Option<String> = obj.get("id")?;
        let status_: Option<OrderStatus> = obj.get("status")?;
        let variant_id_: Option<String> = obj.get("variantId")?;
        let weight_: Option<f64> = obj.get("weight")?;
        let taxable_: Option<bool> = obj.get("taxable")?;
        let image_url_: Option<String> = obj.get("imageUrl")?;
        let dimensions_: Option<Dimensions> = obj.get("dimensions")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let fulfillment_id_: Option<String> = obj.get("fulfillmentId")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let sku_: Option<String> = obj.get("sku")?;
        let variant_title_: Option<String> = obj.get("variantTitle")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let order_id_: Option<String> = obj.get("orderId")?;
        let title_: Option<String> = obj.get("title")?;
        let price_: Option<f64> = obj.get("price")?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let weight_unit_: Option<String> = obj.get("weightUnit")?;
        let active_: Option<bool> = obj.get("active")?;
        let requires_shipping_: Option<bool> = obj.get("requiresShipping")?;
        let custom_attributes_: Option<CustomAttributes> = obj.get("customAttributes")?;
        let description_: Option<String> = obj.get("description")?;
        let val = Self {
            product_id: product_id_,
            id: id_,
            status: status_,
            variant_id: variant_id_,
            weight: weight_,
            taxable: taxable_,
            image_url: image_url_,
            dimensions: dimensions_,
            created_at: created_at_,
            fulfillment_id: fulfillment_id_,
            updated_at: updated_at_,
            sku: sku_,
            variant_title: variant_title_,
            deleted: deleted_,
            order_id: order_id_,
            title: title_,
            price: price_,
            quantity: quantity_,
            weight_unit: weight_unit_,
            active: active_,
            requires_shipping: requires_shipping_,
            custom_attributes: custom_attributes_,
            description: description_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FulfillmentItems {}
pub struct Fulfillments {
    pub receipt: Option<FulfillmentReceipts>,
    pub total_price: Option<f64>,
    pub items: Option<Vec<FulfillmentItems>>,
    pub shipment_date: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub status: Option<FulfillmentStatus>,
    pub id: Option<String>,
    pub metadata: Option<Metadata>,
    pub notes: Option<String>,
    pub carrier: Option<String>,
    pub line_items: Option<Vec<Items>>,
    pub tracking_number: Option<String>,
    pub tracking_urls: Option<Vec<String>>,
    pub order_id: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub expected_delivery: Option<chrono::DateTime<chrono::Utc>>,
    pub service: Option<String>,
    pub currency: Option<Currency>,
    pub address: Option<Addresses>,
}
impl napi::bindgen_prelude::TypeName for Fulfillments {
    fn type_name() -> &'static str {
        "Fulfillments"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Fulfillments {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Fulfillments,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            receipt: receipt_,
            total_price: total_price_,
            items: items_,
            shipment_date: shipment_date_,
            updated_at: updated_at_,
            status: status_,
            id: id_,
            metadata: metadata_,
            notes: notes_,
            carrier: carrier_,
            line_items: line_items_,
            tracking_number: tracking_number_,
            tracking_urls: tracking_urls_,
            order_id: order_id_,
            created_at: created_at_,
            expected_delivery: expected_delivery_,
            service: service_,
            currency: currency_,
            address: address_,
        } = val;
        if receipt_.is_some() {
            obj.set("receipt", receipt_)?;
        }
        if total_price_.is_some() {
            obj.set("totalPrice", total_price_)?;
        }
        if items_.is_some() {
            obj.set("items", items_)?;
        }
        if shipment_date_.is_some() {
            obj.set("shipmentDate", shipment_date_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if carrier_.is_some() {
            obj.set("carrier", carrier_)?;
        }
        if line_items_.is_some() {
            obj.set("lineItems", line_items_)?;
        }
        if tracking_number_.is_some() {
            obj.set("trackingNumber", tracking_number_)?;
        }
        if tracking_urls_.is_some() {
            obj.set("trackingUrls", tracking_urls_)?;
        }
        if order_id_.is_some() {
            obj.set("orderId", order_id_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if expected_delivery_.is_some() {
            obj.set("expectedDelivery", expected_delivery_)?;
        }
        if service_.is_some() {
            obj.set("service", service_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Fulfillments {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let receipt_: Option<FulfillmentReceipts> = obj.get("receipt")?;
        let total_price_: Option<f64> = obj.get("totalPrice")?;
        let items_: Option<Vec<FulfillmentItems>> = obj.get("items")?;
        let shipment_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("shipmentDate")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let status_: Option<FulfillmentStatus> = obj.get("status")?;
        let id_: Option<String> = obj.get("id")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let notes_: Option<String> = obj.get("notes")?;
        let carrier_: Option<String> = obj.get("carrier")?;
        let line_items_: Option<Vec<Items>> = obj.get("lineItems")?;
        let tracking_number_: Option<String> = obj.get("trackingNumber")?;
        let tracking_urls_: Option<Vec<String>> = obj.get("trackingUrls")?;
        let order_id_: Option<String> = obj.get("orderId")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let expected_delivery_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("expectedDelivery")?;
        let service_: Option<String> = obj.get("service")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let val = Self {
            receipt: receipt_,
            total_price: total_price_,
            items: items_,
            shipment_date: shipment_date_,
            updated_at: updated_at_,
            status: status_,
            id: id_,
            metadata: metadata_,
            notes: notes_,
            carrier: carrier_,
            line_items: line_items_,
            tracking_number: tracking_number_,
            tracking_urls: tracking_urls_,
            order_id: order_id_,
            created_at: created_at_,
            expected_delivery: expected_delivery_,
            service: service_,
            currency: currency_,
            address: address_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Fulfillments {}
pub struct CustomAttributes {
    pub field_value: Option<String>,
    pub id: Option<String>,
    pub field_name: Option<String>,
    pub field_type: Option<DataType>,
}
impl napi::bindgen_prelude::TypeName for CustomAttributes {
    fn type_name() -> &'static str {
        "CustomAttributes"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for CustomAttributes {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: CustomAttributes,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            field_value: field_value_,
            id: id_,
            field_name: field_name_,
            field_type: field_type_,
        } = val;
        if field_value_.is_some() {
            obj.set("fieldValue", field_value_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if field_name_.is_some() {
            obj.set("fieldName", field_name_)?;
        }
        if field_type_.is_some() {
            obj.set("fieldType", field_type_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for CustomAttributes {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let field_value_: Option<String> = obj.get("fieldValue")?;
        let id_: Option<String> = obj.get("id")?;
        let field_name_: Option<String> = obj.get("fieldName")?;
        let field_type_: Option<DataType> = obj.get("fieldType")?;
        let val = Self {
            field_value: field_value_,
            id: id_,
            field_name: field_name_,
            field_type: field_type_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CustomAttributes {}
pub struct Companies {
    pub tags: Option<Vec<String>>,
    pub parent_company_id: Option<String>,
    pub name: Option<String>,
    pub default_email: Option<String>,
    pub website: Option<String>,
    pub domain: Option<String>,
    pub phones: Option<Vec<Phones>>,
    pub tax_id: Option<String>,
    pub logo: Option<String>,
    pub incorporation_date: Option<chrono::DateTime<chrono::Utc>>,
    pub revenue_currency: Option<String>,
    pub legal_name: Option<String>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
    pub address: Option<Addresses>,
    pub emails: Option<Vec<Emails>>,
    pub incorporation_country: Option<String>,
    pub industry: Option<String>,
    pub regulatory_status: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub modify_token: Option<String>,
    pub additional_contacts: Option<Vec<Contacts>>,
    pub revenue: Option<f64>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub founded_date: Option<chrono::DateTime<chrono::Utc>>,
    pub description: Option<String>,
    pub default_phone: Option<String>,
    pub stock_symbol: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub number_of_employees: Option<f64>,
    pub duns_number: Option<String>,
    pub r#type: Option<String>,
    pub id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Companies {
    fn type_name() -> &'static str {
        "Companies"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Companies {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Companies,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            tags: tags_,
            parent_company_id: parent_company_id_,
            name: name_,
            default_email: default_email_,
            website: website_,
            domain: domain_,
            phones: phones_,
            tax_id: tax_id_,
            logo: logo_,
            incorporation_date: incorporation_date_,
            revenue_currency: revenue_currency_,
            legal_name: legal_name_,
            social_profiles: social_profiles_,
            address: address_,
            emails: emails_,
            incorporation_country: incorporation_country_,
            industry: industry_,
            regulatory_status: regulatory_status_,
            custom_fields: custom_fields_,
            modify_token: modify_token_,
            additional_contacts: additional_contacts_,
            revenue: revenue_,
            updated_at: updated_at_,
            founded_date: founded_date_,
            description: description_,
            default_phone: default_phone_,
            stock_symbol: stock_symbol_,
            created_at: created_at_,
            number_of_employees: number_of_employees_,
            duns_number: duns_number_,
            r#type: type_,
            id: id_,
        } = val;
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if parent_company_id_.is_some() {
            obj.set("parentCompanyId", parent_company_id_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if default_email_.is_some() {
            obj.set("defaultEmail", default_email_)?;
        }
        if website_.is_some() {
            obj.set("website", website_)?;
        }
        if domain_.is_some() {
            obj.set("domain", domain_)?;
        }
        if phones_.is_some() {
            obj.set("phones", phones_)?;
        }
        if tax_id_.is_some() {
            obj.set("taxId", tax_id_)?;
        }
        if logo_.is_some() {
            obj.set("logo", logo_)?;
        }
        if incorporation_date_.is_some() {
            obj.set("incorporationDate", incorporation_date_)?;
        }
        if revenue_currency_.is_some() {
            obj.set("revenueCurrency", revenue_currency_)?;
        }
        if legal_name_.is_some() {
            obj.set("legalName", legal_name_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if emails_.is_some() {
            obj.set("emails", emails_)?;
        }
        if incorporation_country_.is_some() {
            obj.set("incorporationCountry", incorporation_country_)?;
        }
        if industry_.is_some() {
            obj.set("industry", industry_)?;
        }
        if regulatory_status_.is_some() {
            obj.set("regulatoryStatus", regulatory_status_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if additional_contacts_.is_some() {
            obj.set("additionalContacts", additional_contacts_)?;
        }
        if revenue_.is_some() {
            obj.set("revenue", revenue_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if founded_date_.is_some() {
            obj.set("foundedDate", founded_date_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if default_phone_.is_some() {
            obj.set("defaultPhone", default_phone_)?;
        }
        if stock_symbol_.is_some() {
            obj.set("stockSymbol", stock_symbol_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if number_of_employees_.is_some() {
            obj.set("numberOfEmployees", number_of_employees_)?;
        }
        if duns_number_.is_some() {
            obj.set("dunsNumber", duns_number_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Companies {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let parent_company_id_: Option<String> = obj.get("parentCompanyId")?;
        let name_: Option<String> = obj.get("name")?;
        let default_email_: Option<String> = obj.get("defaultEmail")?;
        let website_: Option<String> = obj.get("website")?;
        let domain_: Option<String> = obj.get("domain")?;
        let phones_: Option<Vec<Phones>> = obj.get("phones")?;
        let tax_id_: Option<String> = obj.get("taxId")?;
        let logo_: Option<String> = obj.get("logo")?;
        let incorporation_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("incorporationDate")?;
        let revenue_currency_: Option<String> = obj.get("revenueCurrency")?;
        let legal_name_: Option<String> = obj.get("legalName")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let emails_: Option<Vec<Emails>> = obj.get("emails")?;
        let incorporation_country_: Option<String> = obj.get("incorporationCountry")?;
        let industry_: Option<String> = obj.get("industry")?;
        let regulatory_status_: Option<String> = obj.get("regulatoryStatus")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let additional_contacts_: Option<Vec<Contacts>> = obj.get("additionalContacts")?;
        let revenue_: Option<f64> = obj.get("revenue")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let founded_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("foundedDate")?;
        let description_: Option<String> = obj.get("description")?;
        let default_phone_: Option<String> = obj.get("defaultPhone")?;
        let stock_symbol_: Option<String> = obj.get("stockSymbol")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let number_of_employees_: Option<f64> = obj.get("numberOfEmployees")?;
        let duns_number_: Option<String> = obj.get("dunsNumber")?;
        let type_: Option<String> = obj.get("type")?;
        let id_: Option<String> = obj.get("id")?;
        let val = Self {
            tags: tags_,
            parent_company_id: parent_company_id_,
            name: name_,
            default_email: default_email_,
            website: website_,
            domain: domain_,
            phones: phones_,
            tax_id: tax_id_,
            logo: logo_,
            incorporation_date: incorporation_date_,
            revenue_currency: revenue_currency_,
            legal_name: legal_name_,
            social_profiles: social_profiles_,
            address: address_,
            emails: emails_,
            incorporation_country: incorporation_country_,
            industry: industry_,
            regulatory_status: regulatory_status_,
            custom_fields: custom_fields_,
            modify_token: modify_token_,
            additional_contacts: additional_contacts_,
            revenue: revenue_,
            updated_at: updated_at_,
            founded_date: founded_date_,
            description: description_,
            default_phone: default_phone_,
            stock_symbol: stock_symbol_,
            created_at: created_at_,
            number_of_employees: number_of_employees_,
            duns_number: duns_number_,
            r#type: type_,
            id: id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Companies {}
pub struct Localizations {
    pub title: Option<String>,
    pub locale: Option<String>,
    pub description: Option<String>,
    pub meta_title: Option<String>,
    pub meta_description: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Localizations {
    fn type_name() -> &'static str {
        "Localizations"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Localizations {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Localizations,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            title: title_,
            locale: locale_,
            description: description_,
            meta_title: meta_title_,
            meta_description: meta_description_,
        } = val;
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if locale_.is_some() {
            obj.set("locale", locale_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if meta_title_.is_some() {
            obj.set("metaTitle", meta_title_)?;
        }
        if meta_description_.is_some() {
            obj.set("metaDescription", meta_description_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Localizations {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let title_: Option<String> = obj.get("title")?;
        let locale_: Option<String> = obj.get("locale")?;
        let description_: Option<String> = obj.get("description")?;
        let meta_title_: Option<String> = obj.get("metaTitle")?;
        let meta_description_: Option<String> = obj.get("metaDescription")?;
        let val = Self {
            title: title_,
            locale: locale_,
            description: description_,
            meta_title: meta_title_,
            meta_description: meta_description_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Localizations {}
pub struct KeyValues {
    pub value: Option<String>,
    pub key: Option<String>,
}
impl napi::bindgen_prelude::TypeName for KeyValues {
    fn type_name() -> &'static str {
        "KeyValues"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for KeyValues {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: KeyValues,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self { value: value_, key: key_ } = val;
        if value_.is_some() {
            obj.set("value", value_)?;
        }
        if key_.is_some() {
            obj.set("key", key_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for KeyValues {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let value_: Option<String> = obj.get("value")?;
        let key_: Option<String> = obj.get("key")?;
        let val = Self { value: value_, key: key_ };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for KeyValues {}
pub struct SocialProfiles {
    pub display_name: Option<String>,
    pub url: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub r#type: Option<SocialPlatform>,
    pub username: Option<String>,
    pub active: Option<bool>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub additional_info: Option<Metadata>,
    pub avatar_url: Option<String>,
    pub email: Option<String>,
}
impl napi::bindgen_prelude::TypeName for SocialProfiles {
    fn type_name() -> &'static str {
        "SocialProfiles"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for SocialProfiles {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: SocialProfiles,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            display_name: display_name_,
            url: url_,
            updated_at: updated_at_,
            deleted: deleted_,
            r#type: type_,
            username: username_,
            active: active_,
            created_at: created_at_,
            additional_info: additional_info_,
            avatar_url: avatar_url_,
            email: email_,
        } = val;
        if display_name_.is_some() {
            obj.set("displayName", display_name_)?;
        }
        if url_.is_some() {
            obj.set("url", url_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if username_.is_some() {
            obj.set("username", username_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if additional_info_.is_some() {
            obj.set("additionalInfo", additional_info_)?;
        }
        if avatar_url_.is_some() {
            obj.set("avatarUrl", avatar_url_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for SocialProfiles {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let display_name_: Option<String> = obj.get("displayName")?;
        let url_: Option<String> = obj.get("url")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let type_: Option<SocialPlatform> = obj.get("type")?;
        let username_: Option<String> = obj.get("username")?;
        let active_: Option<bool> = obj.get("active")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let additional_info_: Option<Metadata> = obj.get("additionalInfo")?;
        let avatar_url_: Option<String> = obj.get("avatarUrl")?;
        let email_: Option<String> = obj.get("email")?;
        let val = Self {
            display_name: display_name_,
            url: url_,
            updated_at: updated_at_,
            deleted: deleted_,
            r#type: type_,
            username: username_,
            active: active_,
            created_at: created_at_,
            additional_info: additional_info_,
            avatar_url: avatar_url_,
            email: email_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for SocialProfiles {}
pub struct Customers {
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub date_of_birth: Option<chrono::DateTime<chrono::Utc>>,
    pub middle_name: Option<String>,
    pub title: Option<String>,
    pub notes: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub default_address: Option<Addresses>,
    pub preferred_contact_method: Option<CommunicationMethod>,
    pub loyalty_program_membership: Option<String>,
    pub customer_type: Option<CustomerType>,
    pub company_id: Option<String>,
    pub metadata: Option<String>,
    pub id: Option<String>,
    pub email: Option<String>,
    pub first_name: Option<String>,
    pub currency: Option<Currency>,
    pub customer_segment: Option<String>,
    pub social_profiles: Option<Vec<SocialProfiles>>,
    pub source: Option<String>,
    pub modify_token: Option<String>,
    pub addresses: Option<Vec<Addresses>>,
    pub company: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub tags: Option<Vec<String>>,
    pub full_name: Option<String>,
    pub status: Option<CustomerStatus>,
    pub phone_number: Option<String>,
    pub last_name: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Customers {
    fn type_name() -> &'static str {
        "Customers"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Customers {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Customers,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            created_at: created_at_,
            date_of_birth: date_of_birth_,
            middle_name: middle_name_,
            title: title_,
            notes: notes_,
            updated_at: updated_at_,
            default_address: default_address_,
            preferred_contact_method: preferred_contact_method_,
            loyalty_program_membership: loyalty_program_membership_,
            customer_type: customer_type_,
            company_id: company_id_,
            metadata: metadata_,
            id: id_,
            email: email_,
            first_name: first_name_,
            currency: currency_,
            customer_segment: customer_segment_,
            social_profiles: social_profiles_,
            source: source_,
            modify_token: modify_token_,
            addresses: addresses_,
            company: company_,
            custom_fields: custom_fields_,
            tags: tags_,
            full_name: full_name_,
            status: status_,
            phone_number: phone_number_,
            last_name: last_name_,
        } = val;
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if date_of_birth_.is_some() {
            obj.set("dateOfBirth", date_of_birth_)?;
        }
        if middle_name_.is_some() {
            obj.set("middleName", middle_name_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if notes_.is_some() {
            obj.set("notes", notes_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if default_address_.is_some() {
            obj.set("defaultAddress", default_address_)?;
        }
        if preferred_contact_method_.is_some() {
            obj.set("preferredContactMethod", preferred_contact_method_)?;
        }
        if loyalty_program_membership_.is_some() {
            obj.set("loyaltyProgramMembership", loyalty_program_membership_)?;
        }
        if customer_type_.is_some() {
            obj.set("customerType", customer_type_)?;
        }
        if company_id_.is_some() {
            obj.set("companyId", company_id_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if customer_segment_.is_some() {
            obj.set("customerSegment", customer_segment_)?;
        }
        if social_profiles_.is_some() {
            obj.set("socialProfiles", social_profiles_)?;
        }
        if source_.is_some() {
            obj.set("source", source_)?;
        }
        if modify_token_.is_some() {
            obj.set("modifyToken", modify_token_)?;
        }
        if addresses_.is_some() {
            obj.set("addresses", addresses_)?;
        }
        if company_.is_some() {
            obj.set("company", company_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if full_name_.is_some() {
            obj.set("fullName", full_name_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if phone_number_.is_some() {
            obj.set("phoneNumber", phone_number_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Customers {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let date_of_birth_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("dateOfBirth")?;
        let middle_name_: Option<String> = obj.get("middleName")?;
        let title_: Option<String> = obj.get("title")?;
        let notes_: Option<String> = obj.get("notes")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let default_address_: Option<Addresses> = obj.get("defaultAddress")?;
        let preferred_contact_method_: Option<CommunicationMethod> = obj
            .get("preferredContactMethod")?;
        let loyalty_program_membership_: Option<String> = obj
            .get("loyaltyProgramMembership")?;
        let customer_type_: Option<CustomerType> = obj.get("customerType")?;
        let company_id_: Option<String> = obj.get("companyId")?;
        let metadata_: Option<String> = obj.get("metadata")?;
        let id_: Option<String> = obj.get("id")?;
        let email_: Option<String> = obj.get("email")?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let customer_segment_: Option<String> = obj.get("customerSegment")?;
        let social_profiles_: Option<Vec<SocialProfiles>> = obj.get("socialProfiles")?;
        let source_: Option<String> = obj.get("source")?;
        let modify_token_: Option<String> = obj.get("modifyToken")?;
        let addresses_: Option<Vec<Addresses>> = obj.get("addresses")?;
        let company_: Option<String> = obj.get("company")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let full_name_: Option<String> = obj.get("fullName")?;
        let status_: Option<CustomerStatus> = obj.get("status")?;
        let phone_number_: Option<String> = obj.get("phoneNumber")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let val = Self {
            created_at: created_at_,
            date_of_birth: date_of_birth_,
            middle_name: middle_name_,
            title: title_,
            notes: notes_,
            updated_at: updated_at_,
            default_address: default_address_,
            preferred_contact_method: preferred_contact_method_,
            loyalty_program_membership: loyalty_program_membership_,
            customer_type: customer_type_,
            company_id: company_id_,
            metadata: metadata_,
            id: id_,
            email: email_,
            first_name: first_name_,
            currency: currency_,
            customer_segment: customer_segment_,
            social_profiles: social_profiles_,
            source: source_,
            modify_token: modify_token_,
            addresses: addresses_,
            company: company_,
            custom_fields: custom_fields_,
            tags: tags_,
            full_name: full_name_,
            status: status_,
            phone_number: phone_number_,
            last_name: last_name_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Customers {}
pub struct TaxLines {
    pub deleted: Option<bool>,
    pub tax_code: Option<String>,
    pub is_inclusive: Option<bool>,
    pub price: Option<f64>,
    pub metadata: Option<Metadata>,
    pub rate: Option<f64>,
    pub title: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for TaxLines {
    fn type_name() -> &'static str {
        "TaxLines"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for TaxLines {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: TaxLines,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            deleted: deleted_,
            tax_code: tax_code_,
            is_inclusive: is_inclusive_,
            price: price_,
            metadata: metadata_,
            rate: rate_,
            title: title_,
            created_at: created_at_,
            updated_at: updated_at_,
            active: active_,
        } = val;
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if tax_code_.is_some() {
            obj.set("taxCode", tax_code_)?;
        }
        if is_inclusive_.is_some() {
            obj.set("isInclusive", is_inclusive_)?;
        }
        if price_.is_some() {
            obj.set("price", price_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if rate_.is_some() {
            obj.set("rate", rate_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for TaxLines {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let tax_code_: Option<String> = obj.get("taxCode")?;
        let is_inclusive_: Option<bool> = obj.get("isInclusive")?;
        let price_: Option<f64> = obj.get("price")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let rate_: Option<f64> = obj.get("rate")?;
        let title_: Option<String> = obj.get("title")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let val = Self {
            deleted: deleted_,
            tax_code: tax_code_,
            is_inclusive: is_inclusive_,
            price: price_,
            metadata: metadata_,
            rate: rate_,
            title: title_,
            created_at: created_at_,
            updated_at: updated_at_,
            active: active_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TaxLines {}
pub struct Images {
    pub height: Option<f64>,
    pub deleted: Option<bool>,
    pub thumbnail_src: Option<String>,
    pub alt_text: Option<String>,
    pub id: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub title: Option<String>,
    pub width: Option<f64>,
    pub mime_type: Option<ImageMimeType>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
    pub caption: Option<String>,
    pub tags: Option<Vec<String>>,
    pub src: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Images {
    fn type_name() -> &'static str {
        "Images"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Images {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Images,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            height: height_,
            deleted: deleted_,
            thumbnail_src: thumbnail_src_,
            alt_text: alt_text_,
            id: id_,
            created_at: created_at_,
            title: title_,
            width: width_,
            mime_type: mime_type_,
            updated_at: updated_at_,
            active: active_,
            caption: caption_,
            tags: tags_,
            src: src_,
        } = val;
        if height_.is_some() {
            obj.set("height", height_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if thumbnail_src_.is_some() {
            obj.set("thumbnailSrc", thumbnail_src_)?;
        }
        if alt_text_.is_some() {
            obj.set("altText", alt_text_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if width_.is_some() {
            obj.set("width", width_)?;
        }
        if mime_type_.is_some() {
            obj.set("mimeType", mime_type_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if caption_.is_some() {
            obj.set("caption", caption_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if src_.is_some() {
            obj.set("src", src_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Images {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let height_: Option<f64> = obj.get("height")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let thumbnail_src_: Option<String> = obj.get("thumbnailSrc")?;
        let alt_text_: Option<String> = obj.get("altText")?;
        let id_: Option<String> = obj.get("id")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let title_: Option<String> = obj.get("title")?;
        let width_: Option<f64> = obj.get("width")?;
        let mime_type_: Option<ImageMimeType> = obj.get("mimeType")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let caption_: Option<String> = obj.get("caption")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let src_: Option<String> = obj.get("src")?;
        let val = Self {
            height: height_,
            deleted: deleted_,
            thumbnail_src: thumbnail_src_,
            alt_text: alt_text_,
            id: id_,
            created_at: created_at_,
            title: title_,
            width: width_,
            mime_type: mime_type_,
            updated_at: updated_at_,
            active: active_,
            caption: caption_,
            tags: tags_,
            src: src_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Images {}
pub struct GiftCards {
    pub card_number: Option<String>,
    pub id: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub issued_by: Option<String>,
    pub expiration_date: Option<chrono::DateTime<chrono::Utc>>,
    pub currency: Option<Currency>,
    pub metadata: Option<String>,
    pub purchased_by: Option<String>,
    pub associated_user: Option<Users>,
    pub status: Option<LifecycleStatus>,
    pub amount_used: Option<f64>,
    pub deleted: Option<bool>,
    pub active: Option<bool>,
    pub balance: Option<f64>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for GiftCards {
    fn type_name() -> &'static str {
        "GiftCards"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for GiftCards {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: GiftCards,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            card_number: card_number_,
            id: id_,
            created_at: created_at_,
            issued_by: issued_by_,
            expiration_date: expiration_date_,
            currency: currency_,
            metadata: metadata_,
            purchased_by: purchased_by_,
            associated_user: associated_user_,
            status: status_,
            amount_used: amount_used_,
            deleted: deleted_,
            active: active_,
            balance: balance_,
            updated_at: updated_at_,
        } = val;
        if card_number_.is_some() {
            obj.set("cardNumber", card_number_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if issued_by_.is_some() {
            obj.set("issuedBy", issued_by_)?;
        }
        if expiration_date_.is_some() {
            obj.set("expirationDate", expiration_date_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if purchased_by_.is_some() {
            obj.set("purchasedBy", purchased_by_)?;
        }
        if associated_user_.is_some() {
            obj.set("associatedUser", associated_user_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if amount_used_.is_some() {
            obj.set("amountUsed", amount_used_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if balance_.is_some() {
            obj.set("balance", balance_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for GiftCards {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let card_number_: Option<String> = obj.get("cardNumber")?;
        let id_: Option<String> = obj.get("id")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let issued_by_: Option<String> = obj.get("issuedBy")?;
        let expiration_date_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("expirationDate")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let metadata_: Option<String> = obj.get("metadata")?;
        let purchased_by_: Option<String> = obj.get("purchasedBy")?;
        let associated_user_: Option<Users> = obj.get("associatedUser")?;
        let status_: Option<LifecycleStatus> = obj.get("status")?;
        let amount_used_: Option<f64> = obj.get("amountUsed")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let active_: Option<bool> = obj.get("active")?;
        let balance_: Option<f64> = obj.get("balance")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let val = Self {
            card_number: card_number_,
            id: id_,
            created_at: created_at_,
            issued_by: issued_by_,
            expiration_date: expiration_date_,
            currency: currency_,
            metadata: metadata_,
            purchased_by: purchased_by_,
            associated_user: associated_user_,
            status: status_,
            amount_used: amount_used_,
            deleted: deleted_,
            active: active_,
            balance: balance_,
            updated_at: updated_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for GiftCards {}
pub struct Promotions {
    pub deleted: Option<bool>,
    pub usage_limit: Option<f64>,
    pub terms_and_conditions: Option<String>,
    pub active: Option<bool>,
    pub start_date: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub description: Option<String>,
    pub discount_value: Option<f64>,
    pub limit_per_customer: Option<f64>,
    pub customer_eligibility: Option<CustomerEligibilityStatus>,
    pub r#type: Option<PromotionType>,
    pub discount_type: Option<DiscountType>,
    pub minimum_purchase_amount: Option<f64>,
    pub end_date: Option<chrono::DateTime<chrono::Utc>>,
    pub currency: Option<Currency>,
    pub code: Option<String>,
    pub eligible_items: Option<Vec<String>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Promotions {
    fn type_name() -> &'static str {
        "Promotions"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Promotions {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Promotions,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            deleted: deleted_,
            usage_limit: usage_limit_,
            terms_and_conditions: terms_and_conditions_,
            active: active_,
            start_date: start_date_,
            created_at: created_at_,
            description: description_,
            discount_value: discount_value_,
            limit_per_customer: limit_per_customer_,
            customer_eligibility: customer_eligibility_,
            r#type: type_,
            discount_type: discount_type_,
            minimum_purchase_amount: minimum_purchase_amount_,
            end_date: end_date_,
            currency: currency_,
            code: code_,
            eligible_items: eligible_items_,
            updated_at: updated_at_,
        } = val;
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if usage_limit_.is_some() {
            obj.set("usageLimit", usage_limit_)?;
        }
        if terms_and_conditions_.is_some() {
            obj.set("termsAndConditions", terms_and_conditions_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if start_date_.is_some() {
            obj.set("startDate", start_date_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if discount_value_.is_some() {
            obj.set("discountValue", discount_value_)?;
        }
        if limit_per_customer_.is_some() {
            obj.set("limitPerCustomer", limit_per_customer_)?;
        }
        if customer_eligibility_.is_some() {
            obj.set("customerEligibility", customer_eligibility_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if discount_type_.is_some() {
            obj.set("discountType", discount_type_)?;
        }
        if minimum_purchase_amount_.is_some() {
            obj.set("minimumPurchaseAmount", minimum_purchase_amount_)?;
        }
        if end_date_.is_some() {
            obj.set("endDate", end_date_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if code_.is_some() {
            obj.set("code", code_)?;
        }
        if eligible_items_.is_some() {
            obj.set("eligibleItems", eligible_items_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Promotions {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let usage_limit_: Option<f64> = obj.get("usageLimit")?;
        let terms_and_conditions_: Option<String> = obj.get("termsAndConditions")?;
        let active_: Option<bool> = obj.get("active")?;
        let start_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("startDate")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let description_: Option<String> = obj.get("description")?;
        let discount_value_: Option<f64> = obj.get("discountValue")?;
        let limit_per_customer_: Option<f64> = obj.get("limitPerCustomer")?;
        let customer_eligibility_: Option<CustomerEligibilityStatus> = obj
            .get("customerEligibility")?;
        let type_: Option<PromotionType> = obj.get("type")?;
        let discount_type_: Option<DiscountType> = obj.get("discountType")?;
        let minimum_purchase_amount_: Option<f64> = obj.get("minimumPurchaseAmount")?;
        let end_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("endDate")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let code_: Option<String> = obj.get("code")?;
        let eligible_items_: Option<Vec<String>> = obj.get("eligibleItems")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let val = Self {
            deleted: deleted_,
            usage_limit: usage_limit_,
            terms_and_conditions: terms_and_conditions_,
            active: active_,
            start_date: start_date_,
            created_at: created_at_,
            description: description_,
            discount_value: discount_value_,
            limit_per_customer: limit_per_customer_,
            customer_eligibility: customer_eligibility_,
            r#type: type_,
            discount_type: discount_type_,
            minimum_purchase_amount: minimum_purchase_amount_,
            end_date: end_date_,
            currency: currency_,
            code: code_,
            eligible_items: eligible_items_,
            updated_at: updated_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Promotions {}
pub struct PaymentDetails {
    pub payment_gateway: Option<String>,
    pub currency: Option<Currency>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub method: Option<String>,
    pub amount: Option<f64>,
    pub billing_address: Option<Addresses>,
    pub refunded: Option<bool>,
    pub active: Option<bool>,
    pub transaction_id: Option<String>,
    pub status: Option<String>,
}
impl napi::bindgen_prelude::TypeName for PaymentDetails {
    fn type_name() -> &'static str {
        "PaymentDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for PaymentDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: PaymentDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            payment_gateway: payment_gateway_,
            currency: currency_,
            created_at: created_at_,
            updated_at: updated_at_,
            deleted: deleted_,
            method: method_,
            amount: amount_,
            billing_address: billing_address_,
            refunded: refunded_,
            active: active_,
            transaction_id: transaction_id_,
            status: status_,
        } = val;
        if payment_gateway_.is_some() {
            obj.set("paymentGateway", payment_gateway_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if method_.is_some() {
            obj.set("method", method_)?;
        }
        if amount_.is_some() {
            obj.set("amount", amount_)?;
        }
        if billing_address_.is_some() {
            obj.set("billingAddress", billing_address_)?;
        }
        if refunded_.is_some() {
            obj.set("refunded", refunded_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if transaction_id_.is_some() {
            obj.set("transactionId", transaction_id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for PaymentDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let payment_gateway_: Option<String> = obj.get("paymentGateway")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let method_: Option<String> = obj.get("method")?;
        let amount_: Option<f64> = obj.get("amount")?;
        let billing_address_: Option<Addresses> = obj.get("billingAddress")?;
        let refunded_: Option<bool> = obj.get("refunded")?;
        let active_: Option<bool> = obj.get("active")?;
        let transaction_id_: Option<String> = obj.get("transactionId")?;
        let status_: Option<String> = obj.get("status")?;
        let val = Self {
            payment_gateway: payment_gateway_,
            currency: currency_,
            created_at: created_at_,
            updated_at: updated_at_,
            deleted: deleted_,
            method: method_,
            amount: amount_,
            billing_address: billing_address_,
            refunded: refunded_,
            active: active_,
            transaction_id: transaction_id_,
            status: status_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PaymentDetails {}
pub struct ShippingDetails {
    pub provider: Option<String>,
    pub active: Option<bool>,
    pub method: Option<String>,
    pub address: Option<Addresses>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub estimated_delivery: Option<chrono::DateTime<chrono::Utc>>,
    pub signature_required: Option<bool>,
    pub insurance: Option<bool>,
    pub tracking_number: Option<String>,
    pub price: Option<f64>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
}
impl napi::bindgen_prelude::TypeName for ShippingDetails {
    fn type_name() -> &'static str {
        "ShippingDetails"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for ShippingDetails {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: ShippingDetails,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            provider: provider_,
            active: active_,
            method: method_,
            address: address_,
            created_at: created_at_,
            estimated_delivery: estimated_delivery_,
            signature_required: signature_required_,
            insurance: insurance_,
            tracking_number: tracking_number_,
            price: price_,
            updated_at: updated_at_,
            deleted: deleted_,
        } = val;
        if provider_.is_some() {
            obj.set("provider", provider_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if method_.is_some() {
            obj.set("method", method_)?;
        }
        if address_.is_some() {
            obj.set("address", address_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if estimated_delivery_.is_some() {
            obj.set("estimatedDelivery", estimated_delivery_)?;
        }
        if signature_required_.is_some() {
            obj.set("signatureRequired", signature_required_)?;
        }
        if insurance_.is_some() {
            obj.set("insurance", insurance_)?;
        }
        if tracking_number_.is_some() {
            obj.set("trackingNumber", tracking_number_)?;
        }
        if price_.is_some() {
            obj.set("price", price_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for ShippingDetails {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let provider_: Option<String> = obj.get("provider")?;
        let active_: Option<bool> = obj.get("active")?;
        let method_: Option<String> = obj.get("method")?;
        let address_: Option<Addresses> = obj.get("address")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let estimated_delivery_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("estimatedDelivery")?;
        let signature_required_: Option<bool> = obj.get("signatureRequired")?;
        let insurance_: Option<bool> = obj.get("insurance")?;
        let tracking_number_: Option<String> = obj.get("trackingNumber")?;
        let price_: Option<f64> = obj.get("price")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let val = Self {
            provider: provider_,
            active: active_,
            method: method_,
            address: address_,
            created_at: created_at_,
            estimated_delivery: estimated_delivery_,
            signature_required: signature_required_,
            insurance: insurance_,
            tracking_number: tracking_number_,
            price: price_,
            updated_at: updated_at_,
            deleted: deleted_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ShippingDetails {}
pub struct PerformanceMetrics {
    pub impressions: Option<f64>,
    pub spend: Option<f64>,
    pub return_on_investment: Option<f64>,
    pub cost_per_conversion: Option<f64>,
    pub clicks: Option<f64>,
    pub conversions: Option<f64>,
    pub conversion_rate: Option<f64>,
    pub cost_per_click: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for PerformanceMetrics {
    fn type_name() -> &'static str {
        "PerformanceMetrics"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for PerformanceMetrics {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: PerformanceMetrics,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            impressions: impressions_,
            spend: spend_,
            return_on_investment: return_on_investment_,
            cost_per_conversion: cost_per_conversion_,
            clicks: clicks_,
            conversions: conversions_,
            conversion_rate: conversion_rate_,
            cost_per_click: cost_per_click_,
        } = val;
        if impressions_.is_some() {
            obj.set("impressions", impressions_)?;
        }
        if spend_.is_some() {
            obj.set("spend", spend_)?;
        }
        if return_on_investment_.is_some() {
            obj.set("returnOnInvestment", return_on_investment_)?;
        }
        if cost_per_conversion_.is_some() {
            obj.set("costPerConversion", cost_per_conversion_)?;
        }
        if clicks_.is_some() {
            obj.set("clicks", clicks_)?;
        }
        if conversions_.is_some() {
            obj.set("conversions", conversions_)?;
        }
        if conversion_rate_.is_some() {
            obj.set("conversionRate", conversion_rate_)?;
        }
        if cost_per_click_.is_some() {
            obj.set("costPerClick", cost_per_click_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for PerformanceMetrics {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let impressions_: Option<f64> = obj.get("impressions")?;
        let spend_: Option<f64> = obj.get("spend")?;
        let return_on_investment_: Option<f64> = obj.get("returnOnInvestment")?;
        let cost_per_conversion_: Option<f64> = obj.get("costPerConversion")?;
        let clicks_: Option<f64> = obj.get("clicks")?;
        let conversions_: Option<f64> = obj.get("conversions")?;
        let conversion_rate_: Option<f64> = obj.get("conversionRate")?;
        let cost_per_click_: Option<f64> = obj.get("costPerClick")?;
        let val = Self {
            impressions: impressions_,
            spend: spend_,
            return_on_investment: return_on_investment_,
            cost_per_conversion: cost_per_conversion_,
            clicks: clicks_,
            conversions: conversions_,
            conversion_rate: conversion_rate_,
            cost_per_click: cost_per_click_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PerformanceMetrics {}
pub struct Carts {
    pub note: Option<String>,
    pub version: Option<String>,
    pub discount_codes: Option<Vec<String>>,
    pub payment_details: Option<PaymentDetails>,
    pub total_price: Option<f64>,
    pub total_weight: Option<f64>,
    pub promotions: Option<Vec<Promotions>>,
    pub buyer_identity: Option<Customers>,
    pub item_count: Option<f64>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub original_total_price: Option<f64>,
    pub gift_cards: Option<Vec<GiftCards>>,
    pub attributes: Option<Vec<String>>,
    pub state: Option<OrderStatus>,
    pub messages: Option<Vec<String>>,
    pub currency: Option<Currency>,
    pub token: Option<String>,
    pub items: Option<Vec<Items>>,
    pub shipping_details: Option<ShippingDetails>,
    pub id: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Carts {
    fn type_name() -> &'static str {
        "Carts"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Carts {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Carts,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            note: note_,
            version: version_,
            discount_codes: discount_codes_,
            payment_details: payment_details_,
            total_price: total_price_,
            total_weight: total_weight_,
            promotions: promotions_,
            buyer_identity: buyer_identity_,
            item_count: item_count_,
            created_at: created_at_,
            updated_at: updated_at_,
            original_total_price: original_total_price_,
            gift_cards: gift_cards_,
            attributes: attributes_,
            state: state_,
            messages: messages_,
            currency: currency_,
            token: token_,
            items: items_,
            shipping_details: shipping_details_,
            id: id_,
        } = val;
        if note_.is_some() {
            obj.set("note", note_)?;
        }
        if version_.is_some() {
            obj.set("version", version_)?;
        }
        if discount_codes_.is_some() {
            obj.set("discountCodes", discount_codes_)?;
        }
        if payment_details_.is_some() {
            obj.set("paymentDetails", payment_details_)?;
        }
        if total_price_.is_some() {
            obj.set("totalPrice", total_price_)?;
        }
        if total_weight_.is_some() {
            obj.set("totalWeight", total_weight_)?;
        }
        if promotions_.is_some() {
            obj.set("promotions", promotions_)?;
        }
        if buyer_identity_.is_some() {
            obj.set("buyerIdentity", buyer_identity_)?;
        }
        if item_count_.is_some() {
            obj.set("itemCount", item_count_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if original_total_price_.is_some() {
            obj.set("originalTotalPrice", original_total_price_)?;
        }
        if gift_cards_.is_some() {
            obj.set("giftCards", gift_cards_)?;
        }
        if attributes_.is_some() {
            obj.set("attributes", attributes_)?;
        }
        if state_.is_some() {
            obj.set("state", state_)?;
        }
        if messages_.is_some() {
            obj.set("messages", messages_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if token_.is_some() {
            obj.set("token", token_)?;
        }
        if items_.is_some() {
            obj.set("items", items_)?;
        }
        if shipping_details_.is_some() {
            obj.set("shippingDetails", shipping_details_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Carts {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let note_: Option<String> = obj.get("note")?;
        let version_: Option<String> = obj.get("version")?;
        let discount_codes_: Option<Vec<String>> = obj.get("discountCodes")?;
        let payment_details_: Option<PaymentDetails> = obj.get("paymentDetails")?;
        let total_price_: Option<f64> = obj.get("totalPrice")?;
        let total_weight_: Option<f64> = obj.get("totalWeight")?;
        let promotions_: Option<Vec<Promotions>> = obj.get("promotions")?;
        let buyer_identity_: Option<Customers> = obj.get("buyerIdentity")?;
        let item_count_: Option<f64> = obj.get("itemCount")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let original_total_price_: Option<f64> = obj.get("originalTotalPrice")?;
        let gift_cards_: Option<Vec<GiftCards>> = obj.get("giftCards")?;
        let attributes_: Option<Vec<String>> = obj.get("attributes")?;
        let state_: Option<OrderStatus> = obj.get("state")?;
        let messages_: Option<Vec<String>> = obj.get("messages")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let token_: Option<String> = obj.get("token")?;
        let items_: Option<Vec<Items>> = obj.get("items")?;
        let shipping_details_: Option<ShippingDetails> = obj.get("shippingDetails")?;
        let id_: Option<String> = obj.get("id")?;
        let val = Self {
            note: note_,
            version: version_,
            discount_codes: discount_codes_,
            payment_details: payment_details_,
            total_price: total_price_,
            total_weight: total_weight_,
            promotions: promotions_,
            buyer_identity: buyer_identity_,
            item_count: item_count_,
            created_at: created_at_,
            updated_at: updated_at_,
            original_total_price: original_total_price_,
            gift_cards: gift_cards_,
            attributes: attributes_,
            state: state_,
            messages: messages_,
            currency: currency_,
            token: token_,
            items: items_,
            shipping_details: shipping_details_,
            id: id_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Carts {}
pub struct Items {
    pub weight: Option<f64>,
    pub weight_unit: Option<String>,
    pub requires_shipping: Option<bool>,
    pub taxable: Option<bool>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
    pub parent_id: Option<String>,
    pub tax_lines: Option<Vec<TaxLines>>,
    pub image: Option<Images>,
    pub title: Option<String>,
    pub discounted_price: Option<f64>,
    pub fulfillable_quantity: Option<f64>,
    pub currency: Option<Currency>,
    pub original_price: Option<f64>,
    pub variant_title: Option<String>,
    pub deleted: Option<bool>,
    pub description: Option<String>,
    pub variant_id: Option<String>,
    pub quantity: Option<f64>,
    pub price: Option<f64>,
    pub id: Option<String>,
    pub account_id: Option<String>,
    pub account_name: Option<String>,
    pub product_id: Option<String>,
    pub sku: Option<String>,
    pub line_price: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for Items {
    fn type_name() -> &'static str {
        "Items"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Items {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Items,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            weight: weight_,
            weight_unit: weight_unit_,
            requires_shipping: requires_shipping_,
            taxable: taxable_,
            created_at: created_at_,
            updated_at: updated_at_,
            active: active_,
            parent_id: parent_id_,
            tax_lines: tax_lines_,
            image: image_,
            title: title_,
            discounted_price: discounted_price_,
            fulfillable_quantity: fulfillable_quantity_,
            currency: currency_,
            original_price: original_price_,
            variant_title: variant_title_,
            deleted: deleted_,
            description: description_,
            variant_id: variant_id_,
            quantity: quantity_,
            price: price_,
            id: id_,
            account_id: account_id_,
            account_name: account_name_,
            product_id: product_id_,
            sku: sku_,
            line_price: line_price_,
        } = val;
        if weight_.is_some() {
            obj.set("weight", weight_)?;
        }
        if weight_unit_.is_some() {
            obj.set("weightUnit", weight_unit_)?;
        }
        if requires_shipping_.is_some() {
            obj.set("requiresShipping", requires_shipping_)?;
        }
        if taxable_.is_some() {
            obj.set("taxable", taxable_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if parent_id_.is_some() {
            obj.set("parentId", parent_id_)?;
        }
        if tax_lines_.is_some() {
            obj.set("taxLines", tax_lines_)?;
        }
        if image_.is_some() {
            obj.set("image", image_)?;
        }
        if title_.is_some() {
            obj.set("title", title_)?;
        }
        if discounted_price_.is_some() {
            obj.set("discountedPrice", discounted_price_)?;
        }
        if fulfillable_quantity_.is_some() {
            obj.set("fulfillableQuantity", fulfillable_quantity_)?;
        }
        if currency_.is_some() {
            obj.set("currency", currency_)?;
        }
        if original_price_.is_some() {
            obj.set("originalPrice", original_price_)?;
        }
        if variant_title_.is_some() {
            obj.set("variantTitle", variant_title_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if variant_id_.is_some() {
            obj.set("variantId", variant_id_)?;
        }
        if quantity_.is_some() {
            obj.set("quantity", quantity_)?;
        }
        if price_.is_some() {
            obj.set("price", price_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if account_id_.is_some() {
            obj.set("accountId", account_id_)?;
        }
        if account_name_.is_some() {
            obj.set("accountName", account_name_)?;
        }
        if product_id_.is_some() {
            obj.set("productId", product_id_)?;
        }
        if sku_.is_some() {
            obj.set("sku", sku_)?;
        }
        if line_price_.is_some() {
            obj.set("linePrice", line_price_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Items {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let weight_: Option<f64> = obj.get("weight")?;
        let weight_unit_: Option<String> = obj.get("weightUnit")?;
        let requires_shipping_: Option<bool> = obj.get("requiresShipping")?;
        let taxable_: Option<bool> = obj.get("taxable")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let parent_id_: Option<String> = obj.get("parentId")?;
        let tax_lines_: Option<Vec<TaxLines>> = obj.get("taxLines")?;
        let image_: Option<Images> = obj.get("image")?;
        let title_: Option<String> = obj.get("title")?;
        let discounted_price_: Option<f64> = obj.get("discountedPrice")?;
        let fulfillable_quantity_: Option<f64> = obj.get("fulfillableQuantity")?;
        let currency_: Option<Currency> = obj.get("currency")?;
        let original_price_: Option<f64> = obj.get("originalPrice")?;
        let variant_title_: Option<String> = obj.get("variantTitle")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let description_: Option<String> = obj.get("description")?;
        let variant_id_: Option<String> = obj.get("variantId")?;
        let quantity_: Option<f64> = obj.get("quantity")?;
        let price_: Option<f64> = obj.get("price")?;
        let id_: Option<String> = obj.get("id")?;
        let account_id_: Option<String> = obj.get("accountId")?;
        let account_name_: Option<String> = obj.get("accountName")?;
        let product_id_: Option<String> = obj.get("productId")?;
        let sku_: Option<String> = obj.get("sku")?;
        let line_price_: Option<f64> = obj.get("linePrice")?;
        let val = Self {
            weight: weight_,
            weight_unit: weight_unit_,
            requires_shipping: requires_shipping_,
            taxable: taxable_,
            created_at: created_at_,
            updated_at: updated_at_,
            active: active_,
            parent_id: parent_id_,
            tax_lines: tax_lines_,
            image: image_,
            title: title_,
            discounted_price: discounted_price_,
            fulfillable_quantity: fulfillable_quantity_,
            currency: currency_,
            original_price: original_price_,
            variant_title: variant_title_,
            deleted: deleted_,
            description: description_,
            variant_id: variant_id_,
            quantity: quantity_,
            price: price_,
            id: id_,
            account_id: account_id_,
            account_name: account_name_,
            product_id: product_id_,
            sku: sku_,
            line_price: line_price_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Items {}
pub struct Campaigns {
    pub channels: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub id: Option<String>,
    pub end_date: Option<chrono::DateTime<chrono::Utc>>,
    pub deleted: Option<bool>,
    pub target_audience: Option<String>,
    pub active: Option<bool>,
    pub name: Option<String>,
    pub performance_metrics: Option<PerformanceMetrics>,
    pub creative_assets: Option<Attachments>,
    pub start_date: Option<chrono::DateTime<chrono::Utc>>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub r#type: Option<CampaignType>,
    pub budget: Option<f64>,
    pub status: Option<CampaignStatus>,
}
impl napi::bindgen_prelude::TypeName for Campaigns {
    fn type_name() -> &'static str {
        "Campaigns"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Campaigns {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Campaigns,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            channels: channels_,
            tags: tags_,
            id: id_,
            end_date: end_date_,
            deleted: deleted_,
            target_audience: target_audience_,
            active: active_,
            name: name_,
            performance_metrics: performance_metrics_,
            creative_assets: creative_assets_,
            start_date: start_date_,
            created_at: created_at_,
            updated_at: updated_at_,
            r#type: type_,
            budget: budget_,
            status: status_,
        } = val;
        if channels_.is_some() {
            obj.set("channels", channels_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if end_date_.is_some() {
            obj.set("endDate", end_date_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if target_audience_.is_some() {
            obj.set("targetAudience", target_audience_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if performance_metrics_.is_some() {
            obj.set("performanceMetrics", performance_metrics_)?;
        }
        if creative_assets_.is_some() {
            obj.set("creativeAssets", creative_assets_)?;
        }
        if start_date_.is_some() {
            obj.set("startDate", start_date_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if budget_.is_some() {
            obj.set("budget", budget_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Campaigns {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let channels_: Option<Vec<String>> = obj.get("channels")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let id_: Option<String> = obj.get("id")?;
        let end_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("endDate")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let target_audience_: Option<String> = obj.get("targetAudience")?;
        let active_: Option<bool> = obj.get("active")?;
        let name_: Option<String> = obj.get("name")?;
        let performance_metrics_: Option<PerformanceMetrics> = obj
            .get("performanceMetrics")?;
        let creative_assets_: Option<Attachments> = obj.get("creativeAssets")?;
        let start_date_: Option<chrono::DateTime<chrono::Utc>> = obj.get("startDate")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let type_: Option<CampaignType> = obj.get("type")?;
        let budget_: Option<f64> = obj.get("budget")?;
        let status_: Option<CampaignStatus> = obj.get("status")?;
        let val = Self {
            channels: channels_,
            tags: tags_,
            id: id_,
            end_date: end_date_,
            deleted: deleted_,
            target_audience: target_audience_,
            active: active_,
            name: name_,
            performance_metrics: performance_metrics_,
            creative_assets: creative_assets_,
            start_date: start_date_,
            created_at: created_at_,
            updated_at: updated_at_,
            r#type: type_,
            budget: budget_,
            status: status_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Campaigns {}
pub struct Attachments {
    pub permissions: Option<Permissions>,
    pub id: Option<String>,
    pub thumbnail_url: Option<String>,
    pub preview_url: Option<String>,
    pub file_name: Option<String>,
    pub file_size: Option<f64>,
    pub file_type: Option<String>,
    pub url: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub metadata: Option<Metadata>,
    pub content: Option<String>,
    pub associated_with: Option<Entity>,
}
impl napi::bindgen_prelude::TypeName for Attachments {
    fn type_name() -> &'static str {
        "Attachments"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Attachments {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Attachments,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            permissions: permissions_,
            id: id_,
            thumbnail_url: thumbnail_url_,
            preview_url: preview_url_,
            file_name: file_name_,
            file_size: file_size_,
            file_type: file_type_,
            url: url_,
            created_at: created_at_,
            updated_at: updated_at_,
            metadata: metadata_,
            content: content_,
            associated_with: associated_with_,
        } = val;
        if permissions_.is_some() {
            obj.set("permissions", permissions_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if thumbnail_url_.is_some() {
            obj.set("thumbnailUrl", thumbnail_url_)?;
        }
        if preview_url_.is_some() {
            obj.set("previewUrl", preview_url_)?;
        }
        if file_name_.is_some() {
            obj.set("fileName", file_name_)?;
        }
        if file_size_.is_some() {
            obj.set("fileSize", file_size_)?;
        }
        if file_type_.is_some() {
            obj.set("fileType", file_type_)?;
        }
        if url_.is_some() {
            obj.set("url", url_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if metadata_.is_some() {
            obj.set("metadata", metadata_)?;
        }
        if content_.is_some() {
            obj.set("content", content_)?;
        }
        if associated_with_.is_some() {
            obj.set("associatedWith", associated_with_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Attachments {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let permissions_: Option<Permissions> = obj.get("permissions")?;
        let id_: Option<String> = obj.get("id")?;
        let thumbnail_url_: Option<String> = obj.get("thumbnailUrl")?;
        let preview_url_: Option<String> = obj.get("previewUrl")?;
        let file_name_: Option<String> = obj.get("fileName")?;
        let file_size_: Option<f64> = obj.get("fileSize")?;
        let file_type_: Option<String> = obj.get("fileType")?;
        let url_: Option<String> = obj.get("url")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let metadata_: Option<Metadata> = obj.get("metadata")?;
        let content_: Option<String> = obj.get("content")?;
        let associated_with_: Option<Entity> = obj.get("associatedWith")?;
        let val = Self {
            permissions: permissions_,
            id: id_,
            thumbnail_url: thumbnail_url_,
            preview_url: preview_url_,
            file_name: file_name_,
            file_size: file_size_,
            file_type: file_type_,
            url: url_,
            created_at: created_at_,
            updated_at: updated_at_,
            metadata: metadata_,
            content: content_,
            associated_with: associated_with_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Attachments {}
pub struct BusinessHours {
    pub time_zone: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub active: Option<bool>,
    pub id: Option<String>,
    pub day_of_week: Option<DayOfWeek>,
    pub sessions: Option<Vec<TimeSession>>,
    pub deleted: Option<bool>,
    pub closed: Option<bool>,
    pub store_i_d: Option<String>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for BusinessHours {
    fn type_name() -> &'static str {
        "BusinessHours"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for BusinessHours {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: BusinessHours,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            time_zone: time_zone_,
            created_at: created_at_,
            active: active_,
            id: id_,
            day_of_week: day_of_week_,
            sessions: sessions_,
            deleted: deleted_,
            closed: closed_,
            store_i_d: store_i_d_,
            updated_at: updated_at_,
        } = val;
        if time_zone_.is_some() {
            obj.set("timeZone", time_zone_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if active_.is_some() {
            obj.set("active", active_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if day_of_week_.is_some() {
            obj.set("dayOfWeek", day_of_week_)?;
        }
        if sessions_.is_some() {
            obj.set("sessions", sessions_)?;
        }
        if deleted_.is_some() {
            obj.set("deleted", deleted_)?;
        }
        if closed_.is_some() {
            obj.set("closed", closed_)?;
        }
        if store_i_d_.is_some() {
            obj.set("storeID", store_i_d_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for BusinessHours {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let time_zone_: Option<String> = obj.get("timeZone")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let active_: Option<bool> = obj.get("active")?;
        let id_: Option<String> = obj.get("id")?;
        let day_of_week_: Option<DayOfWeek> = obj.get("dayOfWeek")?;
        let sessions_: Option<Vec<TimeSession>> = obj.get("sessions")?;
        let deleted_: Option<bool> = obj.get("deleted")?;
        let closed_: Option<bool> = obj.get("closed")?;
        let store_i_d_: Option<String> = obj.get("storeID")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let val = Self {
            time_zone: time_zone_,
            created_at: created_at_,
            active: active_,
            id: id_,
            day_of_week: day_of_week_,
            sessions: sessions_,
            deleted: deleted_,
            closed: closed_,
            store_i_d: store_i_d_,
            updated_at: updated_at_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for BusinessHours {}
pub struct Brands {
    pub name: Option<String>,
    pub country: Option<String>,
    pub description: Option<String>,
    pub status: Option<ItemEntityStatus>,
    pub logo: Option<String>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub website: Option<String>,
    pub id: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub established: Option<chrono::DateTime<chrono::Utc>>,
}
impl napi::bindgen_prelude::TypeName for Brands {
    fn type_name() -> &'static str {
        "Brands"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Brands {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Brands,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            name: name_,
            country: country_,
            description: description_,
            status: status_,
            logo: logo_,
            created_at: created_at_,
            updated_at: updated_at_,
            website: website_,
            id: id_,
            custom_fields: custom_fields_,
            established: established_,
        } = val;
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if description_.is_some() {
            obj.set("description", description_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if logo_.is_some() {
            obj.set("logo", logo_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if website_.is_some() {
            obj.set("website", website_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if established_.is_some() {
            obj.set("established", established_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Brands {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let name_: Option<String> = obj.get("name")?;
        let country_: Option<String> = obj.get("country")?;
        let description_: Option<String> = obj.get("description")?;
        let status_: Option<ItemEntityStatus> = obj.get("status")?;
        let logo_: Option<String> = obj.get("logo")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let website_: Option<String> = obj.get("website")?;
        let id_: Option<String> = obj.get("id")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let established_: Option<chrono::DateTime<chrono::Utc>> = obj
            .get("established")?;
        let val = Self {
            name: name_,
            country: country_,
            description: description_,
            status: status_,
            logo: logo_,
            created_at: created_at_,
            updated_at: updated_at_,
            website: website_,
            id: id_,
            custom_fields: custom_fields_,
            established: established_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Brands {}
pub struct GeoCoordinates {
    pub altitude_accuracy: Option<f64>,
    pub latitude: Option<f64>,
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    pub longitude: Option<f64>,
    pub altitude: Option<f64>,
    pub accuracy: Option<f64>,
    pub heading: Option<f64>,
    pub speed: Option<f64>,
}
impl napi::bindgen_prelude::TypeName for GeoCoordinates {
    fn type_name() -> &'static str {
        "GeoCoordinates"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for GeoCoordinates {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: GeoCoordinates,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            altitude_accuracy: altitude_accuracy_,
            latitude: latitude_,
            timestamp: timestamp_,
            longitude: longitude_,
            altitude: altitude_,
            accuracy: accuracy_,
            heading: heading_,
            speed: speed_,
        } = val;
        if altitude_accuracy_.is_some() {
            obj.set("altitudeAccuracy", altitude_accuracy_)?;
        }
        if latitude_.is_some() {
            obj.set("latitude", latitude_)?;
        }
        if timestamp_.is_some() {
            obj.set("timestamp", timestamp_)?;
        }
        if longitude_.is_some() {
            obj.set("longitude", longitude_)?;
        }
        if altitude_.is_some() {
            obj.set("altitude", altitude_)?;
        }
        if accuracy_.is_some() {
            obj.set("accuracy", accuracy_)?;
        }
        if heading_.is_some() {
            obj.set("heading", heading_)?;
        }
        if speed_.is_some() {
            obj.set("speed", speed_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for GeoCoordinates {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let altitude_accuracy_: Option<f64> = obj.get("altitudeAccuracy")?;
        let latitude_: Option<f64> = obj.get("latitude")?;
        let timestamp_: Option<chrono::DateTime<chrono::Utc>> = obj.get("timestamp")?;
        let longitude_: Option<f64> = obj.get("longitude")?;
        let altitude_: Option<f64> = obj.get("altitude")?;
        let accuracy_: Option<f64> = obj.get("accuracy")?;
        let heading_: Option<f64> = obj.get("heading")?;
        let speed_: Option<f64> = obj.get("speed")?;
        let val = Self {
            altitude_accuracy: altitude_accuracy_,
            latitude: latitude_,
            timestamp: timestamp_,
            longitude: longitude_,
            altitude: altitude_,
            accuracy: accuracy_,
            heading: heading_,
            speed: speed_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for GeoCoordinates {}
pub struct Addresses {
    pub country: Option<String>,
    pub region: Option<String>,
    pub geo_location: Option<GeoCoordinates>,
    pub city: Option<String>,
    pub subdivision_code: Option<String>,
    pub contact_id: Option<String>,
    pub account_id: Option<String>,
    pub postal_code: Option<String>,
    pub street: Option<String>,
    pub name: Option<String>,
    pub province: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub postal_code_extension: Option<String>,
    pub country_code: Option<String>,
    pub company_name: Option<String>,
    pub first_name: Option<String>,
    pub last_name: Option<String>,
    pub id: Option<String>,
    pub address_line2: Option<String>,
    pub email: Option<String>,
    pub r#type: Option<ContactAddressType>,
    pub phone: Option<String>,
}
impl napi::bindgen_prelude::TypeName for Addresses {
    fn type_name() -> &'static str {
        "Addresses"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for Addresses {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Addresses,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            country: country_,
            region: region_,
            geo_location: geo_location_,
            city: city_,
            subdivision_code: subdivision_code_,
            contact_id: contact_id_,
            account_id: account_id_,
            postal_code: postal_code_,
            street: street_,
            name: name_,
            province: province_,
            custom_fields: custom_fields_,
            postal_code_extension: postal_code_extension_,
            country_code: country_code_,
            company_name: company_name_,
            first_name: first_name_,
            last_name: last_name_,
            id: id_,
            address_line2: address_line2_,
            email: email_,
            r#type: type_,
            phone: phone_,
        } = val;
        if country_.is_some() {
            obj.set("country", country_)?;
        }
        if region_.is_some() {
            obj.set("region", region_)?;
        }
        if geo_location_.is_some() {
            obj.set("geoLocation", geo_location_)?;
        }
        if city_.is_some() {
            obj.set("city", city_)?;
        }
        if subdivision_code_.is_some() {
            obj.set("subdivisionCode", subdivision_code_)?;
        }
        if contact_id_.is_some() {
            obj.set("contactId", contact_id_)?;
        }
        if account_id_.is_some() {
            obj.set("accountId", account_id_)?;
        }
        if postal_code_.is_some() {
            obj.set("postalCode", postal_code_)?;
        }
        if street_.is_some() {
            obj.set("street", street_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if province_.is_some() {
            obj.set("province", province_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if postal_code_extension_.is_some() {
            obj.set("postalCodeExtension", postal_code_extension_)?;
        }
        if country_code_.is_some() {
            obj.set("countryCode", country_code_)?;
        }
        if company_name_.is_some() {
            obj.set("companyName", company_name_)?;
        }
        if first_name_.is_some() {
            obj.set("firstName", first_name_)?;
        }
        if last_name_.is_some() {
            obj.set("lastName", last_name_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if address_line2_.is_some() {
            obj.set("addressLine2", address_line2_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        if type_.is_some() {
            obj.set("type", type_)?;
        }
        if phone_.is_some() {
            obj.set("phone", phone_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for Addresses {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let country_: Option<String> = obj.get("country")?;
        let region_: Option<String> = obj.get("region")?;
        let geo_location_: Option<GeoCoordinates> = obj.get("geoLocation")?;
        let city_: Option<String> = obj.get("city")?;
        let subdivision_code_: Option<String> = obj.get("subdivisionCode")?;
        let contact_id_: Option<String> = obj.get("contactId")?;
        let account_id_: Option<String> = obj.get("accountId")?;
        let postal_code_: Option<String> = obj.get("postalCode")?;
        let street_: Option<String> = obj.get("street")?;
        let name_: Option<String> = obj.get("name")?;
        let province_: Option<String> = obj.get("province")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let postal_code_extension_: Option<String> = obj.get("postalCodeExtension")?;
        let country_code_: Option<String> = obj.get("countryCode")?;
        let company_name_: Option<String> = obj.get("companyName")?;
        let first_name_: Option<String> = obj.get("firstName")?;
        let last_name_: Option<String> = obj.get("lastName")?;
        let id_: Option<String> = obj.get("id")?;
        let address_line2_: Option<String> = obj.get("addressLine2")?;
        let email_: Option<String> = obj.get("email")?;
        let type_: Option<ContactAddressType> = obj.get("type")?;
        let phone_: Option<String> = obj.get("phone")?;
        let val = Self {
            country: country_,
            region: region_,
            geo_location: geo_location_,
            city: city_,
            subdivision_code: subdivision_code_,
            contact_id: contact_id_,
            account_id: account_id_,
            postal_code: postal_code_,
            street: street_,
            name: name_,
            province: province_,
            custom_fields: custom_fields_,
            postal_code_extension: postal_code_extension_,
            country_code: country_code_,
            company_name: company_name_,
            first_name: first_name_,
            last_name: last_name_,
            id: id_,
            address_line2: address_line2_,
            email: email_,
            r#type: type_,
            phone: phone_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Addresses {}
pub struct CRMAccounts {
    pub annual_revenue: Option<f64>,
    pub name: Option<String>,
    pub industry: Option<String>,
    pub tags: Option<Vec<String>>,
    pub rating: Option<AccountEngagementLevel>,
    pub number_of_employees: Option<f64>,
    pub owner_id: Option<String>,
    pub status: Option<AccountStatus>,
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    pub billing_address: Option<Addresses>,
    pub id: Option<String>,
    pub account_type: Option<StakeholderType>,
    pub shipping_address: Option<Addresses>,
    pub website: Option<String>,
    pub phone: Option<String>,
    pub custom_fields: Option<Vec<CustomAttributes>>,
    pub email: Option<String>,
}
impl napi::bindgen_prelude::TypeName for CRMAccounts {
    fn type_name() -> &'static str {
        "CRMAccounts"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ToNapiValue for CRMAccounts {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: CRMAccounts,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = env_wrapper.create_object()?;
        let Self {
            annual_revenue: annual_revenue_,
            name: name_,
            industry: industry_,
            tags: tags_,
            rating: rating_,
            number_of_employees: number_of_employees_,
            owner_id: owner_id_,
            status: status_,
            created_at: created_at_,
            updated_at: updated_at_,
            billing_address: billing_address_,
            id: id_,
            account_type: account_type_,
            shipping_address: shipping_address_,
            website: website_,
            phone: phone_,
            custom_fields: custom_fields_,
            email: email_,
        } = val;
        if annual_revenue_.is_some() {
            obj.set("annualRevenue", annual_revenue_)?;
        }
        if name_.is_some() {
            obj.set("name", name_)?;
        }
        if industry_.is_some() {
            obj.set("industry", industry_)?;
        }
        if tags_.is_some() {
            obj.set("tags", tags_)?;
        }
        if rating_.is_some() {
            obj.set("rating", rating_)?;
        }
        if number_of_employees_.is_some() {
            obj.set("numberOfEmployees", number_of_employees_)?;
        }
        if owner_id_.is_some() {
            obj.set("ownerId", owner_id_)?;
        }
        if status_.is_some() {
            obj.set("status", status_)?;
        }
        if created_at_.is_some() {
            obj.set("createdAt", created_at_)?;
        }
        if updated_at_.is_some() {
            obj.set("updatedAt", updated_at_)?;
        }
        if billing_address_.is_some() {
            obj.set("billingAddress", billing_address_)?;
        }
        if id_.is_some() {
            obj.set("id", id_)?;
        }
        if account_type_.is_some() {
            obj.set("accountType", account_type_)?;
        }
        if shipping_address_.is_some() {
            obj.set("shippingAddress", shipping_address_)?;
        }
        if website_.is_some() {
            obj.set("website", website_)?;
        }
        if phone_.is_some() {
            obj.set("phone", phone_)?;
        }
        if custom_fields_.is_some() {
            obj.set("customFields", custom_fields_)?;
        }
        if email_.is_some() {
            obj.set("email", email_)?;
        }
        napi::bindgen_prelude::Object::to_napi_value(env, obj)
    }
}
impl napi::bindgen_prelude::FromNapiValue for CRMAccounts {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let env_wrapper = napi::bindgen_prelude::Env::from(env);
        let mut obj = napi::bindgen_prelude::Object::from_napi_value(env, napi_val)?;
        let annual_revenue_: Option<f64> = obj.get("annualRevenue")?;
        let name_: Option<String> = obj.get("name")?;
        let industry_: Option<String> = obj.get("industry")?;
        let tags_: Option<Vec<String>> = obj.get("tags")?;
        let rating_: Option<AccountEngagementLevel> = obj.get("rating")?;
        let number_of_employees_: Option<f64> = obj.get("numberOfEmployees")?;
        let owner_id_: Option<String> = obj.get("ownerId")?;
        let status_: Option<AccountStatus> = obj.get("status")?;
        let created_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("createdAt")?;
        let updated_at_: Option<chrono::DateTime<chrono::Utc>> = obj.get("updatedAt")?;
        let billing_address_: Option<Addresses> = obj.get("billingAddress")?;
        let id_: Option<String> = obj.get("id")?;
        let account_type_: Option<StakeholderType> = obj.get("accountType")?;
        let shipping_address_: Option<Addresses> = obj.get("shippingAddress")?;
        let website_: Option<String> = obj.get("website")?;
        let phone_: Option<String> = obj.get("phone")?;
        let custom_fields_: Option<Vec<CustomAttributes>> = obj.get("customFields")?;
        let email_: Option<String> = obj.get("email")?;
        let val = Self {
            annual_revenue: annual_revenue_,
            name: name_,
            industry: industry_,
            tags: tags_,
            rating: rating_,
            number_of_employees: number_of_employees_,
            owner_id: owner_id_,
            status: status_,
            created_at: created_at_,
            updated_at: updated_at_,
            billing_address: billing_address_,
            id: id_,
            account_type: account_type_,
            shipping_address: shipping_address_,
            website: website_,
            phone: phone_,
            custom_fields: custom_fields_,
            email: email_,
        };
        Ok(val)
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CRMAccounts {}
pub enum CreditType {
    Goodwill,
    Prepayment,
}
#[automatically_derived]
impl ::core::marker::Copy for CreditType {}
#[automatically_derived]
impl ::core::clone::Clone for CreditType {
    #[inline]
    fn clone(&self) -> CreditType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CreditType {
    fn type_name() -> &'static str {
        "CreditType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CreditType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CreditType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CreditType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Goodwill" => Ok(CreditType::Goodwill),
            "Prepayment" => Ok(CreditType::Prepayment),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CreditType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CreditType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CreditType::Goodwill => "Goodwill",
            CreditType::Prepayment => "Prepayment",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CreditType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Goodwill\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Goodwill")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "CreditType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Prepayment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Prepayment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "CreditType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CreditType_149() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CreditType\0",
        __register__enum__CreditType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CreditType_149___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CreditType_149___rust_ctor___ctor() -> usize {
        __napi_register__CreditType_149();
        0
    }
    __napi_register__CreditType_149___rust_ctor___ctor
};
pub enum TransactionMethod {
    Telephone,
    BankBranch,
    Online,
    Mobile,
    Atm,
    Mail,
}
#[automatically_derived]
impl ::core::marker::Copy for TransactionMethod {}
#[automatically_derived]
impl ::core::clone::Clone for TransactionMethod {
    #[inline]
    fn clone(&self) -> TransactionMethod {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for TransactionMethod {
    fn type_name() -> &'static str {
        "TransactionMethod"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TransactionMethod {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for TransactionMethod {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "TransactionMethod",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Telephone" => Ok(TransactionMethod::Telephone),
            "BankBranch" => Ok(TransactionMethod::BankBranch),
            "Online" => Ok(TransactionMethod::Online),
            "Mobile" => Ok(TransactionMethod::Mobile),
            "Atm" => Ok(TransactionMethod::Atm),
            "Mail" => Ok(TransactionMethod::Mail),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "TransactionMethod",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for TransactionMethod {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            TransactionMethod::Telephone => "Telephone",
            TransactionMethod::BankBranch => "BankBranch",
            TransactionMethod::Online => "Online",
            TransactionMethod::Mobile => "Mobile",
            TransactionMethod::Atm => "Atm",
            TransactionMethod::Mail => "Mail",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__TransactionMethod_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Telephone\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Telephone")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BankBranch\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BankBranch")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Online\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Online")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mobile\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mobile")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Atm\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Atm")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mail\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mail")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__TransactionMethod_150() {
    napi::bindgen_prelude::register_module_export(
        None,
        "TransactionMethod\0",
        __register__enum__TransactionMethod_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__TransactionMethod_150___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__TransactionMethod_150___rust_ctor___ctor() -> usize {
        __napi_register__TransactionMethod_150();
        0
    }
    __napi_register__TransactionMethod_150___rust_ctor___ctor
};
pub enum AccountType {
    OtherCurrentLiabilityPrepaidExpensesPayable,
    ExpenseOtherSellingExpenses,
    RevenueServiceFeeIncome,
    RevenueRevenueGeneral,
    OtherExpenseExtraordinaryItems,
    AssetAccumulatedDepletion,
    EquityDividendDisbursed,
    ExpenseEntertainment,
    OtherIncomeLossOnDisposalOfAssets,
    AssetFixedAssetOtherToolsEquipment,
    ExpenseInterestPaid,
    AssetCalledUpShareCapitalNotPaid,
    ExpenseBadDebts,
    AssetCashAndCashEquivalents,
    ExpenseShippingFreightDelivery,
    ExpenseIncomeTaxExpense,
    OtherIncomeOtherInvestmentIncome,
    AssetAllowanceForBadDebts,
    ExpenseRepairMaintenance,
    Asset,
    ExpenseProjectStudiesSurveysAssessments,
    RevenueDiscountsRefundsGiven,
    AssetShortTermInvestmentsInRelatedParties,
    EquityPreferredStock,
    ExpenseOtherCurrentOperatingCharges,
    OtherExpenseMatCredit,
    OtherExpenseHomeOwnerRentalInsurance,
    OtherIncomeDividendIncome,
    OtherIncomeUnrealisedLossOnSecuritiesNetOfTax,
    ExpenseOtherExternalServices,
    AssetChecking,
    AssetFixedAssetSoftware,
    AssetShortTermLoansAndAdvancesToRelatedParties,
    ExpenseCharitableContributions,
    ExpenseManagementCompensation,
    OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations,
    OtherCurrentLiabilityGlobalTaxPayable,
    AssetNonCurrentAssets,
    ExpenseDuesSubscriptions,
    AssetAssetsHeldForSale,
    AssetFixedAssetFurniture,
    ExpenseEntertainmentMeals,
    ExpensePayrollExpenses,
    LiabilityGroupAndAssociates,
    RevenueSalesRetail,
    AssetFixedAssetCopiers,
    ExpenseAdvertisingPromotional,
    ExpenseBankCharges,
    AssetParticipatingInterests,
    ExpenseTravelExpensesSellingExpense,
    CostOfGoodsSoldSuppliesMaterialsCogs,
    AssetSecurityDeposits,
    ExpenseSundry,
    OtherExpenseVehicleInsurance,
    EquityPaidInCapitalOrSurplus,
    OtherCurrentLiabilityLoanPayable,
    AssetInventory,
    AssetOtherLongTermInvestments,
    CostOfGoodsSoldOtherCostsOfServiceCos,
    AccountsReceivable,
    EquityCommonStock,
    ExpenseInsurance,
    LiabilityLongTermDebit,
    LiabilityProvisionsNonCurrentLiabilities,
    AssetAssetsAvailableForSale,
    ExpenseAppropriationsToDepreciation,
    ExpenseOfficeExpenses,
    LiabilityLongTermLiability,
    OtherExpensePenaltiesSettlements,
    EquityShareApplicationMoneyPendingAllotment,
    AssetOtherCurrentAsset,
    AssetVehicles,
    AssetOtherAsset,
    ExpenseUtilities,
    ExpenseFinanceCosts,
    OtherIncomeGainLossOnSaleOfFixedAssets,
    OtherExpenseDepletion,
    Equity,
    EquityCapitalReserves,
    OtherCurrentLiabilityProvisionsCurrentLiabilities,
    OtherCurrentLiability,
    AssetTrustAccounts,
    AssetSavings,
    RevenueOperatingGrants,
    ExpenseRentOrLeaseOfBuildings,
    RevenueNonProfitIncome,
    OtherCurrentLiabilityPayrollClearing,
    ExpenseDistributionCosts,
    OtherCurrentLiabilityDutiesAndTaxes,
    AssetMoneyMarket,
    AssetAvailableForSaleFinancialAssets,
    ExpenseEquipmentRental,
    Income,
    OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases,
    EquityPartnerDistributions,
    AssetBuildings,
    ExpenseOtherBusinessExpenses,
    OtherCurrentLiabilityDirectDepositPayable,
    LiabilityShareholderNotesPayable,
    ExpensePurchasesRebates,
    AssetTradeAndOtherReceivables,
    AssetInvestmentUsGovernmentObligations,
    EquityPartnersEquity,
    Expense,
    LiabilityGovernmentAndOtherPublicAuthorities,
    AssetGlobalTaxDeferred,
    AssetAccumulatedAmortizationOfOtherAssets,
    AssetDepletableAssets,
    AssetMachineryAndEquipment,
    LiabilityNotesPayable,
    OtherCurrentLiabilityFederalIncomeTaxPayable,
    EquityMoneyReceivedAgainstShareWarrants,
    OtherExpensePriorPeriodItems,
    OtherExpenseTaxRoundoffGainOrLoss,
    AssetOtherLongTermAssets,
    OtherExpenseVehicleRepairs,
    AssetLandAsset,
    ExpenseStaffCosts,
    RevenueOtherPrimaryIncome,
    OtherExpenseExchangeGainOrLoss,
    ExpenseTravel,
    AssetInvestments,
    ExpensePromotionalMeals,
    LiabilityAccruedLongTermLiabilities,
    LiabilityLongTermEmployeeBenefitObligations,
    OtherExpenseVehicle,
    AssetLoansToStockholders,
    EquityOwnersEquity,
    OtherCurrentLiabilityTrustAccountsLiabilities,
    OtherExpenseOtherMiscellaneousExpense,
    EquityPartnerContributions,
    AssetLoansToOfficers,
    ExpenseExtraordinaryCharges,
    AssetOtherCurrentAssets,
    ExpenseTravelExpensesGeneralAndAdminExpenses,
    EquityTreasuryStock,
    OtherExpenseVehicleLoan,
    AssetDevelopmentCosts,
    ExpenseAmortizationExpense,
    EquityEstimatedTaxes,
    LiabilityBankLoans,
    AssetLeaseholdImprovements,
    AssetIntangibleAssets,
    AssetOtherFixedAssets,
    ExpenseOfficeGeneralAdministrativeExpenses,
    AssetGlobalTaxRefund,
    OtherIncomeInterestEarned,
    OtherIncomeTaxExemptInterest,
    CostOfGoodsSoldCostOfSales,
    OtherExpenseDepreciation,
    OtherExpenseVehicleLoanInterest,
    OtherCurrentLiabilityLineOfCredit,
    ExpenseLegalProfessionalFees,
    EquityHealthcare,
    EquityShareCapital,
    AssetAccumulatedDepreciation,
    ExpenseAuto,
    Liability,
    AssetLeaseBuyout,
    AssetUndepositedFunds,
    EquityPersonalExpense,
    EquityPersonalIncome,
    AssetOtherLongTermLoansAndAdvances,
    ExpenseCommissionsAndFees,
    LiabilityCreditCard,
    EquityCalledUpShareCapital,
    AssetAccumulatedAmortization,
    AssetOtherIntangibleAssets,
    ExpenseTravelMeals,
    ExpenseShippingAndDeliveryExpense,
    AssetBank,
    ExpenseTaxesPaid,
    AssetInternalTransfers,
    LiabilityDebtsRelatedToParticipatingInterests,
    ExpensePenaltiesSettlements,
    RevenueIncome,
    LiabilityOtherLongTermProvisions,
    OtherCurrentLiabilityCurrentLiabilities,
    LiabilityAccrualsAndDeferredIncome,
    OtherIncome,
    CostOfGoodsSoldEquipmentRentalCos,
    AssetInvestmentOther,
    AssetInvestmentTaxExemptSecurities,
    ExpenseExternalServices,
    LiabilityOtherLongTermLiabilities,
    AssetCashOnHand,
    LiabilityProvisionForLiabilities,
    ExpenseLossOnDiscontinuedOperationsNetOfTax,
    RevenueSalesWholesale,
    OtherIncomeOtherOperatingIncome,
    OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts,
    AssetProvisionsFixedAssets,
    CostOfGoodsSoldFreightAndDeliveryCost,
    EquityAccumulatedAdjustment,
    AssetOrganizationalCosts,
    ExpenseOtherMiscellaneousServiceCost,
    LiabilityObligationsUnderFinanceLeases,
    OtherExpenseMortgageInterest,
    AssetLongTermLoansAndAdvancesToRelatedParties,
    AssetExpenditureAuthorisationsAndLettersOfCredit,
    AssetFurnitureAndFixtures,
    LiabilityDeferredTaxLiabilities,
    RevenueSavingsByTaxScheme,
    RevenueUnappliedCashPaymentIncome,
    LiabilityOutstandingDuesMicroSmallEnterprise,
    OtherExpenseIncomeTaxOtherExpense,
    AssetFixedAssetComputers,
    EquityOpeningBalanceEquity,
    EquityInvestmentGrants,
    AssetFixedAssetPhone,
    CostOfGoodsSold,
    OtherCurrentLiabilityDividendsPayable,
    LiabilityStaffAndRelatedLongTermLiabilityAccounts,
    ExpenseCostOfLabor,
    OtherCurrentLiabilityPayrollTaxPayable,
    OtherCurrentLiabilityAccruedLiabilities,
    OtherCurrentLiabilityInsurancePayable,
    OtherCurrentLiabilitySundryDebtorsAndCreditors,
    OtherCurrentLiabilityTradeAndOtherPayables,
    OtherExpenseOtherHomeOfficeExpenses,
    OtherCurrentLiabilityOtherCurrentLiabilities,
    AssetLand,
    OtherExpenseExceptionalItems,
    AssetCumulativeDepreciationOnIntangibleAssets,
    AssetOtherEarMarkedBankAccounts,
    RevenueOtherCurrentOperatingIncome,
    AssetOtherConsumables,
    OtherExpenseAmortization,
    OtherExpenseDeferredTaxExpense,
    OtherExpenseVehicleLease,
    AssetIntangibleAssetsUnderDevelopment,
    CostOfGoodsSoldShippingFreightDeliveryCos,
    LiabilityAccountsPayable,
    LiabilityAccruedVacationPayable,
    LiabilityOutstandingDuesOtherThanMicroSmallEnterprise,
    ExpenseUnappliedCashBillPaymentExpense,
    AssetFixedAssetPhotoVideo,
    OtherExpenseRepairsAndMaintenance,
    AssetBalWithGovtAuthorities,
    AssetRetainage,
    OtherExpenseWashAndRoadServices,
    AssetInvestmentMortgageRealEstateLoans,
    OtherExpenseRentAndLease,
    ExpenseSuppliesMaterials,
    AssetEmployeeCashAdvances,
    OtherExpenseUtilities,
    OtherIncomeGainLossOnSaleOfInvestments,
    EquityRetainedEarnings,
    EquityOtherFreeReserves,
    AssetPrepaymentsAndAccruedIncome,
    OtherCurrentLiabilityGlobalTaxSuspense,
    AssetAssetsInCourseOfConstruction,
    EquityAccumulatedOtherComprehensiveIncome,
    RevenueCashReceiptIncome,
    RevenueSalesOfProductIncome,
    AssetLongTermInvestments,
    OtherCurrentLiabilityRentsInTrustLiability,
    AssetCapitalWip,
    AssetFixedAsset,
    AssetLoansToOthers,
    OtherCurrentLiabilityCurrentTaxLiability,
    AssetRentsHeldInTrust,
    OtherExpenseOtherVehicleExpenses,
    AssetDeferredTax,
    AssetPrepaidExpenses,
    RevenueOwnWorkCapitalized,
    LiabilityLiabilitiesRelatedToAssetsHeldForSale,
    OtherExpenseParkingAndTolls,
    ExpenseBorrowingCost,
    OtherExpenseVehicleRegistration,
    OtherCurrentLiabilitySalesTaxPayable,
    AssetProvisionsCurrentAssets,
    ExpenseOtherRentalCosts,
    LiabilityLongTermBorrowings,
    OtherCurrentLiabilityShortTermBorrowings,
    OtherCurrentLiabilityInterestPayables,
    OtherCurrentLiabilitySocialSecurityAgencies,
    CostOfGoodsSoldCostOfLaborCos,
    EquityEquityInEarningsOfSubsidiuaries,
    OtherExpenseGasAndFuel,
    OtherExpense,
    OtherIncomeOtherMiscellaneousIncome,
    AssetGoodwill,
    AssetLicenses,
    OtherCurrentLiabilityStateLocalIncomeTaxPayable,
    ExpenseGlobalTaxExpense,
    OtherCurrentLiabilityProvisionForWarrantyObligations,
    EquityFunds,
    OtherExpenseHomeOffice,
    AssetProvisionsNonCurrentAssets,
}
#[automatically_derived]
impl ::core::marker::Copy for AccountType {}
#[automatically_derived]
impl ::core::clone::Clone for AccountType {
    #[inline]
    fn clone(&self) -> AccountType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for AccountType {
    fn type_name() -> &'static str {
        "AccountType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AccountType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for AccountType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "AccountType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "OtherCurrentLiabilityPrepaidExpensesPayable" => {
                Ok(AccountType::OtherCurrentLiabilityPrepaidExpensesPayable)
            }
            "ExpenseOtherSellingExpenses" => Ok(AccountType::ExpenseOtherSellingExpenses),
            "RevenueServiceFeeIncome" => Ok(AccountType::RevenueServiceFeeIncome),
            "RevenueRevenueGeneral" => Ok(AccountType::RevenueRevenueGeneral),
            "OtherExpenseExtraordinaryItems" => {
                Ok(AccountType::OtherExpenseExtraordinaryItems)
            }
            "AssetAccumulatedDepletion" => Ok(AccountType::AssetAccumulatedDepletion),
            "EquityDividendDisbursed" => Ok(AccountType::EquityDividendDisbursed),
            "ExpenseEntertainment" => Ok(AccountType::ExpenseEntertainment),
            "OtherIncomeLossOnDisposalOfAssets" => {
                Ok(AccountType::OtherIncomeLossOnDisposalOfAssets)
            }
            "AssetFixedAssetOtherToolsEquipment" => {
                Ok(AccountType::AssetFixedAssetOtherToolsEquipment)
            }
            "ExpenseInterestPaid" => Ok(AccountType::ExpenseInterestPaid),
            "AssetCalledUpShareCapitalNotPaid" => {
                Ok(AccountType::AssetCalledUpShareCapitalNotPaid)
            }
            "ExpenseBadDebts" => Ok(AccountType::ExpenseBadDebts),
            "AssetCashAndCashEquivalents" => Ok(AccountType::AssetCashAndCashEquivalents),
            "ExpenseShippingFreightDelivery" => {
                Ok(AccountType::ExpenseShippingFreightDelivery)
            }
            "ExpenseIncomeTaxExpense" => Ok(AccountType::ExpenseIncomeTaxExpense),
            "OtherIncomeOtherInvestmentIncome" => {
                Ok(AccountType::OtherIncomeOtherInvestmentIncome)
            }
            "AssetAllowanceForBadDebts" => Ok(AccountType::AssetAllowanceForBadDebts),
            "ExpenseRepairMaintenance" => Ok(AccountType::ExpenseRepairMaintenance),
            "Asset" => Ok(AccountType::Asset),
            "ExpenseProjectStudiesSurveysAssessments" => {
                Ok(AccountType::ExpenseProjectStudiesSurveysAssessments)
            }
            "RevenueDiscountsRefundsGiven" => {
                Ok(AccountType::RevenueDiscountsRefundsGiven)
            }
            "AssetShortTermInvestmentsInRelatedParties" => {
                Ok(AccountType::AssetShortTermInvestmentsInRelatedParties)
            }
            "EquityPreferredStock" => Ok(AccountType::EquityPreferredStock),
            "ExpenseOtherCurrentOperatingCharges" => {
                Ok(AccountType::ExpenseOtherCurrentOperatingCharges)
            }
            "OtherExpenseMatCredit" => Ok(AccountType::OtherExpenseMatCredit),
            "OtherExpenseHomeOwnerRentalInsurance" => {
                Ok(AccountType::OtherExpenseHomeOwnerRentalInsurance)
            }
            "OtherIncomeDividendIncome" => Ok(AccountType::OtherIncomeDividendIncome),
            "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax" => {
                Ok(AccountType::OtherIncomeUnrealisedLossOnSecuritiesNetOfTax)
            }
            "ExpenseOtherExternalServices" => {
                Ok(AccountType::ExpenseOtherExternalServices)
            }
            "AssetChecking" => Ok(AccountType::AssetChecking),
            "AssetFixedAssetSoftware" => Ok(AccountType::AssetFixedAssetSoftware),
            "AssetShortTermLoansAndAdvancesToRelatedParties" => {
                Ok(AccountType::AssetShortTermLoansAndAdvancesToRelatedParties)
            }
            "ExpenseCharitableContributions" => {
                Ok(AccountType::ExpenseCharitableContributions)
            }
            "ExpenseManagementCompensation" => {
                Ok(AccountType::ExpenseManagementCompensation)
            }
            "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations" => {
                Ok(
                    AccountType::OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations,
                )
            }
            "OtherCurrentLiabilityGlobalTaxPayable" => {
                Ok(AccountType::OtherCurrentLiabilityGlobalTaxPayable)
            }
            "AssetNonCurrentAssets" => Ok(AccountType::AssetNonCurrentAssets),
            "ExpenseDuesSubscriptions" => Ok(AccountType::ExpenseDuesSubscriptions),
            "AssetAssetsHeldForSale" => Ok(AccountType::AssetAssetsHeldForSale),
            "AssetFixedAssetFurniture" => Ok(AccountType::AssetFixedAssetFurniture),
            "ExpenseEntertainmentMeals" => Ok(AccountType::ExpenseEntertainmentMeals),
            "ExpensePayrollExpenses" => Ok(AccountType::ExpensePayrollExpenses),
            "LiabilityGroupAndAssociates" => Ok(AccountType::LiabilityGroupAndAssociates),
            "RevenueSalesRetail" => Ok(AccountType::RevenueSalesRetail),
            "AssetFixedAssetCopiers" => Ok(AccountType::AssetFixedAssetCopiers),
            "ExpenseAdvertisingPromotional" => {
                Ok(AccountType::ExpenseAdvertisingPromotional)
            }
            "ExpenseBankCharges" => Ok(AccountType::ExpenseBankCharges),
            "AssetParticipatingInterests" => Ok(AccountType::AssetParticipatingInterests),
            "ExpenseTravelExpensesSellingExpense" => {
                Ok(AccountType::ExpenseTravelExpensesSellingExpense)
            }
            "CostOfGoodsSoldSuppliesMaterialsCogs" => {
                Ok(AccountType::CostOfGoodsSoldSuppliesMaterialsCogs)
            }
            "AssetSecurityDeposits" => Ok(AccountType::AssetSecurityDeposits),
            "ExpenseSundry" => Ok(AccountType::ExpenseSundry),
            "OtherExpenseVehicleInsurance" => {
                Ok(AccountType::OtherExpenseVehicleInsurance)
            }
            "EquityPaidInCapitalOrSurplus" => {
                Ok(AccountType::EquityPaidInCapitalOrSurplus)
            }
            "OtherCurrentLiabilityLoanPayable" => {
                Ok(AccountType::OtherCurrentLiabilityLoanPayable)
            }
            "AssetInventory" => Ok(AccountType::AssetInventory),
            "AssetOtherLongTermInvestments" => {
                Ok(AccountType::AssetOtherLongTermInvestments)
            }
            "CostOfGoodsSoldOtherCostsOfServiceCos" => {
                Ok(AccountType::CostOfGoodsSoldOtherCostsOfServiceCos)
            }
            "AccountsReceivable" => Ok(AccountType::AccountsReceivable),
            "EquityCommonStock" => Ok(AccountType::EquityCommonStock),
            "ExpenseInsurance" => Ok(AccountType::ExpenseInsurance),
            "LiabilityLongTermDebit" => Ok(AccountType::LiabilityLongTermDebit),
            "LiabilityProvisionsNonCurrentLiabilities" => {
                Ok(AccountType::LiabilityProvisionsNonCurrentLiabilities)
            }
            "AssetAssetsAvailableForSale" => Ok(AccountType::AssetAssetsAvailableForSale),
            "ExpenseAppropriationsToDepreciation" => {
                Ok(AccountType::ExpenseAppropriationsToDepreciation)
            }
            "ExpenseOfficeExpenses" => Ok(AccountType::ExpenseOfficeExpenses),
            "LiabilityLongTermLiability" => Ok(AccountType::LiabilityLongTermLiability),
            "OtherExpensePenaltiesSettlements" => {
                Ok(AccountType::OtherExpensePenaltiesSettlements)
            }
            "EquityShareApplicationMoneyPendingAllotment" => {
                Ok(AccountType::EquityShareApplicationMoneyPendingAllotment)
            }
            "AssetOtherCurrentAsset" => Ok(AccountType::AssetOtherCurrentAsset),
            "AssetVehicles" => Ok(AccountType::AssetVehicles),
            "AssetOtherAsset" => Ok(AccountType::AssetOtherAsset),
            "ExpenseUtilities" => Ok(AccountType::ExpenseUtilities),
            "ExpenseFinanceCosts" => Ok(AccountType::ExpenseFinanceCosts),
            "OtherIncomeGainLossOnSaleOfFixedAssets" => {
                Ok(AccountType::OtherIncomeGainLossOnSaleOfFixedAssets)
            }
            "OtherExpenseDepletion" => Ok(AccountType::OtherExpenseDepletion),
            "Equity" => Ok(AccountType::Equity),
            "EquityCapitalReserves" => Ok(AccountType::EquityCapitalReserves),
            "OtherCurrentLiabilityProvisionsCurrentLiabilities" => {
                Ok(AccountType::OtherCurrentLiabilityProvisionsCurrentLiabilities)
            }
            "OtherCurrentLiability" => Ok(AccountType::OtherCurrentLiability),
            "AssetTrustAccounts" => Ok(AccountType::AssetTrustAccounts),
            "AssetSavings" => Ok(AccountType::AssetSavings),
            "RevenueOperatingGrants" => Ok(AccountType::RevenueOperatingGrants),
            "ExpenseRentOrLeaseOfBuildings" => {
                Ok(AccountType::ExpenseRentOrLeaseOfBuildings)
            }
            "RevenueNonProfitIncome" => Ok(AccountType::RevenueNonProfitIncome),
            "OtherCurrentLiabilityPayrollClearing" => {
                Ok(AccountType::OtherCurrentLiabilityPayrollClearing)
            }
            "ExpenseDistributionCosts" => Ok(AccountType::ExpenseDistributionCosts),
            "OtherCurrentLiabilityDutiesAndTaxes" => {
                Ok(AccountType::OtherCurrentLiabilityDutiesAndTaxes)
            }
            "AssetMoneyMarket" => Ok(AccountType::AssetMoneyMarket),
            "AssetAvailableForSaleFinancialAssets" => {
                Ok(AccountType::AssetAvailableForSaleFinancialAssets)
            }
            "ExpenseEquipmentRental" => Ok(AccountType::ExpenseEquipmentRental),
            "Income" => Ok(AccountType::Income),
            "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases" => {
                Ok(
                    AccountType::OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases,
                )
            }
            "EquityPartnerDistributions" => Ok(AccountType::EquityPartnerDistributions),
            "AssetBuildings" => Ok(AccountType::AssetBuildings),
            "ExpenseOtherBusinessExpenses" => {
                Ok(AccountType::ExpenseOtherBusinessExpenses)
            }
            "OtherCurrentLiabilityDirectDepositPayable" => {
                Ok(AccountType::OtherCurrentLiabilityDirectDepositPayable)
            }
            "LiabilityShareholderNotesPayable" => {
                Ok(AccountType::LiabilityShareholderNotesPayable)
            }
            "ExpensePurchasesRebates" => Ok(AccountType::ExpensePurchasesRebates),
            "AssetTradeAndOtherReceivables" => {
                Ok(AccountType::AssetTradeAndOtherReceivables)
            }
            "AssetInvestmentUsGovernmentObligations" => {
                Ok(AccountType::AssetInvestmentUsGovernmentObligations)
            }
            "EquityPartnersEquity" => Ok(AccountType::EquityPartnersEquity),
            "Expense" => Ok(AccountType::Expense),
            "LiabilityGovernmentAndOtherPublicAuthorities" => {
                Ok(AccountType::LiabilityGovernmentAndOtherPublicAuthorities)
            }
            "AssetGlobalTaxDeferred" => Ok(AccountType::AssetGlobalTaxDeferred),
            "AssetAccumulatedAmortizationOfOtherAssets" => {
                Ok(AccountType::AssetAccumulatedAmortizationOfOtherAssets)
            }
            "AssetDepletableAssets" => Ok(AccountType::AssetDepletableAssets),
            "AssetMachineryAndEquipment" => Ok(AccountType::AssetMachineryAndEquipment),
            "LiabilityNotesPayable" => Ok(AccountType::LiabilityNotesPayable),
            "OtherCurrentLiabilityFederalIncomeTaxPayable" => {
                Ok(AccountType::OtherCurrentLiabilityFederalIncomeTaxPayable)
            }
            "EquityMoneyReceivedAgainstShareWarrants" => {
                Ok(AccountType::EquityMoneyReceivedAgainstShareWarrants)
            }
            "OtherExpensePriorPeriodItems" => {
                Ok(AccountType::OtherExpensePriorPeriodItems)
            }
            "OtherExpenseTaxRoundoffGainOrLoss" => {
                Ok(AccountType::OtherExpenseTaxRoundoffGainOrLoss)
            }
            "AssetOtherLongTermAssets" => Ok(AccountType::AssetOtherLongTermAssets),
            "OtherExpenseVehicleRepairs" => Ok(AccountType::OtherExpenseVehicleRepairs),
            "AssetLandAsset" => Ok(AccountType::AssetLandAsset),
            "ExpenseStaffCosts" => Ok(AccountType::ExpenseStaffCosts),
            "RevenueOtherPrimaryIncome" => Ok(AccountType::RevenueOtherPrimaryIncome),
            "OtherExpenseExchangeGainOrLoss" => {
                Ok(AccountType::OtherExpenseExchangeGainOrLoss)
            }
            "ExpenseTravel" => Ok(AccountType::ExpenseTravel),
            "AssetInvestments" => Ok(AccountType::AssetInvestments),
            "ExpensePromotionalMeals" => Ok(AccountType::ExpensePromotionalMeals),
            "LiabilityAccruedLongTermLiabilities" => {
                Ok(AccountType::LiabilityAccruedLongTermLiabilities)
            }
            "LiabilityLongTermEmployeeBenefitObligations" => {
                Ok(AccountType::LiabilityLongTermEmployeeBenefitObligations)
            }
            "OtherExpenseVehicle" => Ok(AccountType::OtherExpenseVehicle),
            "AssetLoansToStockholders" => Ok(AccountType::AssetLoansToStockholders),
            "EquityOwnersEquity" => Ok(AccountType::EquityOwnersEquity),
            "OtherCurrentLiabilityTrustAccountsLiabilities" => {
                Ok(AccountType::OtherCurrentLiabilityTrustAccountsLiabilities)
            }
            "OtherExpenseOtherMiscellaneousExpense" => {
                Ok(AccountType::OtherExpenseOtherMiscellaneousExpense)
            }
            "EquityPartnerContributions" => Ok(AccountType::EquityPartnerContributions),
            "AssetLoansToOfficers" => Ok(AccountType::AssetLoansToOfficers),
            "ExpenseExtraordinaryCharges" => Ok(AccountType::ExpenseExtraordinaryCharges),
            "AssetOtherCurrentAssets" => Ok(AccountType::AssetOtherCurrentAssets),
            "ExpenseTravelExpensesGeneralAndAdminExpenses" => {
                Ok(AccountType::ExpenseTravelExpensesGeneralAndAdminExpenses)
            }
            "EquityTreasuryStock" => Ok(AccountType::EquityTreasuryStock),
            "OtherExpenseVehicleLoan" => Ok(AccountType::OtherExpenseVehicleLoan),
            "AssetDevelopmentCosts" => Ok(AccountType::AssetDevelopmentCosts),
            "ExpenseAmortizationExpense" => Ok(AccountType::ExpenseAmortizationExpense),
            "EquityEstimatedTaxes" => Ok(AccountType::EquityEstimatedTaxes),
            "LiabilityBankLoans" => Ok(AccountType::LiabilityBankLoans),
            "AssetLeaseholdImprovements" => Ok(AccountType::AssetLeaseholdImprovements),
            "AssetIntangibleAssets" => Ok(AccountType::AssetIntangibleAssets),
            "AssetOtherFixedAssets" => Ok(AccountType::AssetOtherFixedAssets),
            "ExpenseOfficeGeneralAdministrativeExpenses" => {
                Ok(AccountType::ExpenseOfficeGeneralAdministrativeExpenses)
            }
            "AssetGlobalTaxRefund" => Ok(AccountType::AssetGlobalTaxRefund),
            "OtherIncomeInterestEarned" => Ok(AccountType::OtherIncomeInterestEarned),
            "OtherIncomeTaxExemptInterest" => {
                Ok(AccountType::OtherIncomeTaxExemptInterest)
            }
            "CostOfGoodsSoldCostOfSales" => Ok(AccountType::CostOfGoodsSoldCostOfSales),
            "OtherExpenseDepreciation" => Ok(AccountType::OtherExpenseDepreciation),
            "OtherExpenseVehicleLoanInterest" => {
                Ok(AccountType::OtherExpenseVehicleLoanInterest)
            }
            "OtherCurrentLiabilityLineOfCredit" => {
                Ok(AccountType::OtherCurrentLiabilityLineOfCredit)
            }
            "ExpenseLegalProfessionalFees" => {
                Ok(AccountType::ExpenseLegalProfessionalFees)
            }
            "EquityHealthcare" => Ok(AccountType::EquityHealthcare),
            "EquityShareCapital" => Ok(AccountType::EquityShareCapital),
            "AssetAccumulatedDepreciation" => {
                Ok(AccountType::AssetAccumulatedDepreciation)
            }
            "ExpenseAuto" => Ok(AccountType::ExpenseAuto),
            "Liability" => Ok(AccountType::Liability),
            "AssetLeaseBuyout" => Ok(AccountType::AssetLeaseBuyout),
            "AssetUndepositedFunds" => Ok(AccountType::AssetUndepositedFunds),
            "EquityPersonalExpense" => Ok(AccountType::EquityPersonalExpense),
            "EquityPersonalIncome" => Ok(AccountType::EquityPersonalIncome),
            "AssetOtherLongTermLoansAndAdvances" => {
                Ok(AccountType::AssetOtherLongTermLoansAndAdvances)
            }
            "ExpenseCommissionsAndFees" => Ok(AccountType::ExpenseCommissionsAndFees),
            "LiabilityCreditCard" => Ok(AccountType::LiabilityCreditCard),
            "EquityCalledUpShareCapital" => Ok(AccountType::EquityCalledUpShareCapital),
            "AssetAccumulatedAmortization" => {
                Ok(AccountType::AssetAccumulatedAmortization)
            }
            "AssetOtherIntangibleAssets" => Ok(AccountType::AssetOtherIntangibleAssets),
            "ExpenseTravelMeals" => Ok(AccountType::ExpenseTravelMeals),
            "ExpenseShippingAndDeliveryExpense" => {
                Ok(AccountType::ExpenseShippingAndDeliveryExpense)
            }
            "AssetBank" => Ok(AccountType::AssetBank),
            "ExpenseTaxesPaid" => Ok(AccountType::ExpenseTaxesPaid),
            "AssetInternalTransfers" => Ok(AccountType::AssetInternalTransfers),
            "LiabilityDebtsRelatedToParticipatingInterests" => {
                Ok(AccountType::LiabilityDebtsRelatedToParticipatingInterests)
            }
            "ExpensePenaltiesSettlements" => Ok(AccountType::ExpensePenaltiesSettlements),
            "RevenueIncome" => Ok(AccountType::RevenueIncome),
            "LiabilityOtherLongTermProvisions" => {
                Ok(AccountType::LiabilityOtherLongTermProvisions)
            }
            "OtherCurrentLiabilityCurrentLiabilities" => {
                Ok(AccountType::OtherCurrentLiabilityCurrentLiabilities)
            }
            "LiabilityAccrualsAndDeferredIncome" => {
                Ok(AccountType::LiabilityAccrualsAndDeferredIncome)
            }
            "OtherIncome" => Ok(AccountType::OtherIncome),
            "CostOfGoodsSoldEquipmentRentalCos" => {
                Ok(AccountType::CostOfGoodsSoldEquipmentRentalCos)
            }
            "AssetInvestmentOther" => Ok(AccountType::AssetInvestmentOther),
            "AssetInvestmentTaxExemptSecurities" => {
                Ok(AccountType::AssetInvestmentTaxExemptSecurities)
            }
            "ExpenseExternalServices" => Ok(AccountType::ExpenseExternalServices),
            "LiabilityOtherLongTermLiabilities" => {
                Ok(AccountType::LiabilityOtherLongTermLiabilities)
            }
            "AssetCashOnHand" => Ok(AccountType::AssetCashOnHand),
            "LiabilityProvisionForLiabilities" => {
                Ok(AccountType::LiabilityProvisionForLiabilities)
            }
            "ExpenseLossOnDiscontinuedOperationsNetOfTax" => {
                Ok(AccountType::ExpenseLossOnDiscontinuedOperationsNetOfTax)
            }
            "RevenueSalesWholesale" => Ok(AccountType::RevenueSalesWholesale),
            "OtherIncomeOtherOperatingIncome" => {
                Ok(AccountType::OtherIncomeOtherOperatingIncome)
            }
            "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts" => {
                Ok(AccountType::OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts)
            }
            "AssetProvisionsFixedAssets" => Ok(AccountType::AssetProvisionsFixedAssets),
            "CostOfGoodsSoldFreightAndDeliveryCost" => {
                Ok(AccountType::CostOfGoodsSoldFreightAndDeliveryCost)
            }
            "EquityAccumulatedAdjustment" => Ok(AccountType::EquityAccumulatedAdjustment),
            "AssetOrganizationalCosts" => Ok(AccountType::AssetOrganizationalCosts),
            "ExpenseOtherMiscellaneousServiceCost" => {
                Ok(AccountType::ExpenseOtherMiscellaneousServiceCost)
            }
            "LiabilityObligationsUnderFinanceLeases" => {
                Ok(AccountType::LiabilityObligationsUnderFinanceLeases)
            }
            "OtherExpenseMortgageInterest" => {
                Ok(AccountType::OtherExpenseMortgageInterest)
            }
            "AssetLongTermLoansAndAdvancesToRelatedParties" => {
                Ok(AccountType::AssetLongTermLoansAndAdvancesToRelatedParties)
            }
            "AssetExpenditureAuthorisationsAndLettersOfCredit" => {
                Ok(AccountType::AssetExpenditureAuthorisationsAndLettersOfCredit)
            }
            "AssetFurnitureAndFixtures" => Ok(AccountType::AssetFurnitureAndFixtures),
            "LiabilityDeferredTaxLiabilities" => {
                Ok(AccountType::LiabilityDeferredTaxLiabilities)
            }
            "RevenueSavingsByTaxScheme" => Ok(AccountType::RevenueSavingsByTaxScheme),
            "RevenueUnappliedCashPaymentIncome" => {
                Ok(AccountType::RevenueUnappliedCashPaymentIncome)
            }
            "LiabilityOutstandingDuesMicroSmallEnterprise" => {
                Ok(AccountType::LiabilityOutstandingDuesMicroSmallEnterprise)
            }
            "OtherExpenseIncomeTaxOtherExpense" => {
                Ok(AccountType::OtherExpenseIncomeTaxOtherExpense)
            }
            "AssetFixedAssetComputers" => Ok(AccountType::AssetFixedAssetComputers),
            "EquityOpeningBalanceEquity" => Ok(AccountType::EquityOpeningBalanceEquity),
            "EquityInvestmentGrants" => Ok(AccountType::EquityInvestmentGrants),
            "AssetFixedAssetPhone" => Ok(AccountType::AssetFixedAssetPhone),
            "CostOfGoodsSold" => Ok(AccountType::CostOfGoodsSold),
            "OtherCurrentLiabilityDividendsPayable" => {
                Ok(AccountType::OtherCurrentLiabilityDividendsPayable)
            }
            "LiabilityStaffAndRelatedLongTermLiabilityAccounts" => {
                Ok(AccountType::LiabilityStaffAndRelatedLongTermLiabilityAccounts)
            }
            "ExpenseCostOfLabor" => Ok(AccountType::ExpenseCostOfLabor),
            "OtherCurrentLiabilityPayrollTaxPayable" => {
                Ok(AccountType::OtherCurrentLiabilityPayrollTaxPayable)
            }
            "OtherCurrentLiabilityAccruedLiabilities" => {
                Ok(AccountType::OtherCurrentLiabilityAccruedLiabilities)
            }
            "OtherCurrentLiabilityInsurancePayable" => {
                Ok(AccountType::OtherCurrentLiabilityInsurancePayable)
            }
            "OtherCurrentLiabilitySundryDebtorsAndCreditors" => {
                Ok(AccountType::OtherCurrentLiabilitySundryDebtorsAndCreditors)
            }
            "OtherCurrentLiabilityTradeAndOtherPayables" => {
                Ok(AccountType::OtherCurrentLiabilityTradeAndOtherPayables)
            }
            "OtherExpenseOtherHomeOfficeExpenses" => {
                Ok(AccountType::OtherExpenseOtherHomeOfficeExpenses)
            }
            "OtherCurrentLiabilityOtherCurrentLiabilities" => {
                Ok(AccountType::OtherCurrentLiabilityOtherCurrentLiabilities)
            }
            "AssetLand" => Ok(AccountType::AssetLand),
            "OtherExpenseExceptionalItems" => {
                Ok(AccountType::OtherExpenseExceptionalItems)
            }
            "AssetCumulativeDepreciationOnIntangibleAssets" => {
                Ok(AccountType::AssetCumulativeDepreciationOnIntangibleAssets)
            }
            "AssetOtherEarMarkedBankAccounts" => {
                Ok(AccountType::AssetOtherEarMarkedBankAccounts)
            }
            "RevenueOtherCurrentOperatingIncome" => {
                Ok(AccountType::RevenueOtherCurrentOperatingIncome)
            }
            "AssetOtherConsumables" => Ok(AccountType::AssetOtherConsumables),
            "OtherExpenseAmortization" => Ok(AccountType::OtherExpenseAmortization),
            "OtherExpenseDeferredTaxExpense" => {
                Ok(AccountType::OtherExpenseDeferredTaxExpense)
            }
            "OtherExpenseVehicleLease" => Ok(AccountType::OtherExpenseVehicleLease),
            "AssetIntangibleAssetsUnderDevelopment" => {
                Ok(AccountType::AssetIntangibleAssetsUnderDevelopment)
            }
            "CostOfGoodsSoldShippingFreightDeliveryCos" => {
                Ok(AccountType::CostOfGoodsSoldShippingFreightDeliveryCos)
            }
            "LiabilityAccountsPayable" => Ok(AccountType::LiabilityAccountsPayable),
            "LiabilityAccruedVacationPayable" => {
                Ok(AccountType::LiabilityAccruedVacationPayable)
            }
            "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise" => {
                Ok(AccountType::LiabilityOutstandingDuesOtherThanMicroSmallEnterprise)
            }
            "ExpenseUnappliedCashBillPaymentExpense" => {
                Ok(AccountType::ExpenseUnappliedCashBillPaymentExpense)
            }
            "AssetFixedAssetPhotoVideo" => Ok(AccountType::AssetFixedAssetPhotoVideo),
            "OtherExpenseRepairsAndMaintenance" => {
                Ok(AccountType::OtherExpenseRepairsAndMaintenance)
            }
            "AssetBalWithGovtAuthorities" => Ok(AccountType::AssetBalWithGovtAuthorities),
            "AssetRetainage" => Ok(AccountType::AssetRetainage),
            "OtherExpenseWashAndRoadServices" => {
                Ok(AccountType::OtherExpenseWashAndRoadServices)
            }
            "AssetInvestmentMortgageRealEstateLoans" => {
                Ok(AccountType::AssetInvestmentMortgageRealEstateLoans)
            }
            "OtherExpenseRentAndLease" => Ok(AccountType::OtherExpenseRentAndLease),
            "ExpenseSuppliesMaterials" => Ok(AccountType::ExpenseSuppliesMaterials),
            "AssetEmployeeCashAdvances" => Ok(AccountType::AssetEmployeeCashAdvances),
            "OtherExpenseUtilities" => Ok(AccountType::OtherExpenseUtilities),
            "OtherIncomeGainLossOnSaleOfInvestments" => {
                Ok(AccountType::OtherIncomeGainLossOnSaleOfInvestments)
            }
            "EquityRetainedEarnings" => Ok(AccountType::EquityRetainedEarnings),
            "EquityOtherFreeReserves" => Ok(AccountType::EquityOtherFreeReserves),
            "AssetPrepaymentsAndAccruedIncome" => {
                Ok(AccountType::AssetPrepaymentsAndAccruedIncome)
            }
            "OtherCurrentLiabilityGlobalTaxSuspense" => {
                Ok(AccountType::OtherCurrentLiabilityGlobalTaxSuspense)
            }
            "AssetAssetsInCourseOfConstruction" => {
                Ok(AccountType::AssetAssetsInCourseOfConstruction)
            }
            "EquityAccumulatedOtherComprehensiveIncome" => {
                Ok(AccountType::EquityAccumulatedOtherComprehensiveIncome)
            }
            "RevenueCashReceiptIncome" => Ok(AccountType::RevenueCashReceiptIncome),
            "RevenueSalesOfProductIncome" => Ok(AccountType::RevenueSalesOfProductIncome),
            "AssetLongTermInvestments" => Ok(AccountType::AssetLongTermInvestments),
            "OtherCurrentLiabilityRentsInTrustLiability" => {
                Ok(AccountType::OtherCurrentLiabilityRentsInTrustLiability)
            }
            "AssetCapitalWip" => Ok(AccountType::AssetCapitalWip),
            "AssetFixedAsset" => Ok(AccountType::AssetFixedAsset),
            "AssetLoansToOthers" => Ok(AccountType::AssetLoansToOthers),
            "OtherCurrentLiabilityCurrentTaxLiability" => {
                Ok(AccountType::OtherCurrentLiabilityCurrentTaxLiability)
            }
            "AssetRentsHeldInTrust" => Ok(AccountType::AssetRentsHeldInTrust),
            "OtherExpenseOtherVehicleExpenses" => {
                Ok(AccountType::OtherExpenseOtherVehicleExpenses)
            }
            "AssetDeferredTax" => Ok(AccountType::AssetDeferredTax),
            "AssetPrepaidExpenses" => Ok(AccountType::AssetPrepaidExpenses),
            "RevenueOwnWorkCapitalized" => Ok(AccountType::RevenueOwnWorkCapitalized),
            "LiabilityLiabilitiesRelatedToAssetsHeldForSale" => {
                Ok(AccountType::LiabilityLiabilitiesRelatedToAssetsHeldForSale)
            }
            "OtherExpenseParkingAndTolls" => Ok(AccountType::OtherExpenseParkingAndTolls),
            "ExpenseBorrowingCost" => Ok(AccountType::ExpenseBorrowingCost),
            "OtherExpenseVehicleRegistration" => {
                Ok(AccountType::OtherExpenseVehicleRegistration)
            }
            "OtherCurrentLiabilitySalesTaxPayable" => {
                Ok(AccountType::OtherCurrentLiabilitySalesTaxPayable)
            }
            "AssetProvisionsCurrentAssets" => {
                Ok(AccountType::AssetProvisionsCurrentAssets)
            }
            "ExpenseOtherRentalCosts" => Ok(AccountType::ExpenseOtherRentalCosts),
            "LiabilityLongTermBorrowings" => Ok(AccountType::LiabilityLongTermBorrowings),
            "OtherCurrentLiabilityShortTermBorrowings" => {
                Ok(AccountType::OtherCurrentLiabilityShortTermBorrowings)
            }
            "OtherCurrentLiabilityInterestPayables" => {
                Ok(AccountType::OtherCurrentLiabilityInterestPayables)
            }
            "OtherCurrentLiabilitySocialSecurityAgencies" => {
                Ok(AccountType::OtherCurrentLiabilitySocialSecurityAgencies)
            }
            "CostOfGoodsSoldCostOfLaborCos" => {
                Ok(AccountType::CostOfGoodsSoldCostOfLaborCos)
            }
            "EquityEquityInEarningsOfSubsidiuaries" => {
                Ok(AccountType::EquityEquityInEarningsOfSubsidiuaries)
            }
            "OtherExpenseGasAndFuel" => Ok(AccountType::OtherExpenseGasAndFuel),
            "OtherExpense" => Ok(AccountType::OtherExpense),
            "OtherIncomeOtherMiscellaneousIncome" => {
                Ok(AccountType::OtherIncomeOtherMiscellaneousIncome)
            }
            "AssetGoodwill" => Ok(AccountType::AssetGoodwill),
            "AssetLicenses" => Ok(AccountType::AssetLicenses),
            "OtherCurrentLiabilityStateLocalIncomeTaxPayable" => {
                Ok(AccountType::OtherCurrentLiabilityStateLocalIncomeTaxPayable)
            }
            "ExpenseGlobalTaxExpense" => Ok(AccountType::ExpenseGlobalTaxExpense),
            "OtherCurrentLiabilityProvisionForWarrantyObligations" => {
                Ok(AccountType::OtherCurrentLiabilityProvisionForWarrantyObligations)
            }
            "EquityFunds" => Ok(AccountType::EquityFunds),
            "OtherExpenseHomeOffice" => Ok(AccountType::OtherExpenseHomeOffice),
            "AssetProvisionsNonCurrentAssets" => {
                Ok(AccountType::AssetProvisionsNonCurrentAssets)
            }
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "AccountType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for AccountType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            AccountType::OtherCurrentLiabilityPrepaidExpensesPayable => {
                "OtherCurrentLiabilityPrepaidExpensesPayable"
            }
            AccountType::ExpenseOtherSellingExpenses => "ExpenseOtherSellingExpenses",
            AccountType::RevenueServiceFeeIncome => "RevenueServiceFeeIncome",
            AccountType::RevenueRevenueGeneral => "RevenueRevenueGeneral",
            AccountType::OtherExpenseExtraordinaryItems => {
                "OtherExpenseExtraordinaryItems"
            }
            AccountType::AssetAccumulatedDepletion => "AssetAccumulatedDepletion",
            AccountType::EquityDividendDisbursed => "EquityDividendDisbursed",
            AccountType::ExpenseEntertainment => "ExpenseEntertainment",
            AccountType::OtherIncomeLossOnDisposalOfAssets => {
                "OtherIncomeLossOnDisposalOfAssets"
            }
            AccountType::AssetFixedAssetOtherToolsEquipment => {
                "AssetFixedAssetOtherToolsEquipment"
            }
            AccountType::ExpenseInterestPaid => "ExpenseInterestPaid",
            AccountType::AssetCalledUpShareCapitalNotPaid => {
                "AssetCalledUpShareCapitalNotPaid"
            }
            AccountType::ExpenseBadDebts => "ExpenseBadDebts",
            AccountType::AssetCashAndCashEquivalents => "AssetCashAndCashEquivalents",
            AccountType::ExpenseShippingFreightDelivery => {
                "ExpenseShippingFreightDelivery"
            }
            AccountType::ExpenseIncomeTaxExpense => "ExpenseIncomeTaxExpense",
            AccountType::OtherIncomeOtherInvestmentIncome => {
                "OtherIncomeOtherInvestmentIncome"
            }
            AccountType::AssetAllowanceForBadDebts => "AssetAllowanceForBadDebts",
            AccountType::ExpenseRepairMaintenance => "ExpenseRepairMaintenance",
            AccountType::Asset => "Asset",
            AccountType::ExpenseProjectStudiesSurveysAssessments => {
                "ExpenseProjectStudiesSurveysAssessments"
            }
            AccountType::RevenueDiscountsRefundsGiven => "RevenueDiscountsRefundsGiven",
            AccountType::AssetShortTermInvestmentsInRelatedParties => {
                "AssetShortTermInvestmentsInRelatedParties"
            }
            AccountType::EquityPreferredStock => "EquityPreferredStock",
            AccountType::ExpenseOtherCurrentOperatingCharges => {
                "ExpenseOtherCurrentOperatingCharges"
            }
            AccountType::OtherExpenseMatCredit => "OtherExpenseMatCredit",
            AccountType::OtherExpenseHomeOwnerRentalInsurance => {
                "OtherExpenseHomeOwnerRentalInsurance"
            }
            AccountType::OtherIncomeDividendIncome => "OtherIncomeDividendIncome",
            AccountType::OtherIncomeUnrealisedLossOnSecuritiesNetOfTax => {
                "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax"
            }
            AccountType::ExpenseOtherExternalServices => "ExpenseOtherExternalServices",
            AccountType::AssetChecking => "AssetChecking",
            AccountType::AssetFixedAssetSoftware => "AssetFixedAssetSoftware",
            AccountType::AssetShortTermLoansAndAdvancesToRelatedParties => {
                "AssetShortTermLoansAndAdvancesToRelatedParties"
            }
            AccountType::ExpenseCharitableContributions => {
                "ExpenseCharitableContributions"
            }
            AccountType::ExpenseManagementCompensation => "ExpenseManagementCompensation",
            AccountType::OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations => {
                "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations"
            }
            AccountType::OtherCurrentLiabilityGlobalTaxPayable => {
                "OtherCurrentLiabilityGlobalTaxPayable"
            }
            AccountType::AssetNonCurrentAssets => "AssetNonCurrentAssets",
            AccountType::ExpenseDuesSubscriptions => "ExpenseDuesSubscriptions",
            AccountType::AssetAssetsHeldForSale => "AssetAssetsHeldForSale",
            AccountType::AssetFixedAssetFurniture => "AssetFixedAssetFurniture",
            AccountType::ExpenseEntertainmentMeals => "ExpenseEntertainmentMeals",
            AccountType::ExpensePayrollExpenses => "ExpensePayrollExpenses",
            AccountType::LiabilityGroupAndAssociates => "LiabilityGroupAndAssociates",
            AccountType::RevenueSalesRetail => "RevenueSalesRetail",
            AccountType::AssetFixedAssetCopiers => "AssetFixedAssetCopiers",
            AccountType::ExpenseAdvertisingPromotional => "ExpenseAdvertisingPromotional",
            AccountType::ExpenseBankCharges => "ExpenseBankCharges",
            AccountType::AssetParticipatingInterests => "AssetParticipatingInterests",
            AccountType::ExpenseTravelExpensesSellingExpense => {
                "ExpenseTravelExpensesSellingExpense"
            }
            AccountType::CostOfGoodsSoldSuppliesMaterialsCogs => {
                "CostOfGoodsSoldSuppliesMaterialsCogs"
            }
            AccountType::AssetSecurityDeposits => "AssetSecurityDeposits",
            AccountType::ExpenseSundry => "ExpenseSundry",
            AccountType::OtherExpenseVehicleInsurance => "OtherExpenseVehicleInsurance",
            AccountType::EquityPaidInCapitalOrSurplus => "EquityPaidInCapitalOrSurplus",
            AccountType::OtherCurrentLiabilityLoanPayable => {
                "OtherCurrentLiabilityLoanPayable"
            }
            AccountType::AssetInventory => "AssetInventory",
            AccountType::AssetOtherLongTermInvestments => "AssetOtherLongTermInvestments",
            AccountType::CostOfGoodsSoldOtherCostsOfServiceCos => {
                "CostOfGoodsSoldOtherCostsOfServiceCos"
            }
            AccountType::AccountsReceivable => "AccountsReceivable",
            AccountType::EquityCommonStock => "EquityCommonStock",
            AccountType::ExpenseInsurance => "ExpenseInsurance",
            AccountType::LiabilityLongTermDebit => "LiabilityLongTermDebit",
            AccountType::LiabilityProvisionsNonCurrentLiabilities => {
                "LiabilityProvisionsNonCurrentLiabilities"
            }
            AccountType::AssetAssetsAvailableForSale => "AssetAssetsAvailableForSale",
            AccountType::ExpenseAppropriationsToDepreciation => {
                "ExpenseAppropriationsToDepreciation"
            }
            AccountType::ExpenseOfficeExpenses => "ExpenseOfficeExpenses",
            AccountType::LiabilityLongTermLiability => "LiabilityLongTermLiability",
            AccountType::OtherExpensePenaltiesSettlements => {
                "OtherExpensePenaltiesSettlements"
            }
            AccountType::EquityShareApplicationMoneyPendingAllotment => {
                "EquityShareApplicationMoneyPendingAllotment"
            }
            AccountType::AssetOtherCurrentAsset => "AssetOtherCurrentAsset",
            AccountType::AssetVehicles => "AssetVehicles",
            AccountType::AssetOtherAsset => "AssetOtherAsset",
            AccountType::ExpenseUtilities => "ExpenseUtilities",
            AccountType::ExpenseFinanceCosts => "ExpenseFinanceCosts",
            AccountType::OtherIncomeGainLossOnSaleOfFixedAssets => {
                "OtherIncomeGainLossOnSaleOfFixedAssets"
            }
            AccountType::OtherExpenseDepletion => "OtherExpenseDepletion",
            AccountType::Equity => "Equity",
            AccountType::EquityCapitalReserves => "EquityCapitalReserves",
            AccountType::OtherCurrentLiabilityProvisionsCurrentLiabilities => {
                "OtherCurrentLiabilityProvisionsCurrentLiabilities"
            }
            AccountType::OtherCurrentLiability => "OtherCurrentLiability",
            AccountType::AssetTrustAccounts => "AssetTrustAccounts",
            AccountType::AssetSavings => "AssetSavings",
            AccountType::RevenueOperatingGrants => "RevenueOperatingGrants",
            AccountType::ExpenseRentOrLeaseOfBuildings => "ExpenseRentOrLeaseOfBuildings",
            AccountType::RevenueNonProfitIncome => "RevenueNonProfitIncome",
            AccountType::OtherCurrentLiabilityPayrollClearing => {
                "OtherCurrentLiabilityPayrollClearing"
            }
            AccountType::ExpenseDistributionCosts => "ExpenseDistributionCosts",
            AccountType::OtherCurrentLiabilityDutiesAndTaxes => {
                "OtherCurrentLiabilityDutiesAndTaxes"
            }
            AccountType::AssetMoneyMarket => "AssetMoneyMarket",
            AccountType::AssetAvailableForSaleFinancialAssets => {
                "AssetAvailableForSaleFinancialAssets"
            }
            AccountType::ExpenseEquipmentRental => "ExpenseEquipmentRental",
            AccountType::Income => "Income",
            AccountType::OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases => {
                "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases"
            }
            AccountType::EquityPartnerDistributions => "EquityPartnerDistributions",
            AccountType::AssetBuildings => "AssetBuildings",
            AccountType::ExpenseOtherBusinessExpenses => "ExpenseOtherBusinessExpenses",
            AccountType::OtherCurrentLiabilityDirectDepositPayable => {
                "OtherCurrentLiabilityDirectDepositPayable"
            }
            AccountType::LiabilityShareholderNotesPayable => {
                "LiabilityShareholderNotesPayable"
            }
            AccountType::ExpensePurchasesRebates => "ExpensePurchasesRebates",
            AccountType::AssetTradeAndOtherReceivables => "AssetTradeAndOtherReceivables",
            AccountType::AssetInvestmentUsGovernmentObligations => {
                "AssetInvestmentUsGovernmentObligations"
            }
            AccountType::EquityPartnersEquity => "EquityPartnersEquity",
            AccountType::Expense => "Expense",
            AccountType::LiabilityGovernmentAndOtherPublicAuthorities => {
                "LiabilityGovernmentAndOtherPublicAuthorities"
            }
            AccountType::AssetGlobalTaxDeferred => "AssetGlobalTaxDeferred",
            AccountType::AssetAccumulatedAmortizationOfOtherAssets => {
                "AssetAccumulatedAmortizationOfOtherAssets"
            }
            AccountType::AssetDepletableAssets => "AssetDepletableAssets",
            AccountType::AssetMachineryAndEquipment => "AssetMachineryAndEquipment",
            AccountType::LiabilityNotesPayable => "LiabilityNotesPayable",
            AccountType::OtherCurrentLiabilityFederalIncomeTaxPayable => {
                "OtherCurrentLiabilityFederalIncomeTaxPayable"
            }
            AccountType::EquityMoneyReceivedAgainstShareWarrants => {
                "EquityMoneyReceivedAgainstShareWarrants"
            }
            AccountType::OtherExpensePriorPeriodItems => "OtherExpensePriorPeriodItems",
            AccountType::OtherExpenseTaxRoundoffGainOrLoss => {
                "OtherExpenseTaxRoundoffGainOrLoss"
            }
            AccountType::AssetOtherLongTermAssets => "AssetOtherLongTermAssets",
            AccountType::OtherExpenseVehicleRepairs => "OtherExpenseVehicleRepairs",
            AccountType::AssetLandAsset => "AssetLandAsset",
            AccountType::ExpenseStaffCosts => "ExpenseStaffCosts",
            AccountType::RevenueOtherPrimaryIncome => "RevenueOtherPrimaryIncome",
            AccountType::OtherExpenseExchangeGainOrLoss => {
                "OtherExpenseExchangeGainOrLoss"
            }
            AccountType::ExpenseTravel => "ExpenseTravel",
            AccountType::AssetInvestments => "AssetInvestments",
            AccountType::ExpensePromotionalMeals => "ExpensePromotionalMeals",
            AccountType::LiabilityAccruedLongTermLiabilities => {
                "LiabilityAccruedLongTermLiabilities"
            }
            AccountType::LiabilityLongTermEmployeeBenefitObligations => {
                "LiabilityLongTermEmployeeBenefitObligations"
            }
            AccountType::OtherExpenseVehicle => "OtherExpenseVehicle",
            AccountType::AssetLoansToStockholders => "AssetLoansToStockholders",
            AccountType::EquityOwnersEquity => "EquityOwnersEquity",
            AccountType::OtherCurrentLiabilityTrustAccountsLiabilities => {
                "OtherCurrentLiabilityTrustAccountsLiabilities"
            }
            AccountType::OtherExpenseOtherMiscellaneousExpense => {
                "OtherExpenseOtherMiscellaneousExpense"
            }
            AccountType::EquityPartnerContributions => "EquityPartnerContributions",
            AccountType::AssetLoansToOfficers => "AssetLoansToOfficers",
            AccountType::ExpenseExtraordinaryCharges => "ExpenseExtraordinaryCharges",
            AccountType::AssetOtherCurrentAssets => "AssetOtherCurrentAssets",
            AccountType::ExpenseTravelExpensesGeneralAndAdminExpenses => {
                "ExpenseTravelExpensesGeneralAndAdminExpenses"
            }
            AccountType::EquityTreasuryStock => "EquityTreasuryStock",
            AccountType::OtherExpenseVehicleLoan => "OtherExpenseVehicleLoan",
            AccountType::AssetDevelopmentCosts => "AssetDevelopmentCosts",
            AccountType::ExpenseAmortizationExpense => "ExpenseAmortizationExpense",
            AccountType::EquityEstimatedTaxes => "EquityEstimatedTaxes",
            AccountType::LiabilityBankLoans => "LiabilityBankLoans",
            AccountType::AssetLeaseholdImprovements => "AssetLeaseholdImprovements",
            AccountType::AssetIntangibleAssets => "AssetIntangibleAssets",
            AccountType::AssetOtherFixedAssets => "AssetOtherFixedAssets",
            AccountType::ExpenseOfficeGeneralAdministrativeExpenses => {
                "ExpenseOfficeGeneralAdministrativeExpenses"
            }
            AccountType::AssetGlobalTaxRefund => "AssetGlobalTaxRefund",
            AccountType::OtherIncomeInterestEarned => "OtherIncomeInterestEarned",
            AccountType::OtherIncomeTaxExemptInterest => "OtherIncomeTaxExemptInterest",
            AccountType::CostOfGoodsSoldCostOfSales => "CostOfGoodsSoldCostOfSales",
            AccountType::OtherExpenseDepreciation => "OtherExpenseDepreciation",
            AccountType::OtherExpenseVehicleLoanInterest => {
                "OtherExpenseVehicleLoanInterest"
            }
            AccountType::OtherCurrentLiabilityLineOfCredit => {
                "OtherCurrentLiabilityLineOfCredit"
            }
            AccountType::ExpenseLegalProfessionalFees => "ExpenseLegalProfessionalFees",
            AccountType::EquityHealthcare => "EquityHealthcare",
            AccountType::EquityShareCapital => "EquityShareCapital",
            AccountType::AssetAccumulatedDepreciation => "AssetAccumulatedDepreciation",
            AccountType::ExpenseAuto => "ExpenseAuto",
            AccountType::Liability => "Liability",
            AccountType::AssetLeaseBuyout => "AssetLeaseBuyout",
            AccountType::AssetUndepositedFunds => "AssetUndepositedFunds",
            AccountType::EquityPersonalExpense => "EquityPersonalExpense",
            AccountType::EquityPersonalIncome => "EquityPersonalIncome",
            AccountType::AssetOtherLongTermLoansAndAdvances => {
                "AssetOtherLongTermLoansAndAdvances"
            }
            AccountType::ExpenseCommissionsAndFees => "ExpenseCommissionsAndFees",
            AccountType::LiabilityCreditCard => "LiabilityCreditCard",
            AccountType::EquityCalledUpShareCapital => "EquityCalledUpShareCapital",
            AccountType::AssetAccumulatedAmortization => "AssetAccumulatedAmortization",
            AccountType::AssetOtherIntangibleAssets => "AssetOtherIntangibleAssets",
            AccountType::ExpenseTravelMeals => "ExpenseTravelMeals",
            AccountType::ExpenseShippingAndDeliveryExpense => {
                "ExpenseShippingAndDeliveryExpense"
            }
            AccountType::AssetBank => "AssetBank",
            AccountType::ExpenseTaxesPaid => "ExpenseTaxesPaid",
            AccountType::AssetInternalTransfers => "AssetInternalTransfers",
            AccountType::LiabilityDebtsRelatedToParticipatingInterests => {
                "LiabilityDebtsRelatedToParticipatingInterests"
            }
            AccountType::ExpensePenaltiesSettlements => "ExpensePenaltiesSettlements",
            AccountType::RevenueIncome => "RevenueIncome",
            AccountType::LiabilityOtherLongTermProvisions => {
                "LiabilityOtherLongTermProvisions"
            }
            AccountType::OtherCurrentLiabilityCurrentLiabilities => {
                "OtherCurrentLiabilityCurrentLiabilities"
            }
            AccountType::LiabilityAccrualsAndDeferredIncome => {
                "LiabilityAccrualsAndDeferredIncome"
            }
            AccountType::OtherIncome => "OtherIncome",
            AccountType::CostOfGoodsSoldEquipmentRentalCos => {
                "CostOfGoodsSoldEquipmentRentalCos"
            }
            AccountType::AssetInvestmentOther => "AssetInvestmentOther",
            AccountType::AssetInvestmentTaxExemptSecurities => {
                "AssetInvestmentTaxExemptSecurities"
            }
            AccountType::ExpenseExternalServices => "ExpenseExternalServices",
            AccountType::LiabilityOtherLongTermLiabilities => {
                "LiabilityOtherLongTermLiabilities"
            }
            AccountType::AssetCashOnHand => "AssetCashOnHand",
            AccountType::LiabilityProvisionForLiabilities => {
                "LiabilityProvisionForLiabilities"
            }
            AccountType::ExpenseLossOnDiscontinuedOperationsNetOfTax => {
                "ExpenseLossOnDiscontinuedOperationsNetOfTax"
            }
            AccountType::RevenueSalesWholesale => "RevenueSalesWholesale",
            AccountType::OtherIncomeOtherOperatingIncome => {
                "OtherIncomeOtherOperatingIncome"
            }
            AccountType::OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts => {
                "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts"
            }
            AccountType::AssetProvisionsFixedAssets => "AssetProvisionsFixedAssets",
            AccountType::CostOfGoodsSoldFreightAndDeliveryCost => {
                "CostOfGoodsSoldFreightAndDeliveryCost"
            }
            AccountType::EquityAccumulatedAdjustment => "EquityAccumulatedAdjustment",
            AccountType::AssetOrganizationalCosts => "AssetOrganizationalCosts",
            AccountType::ExpenseOtherMiscellaneousServiceCost => {
                "ExpenseOtherMiscellaneousServiceCost"
            }
            AccountType::LiabilityObligationsUnderFinanceLeases => {
                "LiabilityObligationsUnderFinanceLeases"
            }
            AccountType::OtherExpenseMortgageInterest => "OtherExpenseMortgageInterest",
            AccountType::AssetLongTermLoansAndAdvancesToRelatedParties => {
                "AssetLongTermLoansAndAdvancesToRelatedParties"
            }
            AccountType::AssetExpenditureAuthorisationsAndLettersOfCredit => {
                "AssetExpenditureAuthorisationsAndLettersOfCredit"
            }
            AccountType::AssetFurnitureAndFixtures => "AssetFurnitureAndFixtures",
            AccountType::LiabilityDeferredTaxLiabilities => {
                "LiabilityDeferredTaxLiabilities"
            }
            AccountType::RevenueSavingsByTaxScheme => "RevenueSavingsByTaxScheme",
            AccountType::RevenueUnappliedCashPaymentIncome => {
                "RevenueUnappliedCashPaymentIncome"
            }
            AccountType::LiabilityOutstandingDuesMicroSmallEnterprise => {
                "LiabilityOutstandingDuesMicroSmallEnterprise"
            }
            AccountType::OtherExpenseIncomeTaxOtherExpense => {
                "OtherExpenseIncomeTaxOtherExpense"
            }
            AccountType::AssetFixedAssetComputers => "AssetFixedAssetComputers",
            AccountType::EquityOpeningBalanceEquity => "EquityOpeningBalanceEquity",
            AccountType::EquityInvestmentGrants => "EquityInvestmentGrants",
            AccountType::AssetFixedAssetPhone => "AssetFixedAssetPhone",
            AccountType::CostOfGoodsSold => "CostOfGoodsSold",
            AccountType::OtherCurrentLiabilityDividendsPayable => {
                "OtherCurrentLiabilityDividendsPayable"
            }
            AccountType::LiabilityStaffAndRelatedLongTermLiabilityAccounts => {
                "LiabilityStaffAndRelatedLongTermLiabilityAccounts"
            }
            AccountType::ExpenseCostOfLabor => "ExpenseCostOfLabor",
            AccountType::OtherCurrentLiabilityPayrollTaxPayable => {
                "OtherCurrentLiabilityPayrollTaxPayable"
            }
            AccountType::OtherCurrentLiabilityAccruedLiabilities => {
                "OtherCurrentLiabilityAccruedLiabilities"
            }
            AccountType::OtherCurrentLiabilityInsurancePayable => {
                "OtherCurrentLiabilityInsurancePayable"
            }
            AccountType::OtherCurrentLiabilitySundryDebtorsAndCreditors => {
                "OtherCurrentLiabilitySundryDebtorsAndCreditors"
            }
            AccountType::OtherCurrentLiabilityTradeAndOtherPayables => {
                "OtherCurrentLiabilityTradeAndOtherPayables"
            }
            AccountType::OtherExpenseOtherHomeOfficeExpenses => {
                "OtherExpenseOtherHomeOfficeExpenses"
            }
            AccountType::OtherCurrentLiabilityOtherCurrentLiabilities => {
                "OtherCurrentLiabilityOtherCurrentLiabilities"
            }
            AccountType::AssetLand => "AssetLand",
            AccountType::OtherExpenseExceptionalItems => "OtherExpenseExceptionalItems",
            AccountType::AssetCumulativeDepreciationOnIntangibleAssets => {
                "AssetCumulativeDepreciationOnIntangibleAssets"
            }
            AccountType::AssetOtherEarMarkedBankAccounts => {
                "AssetOtherEarMarkedBankAccounts"
            }
            AccountType::RevenueOtherCurrentOperatingIncome => {
                "RevenueOtherCurrentOperatingIncome"
            }
            AccountType::AssetOtherConsumables => "AssetOtherConsumables",
            AccountType::OtherExpenseAmortization => "OtherExpenseAmortization",
            AccountType::OtherExpenseDeferredTaxExpense => {
                "OtherExpenseDeferredTaxExpense"
            }
            AccountType::OtherExpenseVehicleLease => "OtherExpenseVehicleLease",
            AccountType::AssetIntangibleAssetsUnderDevelopment => {
                "AssetIntangibleAssetsUnderDevelopment"
            }
            AccountType::CostOfGoodsSoldShippingFreightDeliveryCos => {
                "CostOfGoodsSoldShippingFreightDeliveryCos"
            }
            AccountType::LiabilityAccountsPayable => "LiabilityAccountsPayable",
            AccountType::LiabilityAccruedVacationPayable => {
                "LiabilityAccruedVacationPayable"
            }
            AccountType::LiabilityOutstandingDuesOtherThanMicroSmallEnterprise => {
                "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise"
            }
            AccountType::ExpenseUnappliedCashBillPaymentExpense => {
                "ExpenseUnappliedCashBillPaymentExpense"
            }
            AccountType::AssetFixedAssetPhotoVideo => "AssetFixedAssetPhotoVideo",
            AccountType::OtherExpenseRepairsAndMaintenance => {
                "OtherExpenseRepairsAndMaintenance"
            }
            AccountType::AssetBalWithGovtAuthorities => "AssetBalWithGovtAuthorities",
            AccountType::AssetRetainage => "AssetRetainage",
            AccountType::OtherExpenseWashAndRoadServices => {
                "OtherExpenseWashAndRoadServices"
            }
            AccountType::AssetInvestmentMortgageRealEstateLoans => {
                "AssetInvestmentMortgageRealEstateLoans"
            }
            AccountType::OtherExpenseRentAndLease => "OtherExpenseRentAndLease",
            AccountType::ExpenseSuppliesMaterials => "ExpenseSuppliesMaterials",
            AccountType::AssetEmployeeCashAdvances => "AssetEmployeeCashAdvances",
            AccountType::OtherExpenseUtilities => "OtherExpenseUtilities",
            AccountType::OtherIncomeGainLossOnSaleOfInvestments => {
                "OtherIncomeGainLossOnSaleOfInvestments"
            }
            AccountType::EquityRetainedEarnings => "EquityRetainedEarnings",
            AccountType::EquityOtherFreeReserves => "EquityOtherFreeReserves",
            AccountType::AssetPrepaymentsAndAccruedIncome => {
                "AssetPrepaymentsAndAccruedIncome"
            }
            AccountType::OtherCurrentLiabilityGlobalTaxSuspense => {
                "OtherCurrentLiabilityGlobalTaxSuspense"
            }
            AccountType::AssetAssetsInCourseOfConstruction => {
                "AssetAssetsInCourseOfConstruction"
            }
            AccountType::EquityAccumulatedOtherComprehensiveIncome => {
                "EquityAccumulatedOtherComprehensiveIncome"
            }
            AccountType::RevenueCashReceiptIncome => "RevenueCashReceiptIncome",
            AccountType::RevenueSalesOfProductIncome => "RevenueSalesOfProductIncome",
            AccountType::AssetLongTermInvestments => "AssetLongTermInvestments",
            AccountType::OtherCurrentLiabilityRentsInTrustLiability => {
                "OtherCurrentLiabilityRentsInTrustLiability"
            }
            AccountType::AssetCapitalWip => "AssetCapitalWip",
            AccountType::AssetFixedAsset => "AssetFixedAsset",
            AccountType::AssetLoansToOthers => "AssetLoansToOthers",
            AccountType::OtherCurrentLiabilityCurrentTaxLiability => {
                "OtherCurrentLiabilityCurrentTaxLiability"
            }
            AccountType::AssetRentsHeldInTrust => "AssetRentsHeldInTrust",
            AccountType::OtherExpenseOtherVehicleExpenses => {
                "OtherExpenseOtherVehicleExpenses"
            }
            AccountType::AssetDeferredTax => "AssetDeferredTax",
            AccountType::AssetPrepaidExpenses => "AssetPrepaidExpenses",
            AccountType::RevenueOwnWorkCapitalized => "RevenueOwnWorkCapitalized",
            AccountType::LiabilityLiabilitiesRelatedToAssetsHeldForSale => {
                "LiabilityLiabilitiesRelatedToAssetsHeldForSale"
            }
            AccountType::OtherExpenseParkingAndTolls => "OtherExpenseParkingAndTolls",
            AccountType::ExpenseBorrowingCost => "ExpenseBorrowingCost",
            AccountType::OtherExpenseVehicleRegistration => {
                "OtherExpenseVehicleRegistration"
            }
            AccountType::OtherCurrentLiabilitySalesTaxPayable => {
                "OtherCurrentLiabilitySalesTaxPayable"
            }
            AccountType::AssetProvisionsCurrentAssets => "AssetProvisionsCurrentAssets",
            AccountType::ExpenseOtherRentalCosts => "ExpenseOtherRentalCosts",
            AccountType::LiabilityLongTermBorrowings => "LiabilityLongTermBorrowings",
            AccountType::OtherCurrentLiabilityShortTermBorrowings => {
                "OtherCurrentLiabilityShortTermBorrowings"
            }
            AccountType::OtherCurrentLiabilityInterestPayables => {
                "OtherCurrentLiabilityInterestPayables"
            }
            AccountType::OtherCurrentLiabilitySocialSecurityAgencies => {
                "OtherCurrentLiabilitySocialSecurityAgencies"
            }
            AccountType::CostOfGoodsSoldCostOfLaborCos => "CostOfGoodsSoldCostOfLaborCos",
            AccountType::EquityEquityInEarningsOfSubsidiuaries => {
                "EquityEquityInEarningsOfSubsidiuaries"
            }
            AccountType::OtherExpenseGasAndFuel => "OtherExpenseGasAndFuel",
            AccountType::OtherExpense => "OtherExpense",
            AccountType::OtherIncomeOtherMiscellaneousIncome => {
                "OtherIncomeOtherMiscellaneousIncome"
            }
            AccountType::AssetGoodwill => "AssetGoodwill",
            AccountType::AssetLicenses => "AssetLicenses",
            AccountType::OtherCurrentLiabilityStateLocalIncomeTaxPayable => {
                "OtherCurrentLiabilityStateLocalIncomeTaxPayable"
            }
            AccountType::ExpenseGlobalTaxExpense => "ExpenseGlobalTaxExpense",
            AccountType::OtherCurrentLiabilityProvisionForWarrantyObligations => {
                "OtherCurrentLiabilityProvisionForWarrantyObligations"
            }
            AccountType::EquityFunds => "EquityFunds",
            AccountType::OtherExpenseHomeOffice => "OtherExpenseHomeOffice",
            AccountType::AssetProvisionsNonCurrentAssets => {
                "AssetProvisionsNonCurrentAssets"
            }
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__AccountType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityPrepaidExpensesPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityPrepaidExpensesPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherSellingExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherSellingExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueServiceFeeIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueServiceFeeIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueRevenueGeneral\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueRevenueGeneral",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseExtraordinaryItems\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseExtraordinaryItems",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedDepletion\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedDepletion",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityDividendDisbursed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityDividendDisbursed",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseEntertainment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseEntertainment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeLossOnDisposalOfAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeLossOnDisposalOfAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetOtherToolsEquipment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetOtherToolsEquipment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseInterestPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseInterestPaid",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCalledUpShareCapitalNotPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCalledUpShareCapitalNotPaid",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseBadDebts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseBadDebts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCashAndCashEquivalents\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCashAndCashEquivalents",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseShippingFreightDelivery\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseShippingFreightDelivery",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseIncomeTaxExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseIncomeTaxExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeOtherInvestmentIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeOtherInvestmentIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAllowanceForBadDebts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAllowanceForBadDebts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseRepairMaintenance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseRepairMaintenance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Asset\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Asset")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseProjectStudiesSurveysAssessments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseProjectStudiesSurveysAssessments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueDiscountsRefundsGiven\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueDiscountsRefundsGiven",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetShortTermInvestmentsInRelatedParties\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetShortTermInvestmentsInRelatedParties",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPreferredStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPreferredStock",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherCurrentOperatingCharges\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherCurrentOperatingCharges",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseMatCredit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseMatCredit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseHomeOwnerRentalInsurance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseHomeOwnerRentalInsurance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeDividendIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeDividendIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherExternalServices\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherExternalServices",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetChecking\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetChecking")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetSoftware\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetSoftware",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetShortTermLoansAndAdvancesToRelatedParties\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetShortTermLoansAndAdvancesToRelatedParties",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseCharitableContributions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseCharitableContributions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseManagementCompensation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseManagementCompensation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityGlobalTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityGlobalTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetNonCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetNonCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseDuesSubscriptions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseDuesSubscriptions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAssetsHeldForSale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAssetsHeldForSale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetFurniture\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetFurniture",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseEntertainmentMeals\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseEntertainmentMeals",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePayrollExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePayrollExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityGroupAndAssociates\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityGroupAndAssociates",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSalesRetail\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSalesRetail",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetCopiers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetCopiers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAdvertisingPromotional\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseAdvertisingPromotional",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseBankCharges\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseBankCharges",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetParticipatingInterests\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetParticipatingInterests",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravelExpensesSellingExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTravelExpensesSellingExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldSuppliesMaterialsCogs\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldSuppliesMaterialsCogs",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetSecurityDeposits\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetSecurityDeposits",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseSundry\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExpenseSundry")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleInsurance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleInsurance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPaidInCapitalOrSurplus\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPaidInCapitalOrSurplus",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityLoanPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityLoanPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInventory\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetInventory")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherLongTermInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherLongTermInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldOtherCostsOfServiceCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldOtherCostsOfServiceCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AccountsReceivable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AccountsReceivable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityCommonStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityCommonStock",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseInsurance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseInsurance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermDebit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermDebit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityProvisionsNonCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityProvisionsNonCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAssetsAvailableForSale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAssetsAvailableForSale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAppropriationsToDepreciation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseAppropriationsToDepreciation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOfficeExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOfficeExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpensePenaltiesSettlements\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpensePenaltiesSettlements",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityShareApplicationMoneyPendingAllotment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityShareApplicationMoneyPendingAllotment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherCurrentAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherCurrentAsset",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetVehicles\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetVehicles")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherAsset",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseUtilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseUtilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseFinanceCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseFinanceCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeGainLossOnSaleOfFixedAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeGainLossOnSaleOfFixedAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseDepletion\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseDepletion",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Equity\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Equity")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityCapitalReserves\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityCapitalReserves",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityProvisionsCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityProvisionsCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetTrustAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetTrustAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetSavings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetSavings")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOperatingGrants\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOperatingGrants",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseRentOrLeaseOfBuildings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseRentOrLeaseOfBuildings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueNonProfitIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueNonProfitIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityPayrollClearing\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityPayrollClearing",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseDistributionCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseDistributionCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityDutiesAndTaxes\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityDutiesAndTaxes",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetMoneyMarket\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetMoneyMarket",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAvailableForSaleFinancialAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAvailableForSaleFinancialAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseEquipmentRental\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseEquipmentRental",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Income\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Income")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases\0"
                .as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPartnerDistributions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPartnerDistributions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetBuildings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetBuildings")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherBusinessExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherBusinessExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityDirectDepositPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityDirectDepositPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityShareholderNotesPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityShareholderNotesPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePurchasesRebates\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePurchasesRebates",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetTradeAndOtherReceivables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetTradeAndOtherReceivables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentUsGovernmentObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentUsGovernmentObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPartnersEquity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPartnersEquity",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Expense\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Expense")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityGovernmentAndOtherPublicAuthorities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityGovernmentAndOtherPublicAuthorities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetGlobalTaxDeferred\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetGlobalTaxDeferred",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedAmortizationOfOtherAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedAmortizationOfOtherAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetDepletableAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetDepletableAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetMachineryAndEquipment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetMachineryAndEquipment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityNotesPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityNotesPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityFederalIncomeTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityFederalIncomeTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityMoneyReceivedAgainstShareWarrants\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityMoneyReceivedAgainstShareWarrants",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpensePriorPeriodItems\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpensePriorPeriodItems",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseTaxRoundoffGainOrLoss\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseTaxRoundoffGainOrLoss",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherLongTermAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherLongTermAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleRepairs\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleRepairs",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLandAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetLandAsset")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseStaffCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseStaffCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOtherPrimaryIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOtherPrimaryIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseExchangeGainOrLoss\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseExchangeGainOrLoss",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravel\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExpenseTravel")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePromotionalMeals\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePromotionalMeals",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccruedLongTermLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccruedLongTermLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermEmployeeBenefitObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermEmployeeBenefitObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicle\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicle",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLoansToStockholders\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLoansToStockholders",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityOwnersEquity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityOwnersEquity",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityTrustAccountsLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityTrustAccountsLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseOtherMiscellaneousExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseOtherMiscellaneousExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPartnerContributions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPartnerContributions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLoansToOfficers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLoansToOfficers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseExtraordinaryCharges\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseExtraordinaryCharges",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravelExpensesGeneralAndAdminExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTravelExpensesGeneralAndAdminExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityTreasuryStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityTreasuryStock",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleLoan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleLoan",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetDevelopmentCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetDevelopmentCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAmortizationExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseAmortizationExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityEstimatedTaxes\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityEstimatedTaxes",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityBankLoans\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityBankLoans",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLeaseholdImprovements\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLeaseholdImprovements",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetIntangibleAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetIntangibleAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherFixedAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherFixedAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOfficeGeneralAdministrativeExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOfficeGeneralAdministrativeExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetGlobalTaxRefund\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetGlobalTaxRefund",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeInterestEarned\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeInterestEarned",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeTaxExemptInterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeTaxExemptInterest",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldCostOfSales\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldCostOfSales",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseDepreciation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseDepreciation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleLoanInterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleLoanInterest",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityLineOfCredit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityLineOfCredit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseLegalProfessionalFees\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseLegalProfessionalFees",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityHealthcare\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityHealthcare",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityShareCapital\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityShareCapital",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedDepreciation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedDepreciation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAuto\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExpenseAuto")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Liability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Liability")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLeaseBuyout\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLeaseBuyout",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetUndepositedFunds\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetUndepositedFunds",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPersonalExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPersonalExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPersonalIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPersonalIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherLongTermLoansAndAdvances\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherLongTermLoansAndAdvances",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseCommissionsAndFees\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseCommissionsAndFees",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityCreditCard\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityCreditCard",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityCalledUpShareCapital\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityCalledUpShareCapital",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedAmortization\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedAmortization",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherIntangibleAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherIntangibleAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravelMeals\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTravelMeals",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseShippingAndDeliveryExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseShippingAndDeliveryExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetBank\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetBank")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTaxesPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTaxesPaid",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInternalTransfers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInternalTransfers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityDebtsRelatedToParticipatingInterests\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityDebtsRelatedToParticipatingInterests",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePenaltiesSettlements\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePenaltiesSettlements",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RevenueIncome")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOtherLongTermProvisions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOtherLongTermProvisions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccrualsAndDeferredIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccrualsAndDeferredIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OtherIncome")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldEquipmentRentalCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldEquipmentRentalCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentOther\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentOther",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentTaxExemptSecurities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentTaxExemptSecurities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseExternalServices\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseExternalServices",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOtherLongTermLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOtherLongTermLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCashOnHand\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCashOnHand",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityProvisionForLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityProvisionForLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseLossOnDiscontinuedOperationsNetOfTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseLossOnDiscontinuedOperationsNetOfTax",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSalesWholesale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSalesWholesale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeOtherOperatingIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeOtherOperatingIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetProvisionsFixedAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetProvisionsFixedAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldFreightAndDeliveryCost\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldFreightAndDeliveryCost",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityAccumulatedAdjustment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityAccumulatedAdjustment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOrganizationalCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOrganizationalCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherMiscellaneousServiceCost\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherMiscellaneousServiceCost",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityObligationsUnderFinanceLeases\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityObligationsUnderFinanceLeases",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseMortgageInterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseMortgageInterest",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLongTermLoansAndAdvancesToRelatedParties\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLongTermLoansAndAdvancesToRelatedParties",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetExpenditureAuthorisationsAndLettersOfCredit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetExpenditureAuthorisationsAndLettersOfCredit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFurnitureAndFixtures\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFurnitureAndFixtures",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityDeferredTaxLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityDeferredTaxLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSavingsByTaxScheme\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSavingsByTaxScheme",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueUnappliedCashPaymentIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueUnappliedCashPaymentIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOutstandingDuesMicroSmallEnterprise\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOutstandingDuesMicroSmallEnterprise",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseIncomeTaxOtherExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseIncomeTaxOtherExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetComputers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetComputers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityOpeningBalanceEquity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityOpeningBalanceEquity",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityInvestmentGrants\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityInvestmentGrants",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetPhone\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetPhone",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSold\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSold",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityDividendsPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityDividendsPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityStaffAndRelatedLongTermLiabilityAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityStaffAndRelatedLongTermLiabilityAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseCostOfLabor\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseCostOfLabor",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityPayrollTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityPayrollTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityAccruedLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityAccruedLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityInsurancePayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityInsurancePayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilitySundryDebtorsAndCreditors\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilitySundryDebtorsAndCreditors",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityTradeAndOtherPayables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityTradeAndOtherPayables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseOtherHomeOfficeExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseOtherHomeOfficeExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityOtherCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityOtherCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLand\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetLand")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseExceptionalItems\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseExceptionalItems",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCumulativeDepreciationOnIntangibleAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCumulativeDepreciationOnIntangibleAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherEarMarkedBankAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherEarMarkedBankAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOtherCurrentOperatingIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOtherCurrentOperatingIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherConsumables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherConsumables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseAmortization\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseAmortization",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseDeferredTaxExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseDeferredTaxExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleLease\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleLease",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetIntangibleAssetsUnderDevelopment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetIntangibleAssetsUnderDevelopment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldShippingFreightDeliveryCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldShippingFreightDeliveryCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccountsPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccountsPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccruedVacationPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccruedVacationPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseUnappliedCashBillPaymentExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseUnappliedCashBillPaymentExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetPhotoVideo\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetPhotoVideo",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseRepairsAndMaintenance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseRepairsAndMaintenance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetBalWithGovtAuthorities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetBalWithGovtAuthorities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetRetainage\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetRetainage")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseWashAndRoadServices\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseWashAndRoadServices",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentMortgageRealEstateLoans\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentMortgageRealEstateLoans",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseRentAndLease\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseRentAndLease",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseSuppliesMaterials\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseSuppliesMaterials",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetEmployeeCashAdvances\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetEmployeeCashAdvances",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseUtilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseUtilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeGainLossOnSaleOfInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeGainLossOnSaleOfInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityRetainedEarnings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityRetainedEarnings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityOtherFreeReserves\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityOtherFreeReserves",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetPrepaymentsAndAccruedIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetPrepaymentsAndAccruedIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityGlobalTaxSuspense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityGlobalTaxSuspense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAssetsInCourseOfConstruction\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAssetsInCourseOfConstruction",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityAccumulatedOtherComprehensiveIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityAccumulatedOtherComprehensiveIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueCashReceiptIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueCashReceiptIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSalesOfProductIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSalesOfProductIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLongTermInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLongTermInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityRentsInTrustLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityRentsInTrustLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCapitalWip\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCapitalWip",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAsset",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLoansToOthers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLoansToOthers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentTaxLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentTaxLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetRentsHeldInTrust\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetRentsHeldInTrust",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseOtherVehicleExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseOtherVehicleExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetDeferredTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetDeferredTax",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetPrepaidExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetPrepaidExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOwnWorkCapitalized\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOwnWorkCapitalized",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLiabilitiesRelatedToAssetsHeldForSale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLiabilitiesRelatedToAssetsHeldForSale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseParkingAndTolls\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseParkingAndTolls",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseBorrowingCost\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseBorrowingCost",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleRegistration\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleRegistration",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilitySalesTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilitySalesTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetProvisionsCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetProvisionsCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherRentalCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherRentalCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermBorrowings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermBorrowings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityShortTermBorrowings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityShortTermBorrowings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityInterestPayables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityInterestPayables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilitySocialSecurityAgencies\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilitySocialSecurityAgencies",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldCostOfLaborCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldCostOfLaborCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityEquityInEarningsOfSubsidiuaries\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityEquityInEarningsOfSubsidiuaries",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseGasAndFuel\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseGasAndFuel",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OtherExpense")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeOtherMiscellaneousIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeOtherMiscellaneousIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetGoodwill\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetGoodwill")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLicenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetLicenses")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityStateLocalIncomeTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityStateLocalIncomeTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseGlobalTaxExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseGlobalTaxExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityProvisionForWarrantyObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityProvisionForWarrantyObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityFunds\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "EquityFunds")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseHomeOffice\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseHomeOffice",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetProvisionsNonCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetProvisionsNonCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__AccountType_151() {
    napi::bindgen_prelude::register_module_export(
        None,
        "AccountType\0",
        __register__enum__AccountType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__AccountType_151___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__AccountType_151___rust_ctor___ctor() -> usize {
        __napi_register__AccountType_151();
        0
    }
    __napi_register__AccountType_151___rust_ctor___ctor
};
pub enum SkuValidation {
    None,
    LocalUnique,
    GlobalUnique,
}
#[automatically_derived]
impl ::core::marker::Copy for SkuValidation {}
#[automatically_derived]
impl ::core::clone::Clone for SkuValidation {
    #[inline]
    fn clone(&self) -> SkuValidation {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for SkuValidation {
    fn type_name() -> &'static str {
        "SkuValidation"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for SkuValidation {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for SkuValidation {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "SkuValidation",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "None" => Ok(SkuValidation::None),
            "LocalUnique" => Ok(SkuValidation::LocalUnique),
            "GlobalUnique" => Ok(SkuValidation::GlobalUnique),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "SkuValidation",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for SkuValidation {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            SkuValidation::None => "None",
            SkuValidation::LocalUnique => "LocalUnique",
            SkuValidation::GlobalUnique => "GlobalUnique",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__SkuValidation_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("None\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "None")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SkuValidation\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LocalUnique\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LocalUnique")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SkuValidation\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "GlobalUnique\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GlobalUnique")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SkuValidation\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__SkuValidation_152() {
    napi::bindgen_prelude::register_module_export(
        None,
        "SkuValidation\0",
        __register__enum__SkuValidation_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__SkuValidation_152___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__SkuValidation_152___rust_ctor___ctor() -> usize {
        __napi_register__SkuValidation_152();
        0
    }
    __napi_register__SkuValidation_152___rust_ctor___ctor
};
pub enum Gender {
    Male,
    PreferNotToSay,
    Other,
    Female,
}
#[automatically_derived]
impl ::core::marker::Copy for Gender {}
#[automatically_derived]
impl ::core::clone::Clone for Gender {
    #[inline]
    fn clone(&self) -> Gender {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for Gender {
    fn type_name() -> &'static str {
        "Gender"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Gender {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for Gender {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "Gender",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Male" => Ok(Gender::Male),
            "PreferNotToSay" => Ok(Gender::PreferNotToSay),
            "Other" => Ok(Gender::Other),
            "Female" => Ok(Gender::Female),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "Gender",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for Gender {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            Gender::Male => "Male",
            Gender::PreferNotToSay => "PreferNotToSay",
            Gender::Other => "Other",
            Gender::Female => "Female",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__Gender_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Male\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Male")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Gender\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PreferNotToSay\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PreferNotToSay")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Gender\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Gender\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Female\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Female")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Gender\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__Gender_153() {
    napi::bindgen_prelude::register_module_export(
        None,
        "Gender\0",
        __register__enum__Gender_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__Gender_153___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__Gender_153___rust_ctor___ctor() -> usize {
        __napi_register__Gender_153();
        0
    }
    __napi_register__Gender_153___rust_ctor___ctor
};
pub enum Roles {
    User,
    Admin,
    Moderator,
}
#[automatically_derived]
impl ::core::marker::Copy for Roles {}
#[automatically_derived]
impl ::core::clone::Clone for Roles {
    #[inline]
    fn clone(&self) -> Roles {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for Roles {
    fn type_name() -> &'static str {
        "Roles"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Roles {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for Roles {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "Roles",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "User" => Ok(Roles::User),
            "Admin" => Ok(Roles::Admin),
            "Moderator" => Ok(Roles::Moderator),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "Roles",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for Roles {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            Roles::User => "User",
            Roles::Admin => "Admin",
            Roles::Moderator => "Moderator",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__Roles_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("User\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "User")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Roles\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Admin\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Admin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Roles\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Moderator\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Moderator")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Roles\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__Roles_154() {
    napi::bindgen_prelude::register_module_export(
        None,
        "Roles\0",
        __register__enum__Roles_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__Roles_154___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__Roles_154___rust_ctor___ctor() -> usize {
        __napi_register__Roles_154();
        0
    }
    __napi_register__Roles_154___rust_ctor___ctor
};
pub enum EmploymentType {
    Freelance,
    Internship,
    Contract,
    Permanent,
    Temporary,
    PartTime,
    FullTime,
    Volunteer,
    Seasonal,
}
#[automatically_derived]
impl ::core::marker::Copy for EmploymentType {}
#[automatically_derived]
impl ::core::clone::Clone for EmploymentType {
    #[inline]
    fn clone(&self) -> EmploymentType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for EmploymentType {
    fn type_name() -> &'static str {
        "EmploymentType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for EmploymentType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for EmploymentType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "EmploymentType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Freelance" => Ok(EmploymentType::Freelance),
            "Internship" => Ok(EmploymentType::Internship),
            "Contract" => Ok(EmploymentType::Contract),
            "Permanent" => Ok(EmploymentType::Permanent),
            "Temporary" => Ok(EmploymentType::Temporary),
            "PartTime" => Ok(EmploymentType::PartTime),
            "FullTime" => Ok(EmploymentType::FullTime),
            "Volunteer" => Ok(EmploymentType::Volunteer),
            "Seasonal" => Ok(EmploymentType::Seasonal),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "EmploymentType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for EmploymentType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            EmploymentType::Freelance => "Freelance",
            EmploymentType::Internship => "Internship",
            EmploymentType::Contract => "Contract",
            EmploymentType::Permanent => "Permanent",
            EmploymentType::Temporary => "Temporary",
            EmploymentType::PartTime => "PartTime",
            EmploymentType::FullTime => "FullTime",
            EmploymentType::Volunteer => "Volunteer",
            EmploymentType::Seasonal => "Seasonal",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__EmploymentType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Freelance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Freelance")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Internship\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Internship")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Contract\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Contract")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Permanent\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Permanent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Temporary\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Temporary")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PartTime\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PartTime")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "FullTime\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FullTime")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Volunteer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Volunteer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Seasonal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Seasonal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__EmploymentType_155() {
    napi::bindgen_prelude::register_module_export(
        None,
        "EmploymentType\0",
        __register__enum__EmploymentType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__EmploymentType_155___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__EmploymentType_155___rust_ctor___ctor() -> usize {
        __napi_register__EmploymentType_155();
        0
    }
    __napi_register__EmploymentType_155___rust_ctor___ctor
};
pub enum TimeCycle {
    SemiMonthly,
    SemiAnnually,
    Custom,
    Hourly,
    Annually,
    Weekly,
    Triennially,
    Daily,
    Monthly,
    AdHoc,
    Secondly,
    Quarterly,
    Biweekly,
    Biennially,
    Minutely,
}
#[automatically_derived]
impl ::core::marker::Copy for TimeCycle {}
#[automatically_derived]
impl ::core::clone::Clone for TimeCycle {
    #[inline]
    fn clone(&self) -> TimeCycle {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for TimeCycle {
    fn type_name() -> &'static str {
        "TimeCycle"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TimeCycle {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for TimeCycle {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "TimeCycle",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "SemiMonthly" => Ok(TimeCycle::SemiMonthly),
            "SemiAnnually" => Ok(TimeCycle::SemiAnnually),
            "Custom" => Ok(TimeCycle::Custom),
            "Hourly" => Ok(TimeCycle::Hourly),
            "Annually" => Ok(TimeCycle::Annually),
            "Weekly" => Ok(TimeCycle::Weekly),
            "Triennially" => Ok(TimeCycle::Triennially),
            "Daily" => Ok(TimeCycle::Daily),
            "Monthly" => Ok(TimeCycle::Monthly),
            "AdHoc" => Ok(TimeCycle::AdHoc),
            "Secondly" => Ok(TimeCycle::Secondly),
            "Quarterly" => Ok(TimeCycle::Quarterly),
            "Biweekly" => Ok(TimeCycle::Biweekly),
            "Biennially" => Ok(TimeCycle::Biennially),
            "Minutely" => Ok(TimeCycle::Minutely),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "TimeCycle",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for TimeCycle {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            TimeCycle::SemiMonthly => "SemiMonthly",
            TimeCycle::SemiAnnually => "SemiAnnually",
            TimeCycle::Custom => "Custom",
            TimeCycle::Hourly => "Hourly",
            TimeCycle::Annually => "Annually",
            TimeCycle::Weekly => "Weekly",
            TimeCycle::Triennially => "Triennially",
            TimeCycle::Daily => "Daily",
            TimeCycle::Monthly => "Monthly",
            TimeCycle::AdHoc => "AdHoc",
            TimeCycle::Secondly => "Secondly",
            TimeCycle::Quarterly => "Quarterly",
            TimeCycle::Biweekly => "Biweekly",
            TimeCycle::Biennially => "Biennially",
            TimeCycle::Minutely => "Minutely",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__TimeCycle_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SemiMonthly\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SemiMonthly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SemiAnnually\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SemiAnnually")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Custom\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Custom")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Hourly\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Hourly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Annually\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Annually")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Weekly\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Weekly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Triennially\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Triennially")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Daily\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Daily")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Monthly\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Monthly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AdHoc\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AdHoc")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Secondly\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Secondly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Quarterly\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Quarterly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Biweekly\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Biweekly")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Biennially\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Biennially")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Minutely\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Minutely")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TimeCycle\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__TimeCycle_156() {
    napi::bindgen_prelude::register_module_export(
        None,
        "TimeCycle\0",
        __register__enum__TimeCycle_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__TimeCycle_156___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__TimeCycle_156___rust_ctor___ctor() -> usize {
        __napi_register__TimeCycle_156();
        0
    }
    __napi_register__TimeCycle_156___rust_ctor___ctor
};
pub enum Country {
    Gambia,
    Mali,
    Netherlands,
    Gabon,
    DominicanRepublic,
    SaoTomeAndPrincipe,
    Serbia,
    PapuaNewGuinea,
    Bulgaria,
    Mexico,
    Tunisia,
    Uganda,
    Hungary,
    Cambodia,
    Luxembourg,
    SouthKorea,
    SolomonIslands,
    Myanmar,
    SouthSudan,
    Turkey,
    Mongolia,
    Uzbekistan,
    Mozambique,
    Kenya,
    Mauritania,
    CaboVerde,
    Lesotho,
    Madagascar,
    Ethiopia,
    Norway,
    Nepal,
    Eritrea,
    Nigeria,
    Germany,
    Ireland,
    ElSalvador,
    Mauritius,
    Zimbabwe,
    Bolivia,
    Israel,
    Palau,
    Kyrgyzstan,
    Albania,
    GuineaBissau,
    Honduras,
    TimorLeste,
    Kiribati,
    Bahrain,
    Canada,
    Philippines,
    Brunei,
    Fiji,
    Japan,
    CentralAfricanRepublic,
    Monaco,
    Azerbaijan,
    Samoa,
    Chile,
    Maldives,
    Malta,
    Algeria,
    Chad,
    Cuba,
    Micronesia,
    Nauru,
    Oman,
    Somalia,
    Tonga,
    Switzerland,
    Vanuatu,
    CoteDIvoire,
    Denmark,
    Nicaragua,
    Benin,
    Spain,
    Taiwan,
    SierraLeone,
    Barbados,
    Lebanon,
    Cyprus,
    Niger,
    Tuvalu,
    CostaRica,
    Ukraine,
    UnitedKingdom,
    Togo,
    SaintVincentAndTheGrenadines,
    Namibia,
    Egypt,
    Australia,
    Montenegro,
    Portugal,
    Brazil,
    Rwanda,
    Yemen,
    Bahamas,
    Guyana,
    Slovenia,
    Sweden,
    Poland,
    Eswatini,
    Russia,
    Botswana,
    Colombia,
    Malawi,
    Romania,
    SriLanka,
    Iraq,
    Thailand,
    Guinea,
    Pakistan,
    Panama,
    Bangladesh,
    Belgium,
    Djibouti,
    AntiguaAndBarbuda,
    Belarus,
    CongoRepublic,
    CongoDemocraticRepublic,
    Dominica,
    Estonia,
    Malaysia,
    SaintLucia,
    CzechRepublic,
    Palestine,
    Venezuela,
    India,
    Bhutan,
    Grenada,
    Jamaica,
    MarshallIslands,
    Belize,
    BosniaAndHerzegovina,
    Guatemala,
    Italy,
    Burundi,
    SaintKittsAndNevis,
    Indonesia,
    Latvia,
    Zambia,
    Andorra,
    Moldova,
    Comoros,
    Tajikistan,
    Greece,
    Jordan,
    Libya,
    Kuwait,
    Liechtenstein,
    Morocco,
    NewZealand,
    NorthKorea,
    SaudiArabia,
    Slovakia,
    Syria,
    VaticanCity,
    Haiti,
    Seychelles,
    Angola,
    Sudan,
    Vietnam,
    France,
    China,
    Iceland,
    Lithuania,
    Peru,
    SanMarino,
    Cameroon,
    Georgia,
    TrinidadAndTobago,
    UnitedStates,
    Croatia,
    Tanzania,
    Iran,
    Argentina,
    NorthMacedonia,
    Suriname,
    Turkmenistan,
    Liberia,
    Armenia,
    Austria,
    EquatorialGuinea,
    Ghana,
    Paraguay,
    Qatar,
    BurkinaFaso,
    Ecuador,
    Senegal,
    Finland,
    Singapore,
    UnitedArabEmirates,
    Laos,
    Kazakhstan,
    Afghanistan,
    SouthAfrica,
    Uruguay,
}
#[automatically_derived]
impl ::core::marker::Copy for Country {}
#[automatically_derived]
impl ::core::clone::Clone for Country {
    #[inline]
    fn clone(&self) -> Country {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for Country {
    fn type_name() -> &'static str {
        "Country"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Country {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for Country {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "Country",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Gambia" => Ok(Country::Gambia),
            "Mali" => Ok(Country::Mali),
            "Netherlands" => Ok(Country::Netherlands),
            "Gabon" => Ok(Country::Gabon),
            "DominicanRepublic" => Ok(Country::DominicanRepublic),
            "SaoTomeAndPrincipe" => Ok(Country::SaoTomeAndPrincipe),
            "Serbia" => Ok(Country::Serbia),
            "PapuaNewGuinea" => Ok(Country::PapuaNewGuinea),
            "Bulgaria" => Ok(Country::Bulgaria),
            "Mexico" => Ok(Country::Mexico),
            "Tunisia" => Ok(Country::Tunisia),
            "Uganda" => Ok(Country::Uganda),
            "Hungary" => Ok(Country::Hungary),
            "Cambodia" => Ok(Country::Cambodia),
            "Luxembourg" => Ok(Country::Luxembourg),
            "SouthKorea" => Ok(Country::SouthKorea),
            "SolomonIslands" => Ok(Country::SolomonIslands),
            "Myanmar" => Ok(Country::Myanmar),
            "SouthSudan" => Ok(Country::SouthSudan),
            "Turkey" => Ok(Country::Turkey),
            "Mongolia" => Ok(Country::Mongolia),
            "Uzbekistan" => Ok(Country::Uzbekistan),
            "Mozambique" => Ok(Country::Mozambique),
            "Kenya" => Ok(Country::Kenya),
            "Mauritania" => Ok(Country::Mauritania),
            "CaboVerde" => Ok(Country::CaboVerde),
            "Lesotho" => Ok(Country::Lesotho),
            "Madagascar" => Ok(Country::Madagascar),
            "Ethiopia" => Ok(Country::Ethiopia),
            "Norway" => Ok(Country::Norway),
            "Nepal" => Ok(Country::Nepal),
            "Eritrea" => Ok(Country::Eritrea),
            "Nigeria" => Ok(Country::Nigeria),
            "Germany" => Ok(Country::Germany),
            "Ireland" => Ok(Country::Ireland),
            "ElSalvador" => Ok(Country::ElSalvador),
            "Mauritius" => Ok(Country::Mauritius),
            "Zimbabwe" => Ok(Country::Zimbabwe),
            "Bolivia" => Ok(Country::Bolivia),
            "Israel" => Ok(Country::Israel),
            "Palau" => Ok(Country::Palau),
            "Kyrgyzstan" => Ok(Country::Kyrgyzstan),
            "Albania" => Ok(Country::Albania),
            "GuineaBissau" => Ok(Country::GuineaBissau),
            "Honduras" => Ok(Country::Honduras),
            "TimorLeste" => Ok(Country::TimorLeste),
            "Kiribati" => Ok(Country::Kiribati),
            "Bahrain" => Ok(Country::Bahrain),
            "Canada" => Ok(Country::Canada),
            "Philippines" => Ok(Country::Philippines),
            "Brunei" => Ok(Country::Brunei),
            "Fiji" => Ok(Country::Fiji),
            "Japan" => Ok(Country::Japan),
            "CentralAfricanRepublic" => Ok(Country::CentralAfricanRepublic),
            "Monaco" => Ok(Country::Monaco),
            "Azerbaijan" => Ok(Country::Azerbaijan),
            "Samoa" => Ok(Country::Samoa),
            "Chile" => Ok(Country::Chile),
            "Maldives" => Ok(Country::Maldives),
            "Malta" => Ok(Country::Malta),
            "Algeria" => Ok(Country::Algeria),
            "Chad" => Ok(Country::Chad),
            "Cuba" => Ok(Country::Cuba),
            "Micronesia" => Ok(Country::Micronesia),
            "Nauru" => Ok(Country::Nauru),
            "Oman" => Ok(Country::Oman),
            "Somalia" => Ok(Country::Somalia),
            "Tonga" => Ok(Country::Tonga),
            "Switzerland" => Ok(Country::Switzerland),
            "Vanuatu" => Ok(Country::Vanuatu),
            "CoteDIvoire" => Ok(Country::CoteDIvoire),
            "Denmark" => Ok(Country::Denmark),
            "Nicaragua" => Ok(Country::Nicaragua),
            "Benin" => Ok(Country::Benin),
            "Spain" => Ok(Country::Spain),
            "Taiwan" => Ok(Country::Taiwan),
            "SierraLeone" => Ok(Country::SierraLeone),
            "Barbados" => Ok(Country::Barbados),
            "Lebanon" => Ok(Country::Lebanon),
            "Cyprus" => Ok(Country::Cyprus),
            "Niger" => Ok(Country::Niger),
            "Tuvalu" => Ok(Country::Tuvalu),
            "CostaRica" => Ok(Country::CostaRica),
            "Ukraine" => Ok(Country::Ukraine),
            "UnitedKingdom" => Ok(Country::UnitedKingdom),
            "Togo" => Ok(Country::Togo),
            "SaintVincentAndTheGrenadines" => Ok(Country::SaintVincentAndTheGrenadines),
            "Namibia" => Ok(Country::Namibia),
            "Egypt" => Ok(Country::Egypt),
            "Australia" => Ok(Country::Australia),
            "Montenegro" => Ok(Country::Montenegro),
            "Portugal" => Ok(Country::Portugal),
            "Brazil" => Ok(Country::Brazil),
            "Rwanda" => Ok(Country::Rwanda),
            "Yemen" => Ok(Country::Yemen),
            "Bahamas" => Ok(Country::Bahamas),
            "Guyana" => Ok(Country::Guyana),
            "Slovenia" => Ok(Country::Slovenia),
            "Sweden" => Ok(Country::Sweden),
            "Poland" => Ok(Country::Poland),
            "Eswatini" => Ok(Country::Eswatini),
            "Russia" => Ok(Country::Russia),
            "Botswana" => Ok(Country::Botswana),
            "Colombia" => Ok(Country::Colombia),
            "Malawi" => Ok(Country::Malawi),
            "Romania" => Ok(Country::Romania),
            "SriLanka" => Ok(Country::SriLanka),
            "Iraq" => Ok(Country::Iraq),
            "Thailand" => Ok(Country::Thailand),
            "Guinea" => Ok(Country::Guinea),
            "Pakistan" => Ok(Country::Pakistan),
            "Panama" => Ok(Country::Panama),
            "Bangladesh" => Ok(Country::Bangladesh),
            "Belgium" => Ok(Country::Belgium),
            "Djibouti" => Ok(Country::Djibouti),
            "AntiguaAndBarbuda" => Ok(Country::AntiguaAndBarbuda),
            "Belarus" => Ok(Country::Belarus),
            "CongoRepublic" => Ok(Country::CongoRepublic),
            "CongoDemocraticRepublic" => Ok(Country::CongoDemocraticRepublic),
            "Dominica" => Ok(Country::Dominica),
            "Estonia" => Ok(Country::Estonia),
            "Malaysia" => Ok(Country::Malaysia),
            "SaintLucia" => Ok(Country::SaintLucia),
            "CzechRepublic" => Ok(Country::CzechRepublic),
            "Palestine" => Ok(Country::Palestine),
            "Venezuela" => Ok(Country::Venezuela),
            "India" => Ok(Country::India),
            "Bhutan" => Ok(Country::Bhutan),
            "Grenada" => Ok(Country::Grenada),
            "Jamaica" => Ok(Country::Jamaica),
            "MarshallIslands" => Ok(Country::MarshallIslands),
            "Belize" => Ok(Country::Belize),
            "BosniaAndHerzegovina" => Ok(Country::BosniaAndHerzegovina),
            "Guatemala" => Ok(Country::Guatemala),
            "Italy" => Ok(Country::Italy),
            "Burundi" => Ok(Country::Burundi),
            "SaintKittsAndNevis" => Ok(Country::SaintKittsAndNevis),
            "Indonesia" => Ok(Country::Indonesia),
            "Latvia" => Ok(Country::Latvia),
            "Zambia" => Ok(Country::Zambia),
            "Andorra" => Ok(Country::Andorra),
            "Moldova" => Ok(Country::Moldova),
            "Comoros" => Ok(Country::Comoros),
            "Tajikistan" => Ok(Country::Tajikistan),
            "Greece" => Ok(Country::Greece),
            "Jordan" => Ok(Country::Jordan),
            "Libya" => Ok(Country::Libya),
            "Kuwait" => Ok(Country::Kuwait),
            "Liechtenstein" => Ok(Country::Liechtenstein),
            "Morocco" => Ok(Country::Morocco),
            "NewZealand" => Ok(Country::NewZealand),
            "NorthKorea" => Ok(Country::NorthKorea),
            "SaudiArabia" => Ok(Country::SaudiArabia),
            "Slovakia" => Ok(Country::Slovakia),
            "Syria" => Ok(Country::Syria),
            "VaticanCity" => Ok(Country::VaticanCity),
            "Haiti" => Ok(Country::Haiti),
            "Seychelles" => Ok(Country::Seychelles),
            "Angola" => Ok(Country::Angola),
            "Sudan" => Ok(Country::Sudan),
            "Vietnam" => Ok(Country::Vietnam),
            "France" => Ok(Country::France),
            "China" => Ok(Country::China),
            "Iceland" => Ok(Country::Iceland),
            "Lithuania" => Ok(Country::Lithuania),
            "Peru" => Ok(Country::Peru),
            "SanMarino" => Ok(Country::SanMarino),
            "Cameroon" => Ok(Country::Cameroon),
            "Georgia" => Ok(Country::Georgia),
            "TrinidadAndTobago" => Ok(Country::TrinidadAndTobago),
            "UnitedStates" => Ok(Country::UnitedStates),
            "Croatia" => Ok(Country::Croatia),
            "Tanzania" => Ok(Country::Tanzania),
            "Iran" => Ok(Country::Iran),
            "Argentina" => Ok(Country::Argentina),
            "NorthMacedonia" => Ok(Country::NorthMacedonia),
            "Suriname" => Ok(Country::Suriname),
            "Turkmenistan" => Ok(Country::Turkmenistan),
            "Liberia" => Ok(Country::Liberia),
            "Armenia" => Ok(Country::Armenia),
            "Austria" => Ok(Country::Austria),
            "EquatorialGuinea" => Ok(Country::EquatorialGuinea),
            "Ghana" => Ok(Country::Ghana),
            "Paraguay" => Ok(Country::Paraguay),
            "Qatar" => Ok(Country::Qatar),
            "BurkinaFaso" => Ok(Country::BurkinaFaso),
            "Ecuador" => Ok(Country::Ecuador),
            "Senegal" => Ok(Country::Senegal),
            "Finland" => Ok(Country::Finland),
            "Singapore" => Ok(Country::Singapore),
            "UnitedArabEmirates" => Ok(Country::UnitedArabEmirates),
            "Laos" => Ok(Country::Laos),
            "Kazakhstan" => Ok(Country::Kazakhstan),
            "Afghanistan" => Ok(Country::Afghanistan),
            "SouthAfrica" => Ok(Country::SouthAfrica),
            "Uruguay" => Ok(Country::Uruguay),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "Country",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for Country {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            Country::Gambia => "Gambia",
            Country::Mali => "Mali",
            Country::Netherlands => "Netherlands",
            Country::Gabon => "Gabon",
            Country::DominicanRepublic => "DominicanRepublic",
            Country::SaoTomeAndPrincipe => "SaoTomeAndPrincipe",
            Country::Serbia => "Serbia",
            Country::PapuaNewGuinea => "PapuaNewGuinea",
            Country::Bulgaria => "Bulgaria",
            Country::Mexico => "Mexico",
            Country::Tunisia => "Tunisia",
            Country::Uganda => "Uganda",
            Country::Hungary => "Hungary",
            Country::Cambodia => "Cambodia",
            Country::Luxembourg => "Luxembourg",
            Country::SouthKorea => "SouthKorea",
            Country::SolomonIslands => "SolomonIslands",
            Country::Myanmar => "Myanmar",
            Country::SouthSudan => "SouthSudan",
            Country::Turkey => "Turkey",
            Country::Mongolia => "Mongolia",
            Country::Uzbekistan => "Uzbekistan",
            Country::Mozambique => "Mozambique",
            Country::Kenya => "Kenya",
            Country::Mauritania => "Mauritania",
            Country::CaboVerde => "CaboVerde",
            Country::Lesotho => "Lesotho",
            Country::Madagascar => "Madagascar",
            Country::Ethiopia => "Ethiopia",
            Country::Norway => "Norway",
            Country::Nepal => "Nepal",
            Country::Eritrea => "Eritrea",
            Country::Nigeria => "Nigeria",
            Country::Germany => "Germany",
            Country::Ireland => "Ireland",
            Country::ElSalvador => "ElSalvador",
            Country::Mauritius => "Mauritius",
            Country::Zimbabwe => "Zimbabwe",
            Country::Bolivia => "Bolivia",
            Country::Israel => "Israel",
            Country::Palau => "Palau",
            Country::Kyrgyzstan => "Kyrgyzstan",
            Country::Albania => "Albania",
            Country::GuineaBissau => "GuineaBissau",
            Country::Honduras => "Honduras",
            Country::TimorLeste => "TimorLeste",
            Country::Kiribati => "Kiribati",
            Country::Bahrain => "Bahrain",
            Country::Canada => "Canada",
            Country::Philippines => "Philippines",
            Country::Brunei => "Brunei",
            Country::Fiji => "Fiji",
            Country::Japan => "Japan",
            Country::CentralAfricanRepublic => "CentralAfricanRepublic",
            Country::Monaco => "Monaco",
            Country::Azerbaijan => "Azerbaijan",
            Country::Samoa => "Samoa",
            Country::Chile => "Chile",
            Country::Maldives => "Maldives",
            Country::Malta => "Malta",
            Country::Algeria => "Algeria",
            Country::Chad => "Chad",
            Country::Cuba => "Cuba",
            Country::Micronesia => "Micronesia",
            Country::Nauru => "Nauru",
            Country::Oman => "Oman",
            Country::Somalia => "Somalia",
            Country::Tonga => "Tonga",
            Country::Switzerland => "Switzerland",
            Country::Vanuatu => "Vanuatu",
            Country::CoteDIvoire => "CoteDIvoire",
            Country::Denmark => "Denmark",
            Country::Nicaragua => "Nicaragua",
            Country::Benin => "Benin",
            Country::Spain => "Spain",
            Country::Taiwan => "Taiwan",
            Country::SierraLeone => "SierraLeone",
            Country::Barbados => "Barbados",
            Country::Lebanon => "Lebanon",
            Country::Cyprus => "Cyprus",
            Country::Niger => "Niger",
            Country::Tuvalu => "Tuvalu",
            Country::CostaRica => "CostaRica",
            Country::Ukraine => "Ukraine",
            Country::UnitedKingdom => "UnitedKingdom",
            Country::Togo => "Togo",
            Country::SaintVincentAndTheGrenadines => "SaintVincentAndTheGrenadines",
            Country::Namibia => "Namibia",
            Country::Egypt => "Egypt",
            Country::Australia => "Australia",
            Country::Montenegro => "Montenegro",
            Country::Portugal => "Portugal",
            Country::Brazil => "Brazil",
            Country::Rwanda => "Rwanda",
            Country::Yemen => "Yemen",
            Country::Bahamas => "Bahamas",
            Country::Guyana => "Guyana",
            Country::Slovenia => "Slovenia",
            Country::Sweden => "Sweden",
            Country::Poland => "Poland",
            Country::Eswatini => "Eswatini",
            Country::Russia => "Russia",
            Country::Botswana => "Botswana",
            Country::Colombia => "Colombia",
            Country::Malawi => "Malawi",
            Country::Romania => "Romania",
            Country::SriLanka => "SriLanka",
            Country::Iraq => "Iraq",
            Country::Thailand => "Thailand",
            Country::Guinea => "Guinea",
            Country::Pakistan => "Pakistan",
            Country::Panama => "Panama",
            Country::Bangladesh => "Bangladesh",
            Country::Belgium => "Belgium",
            Country::Djibouti => "Djibouti",
            Country::AntiguaAndBarbuda => "AntiguaAndBarbuda",
            Country::Belarus => "Belarus",
            Country::CongoRepublic => "CongoRepublic",
            Country::CongoDemocraticRepublic => "CongoDemocraticRepublic",
            Country::Dominica => "Dominica",
            Country::Estonia => "Estonia",
            Country::Malaysia => "Malaysia",
            Country::SaintLucia => "SaintLucia",
            Country::CzechRepublic => "CzechRepublic",
            Country::Palestine => "Palestine",
            Country::Venezuela => "Venezuela",
            Country::India => "India",
            Country::Bhutan => "Bhutan",
            Country::Grenada => "Grenada",
            Country::Jamaica => "Jamaica",
            Country::MarshallIslands => "MarshallIslands",
            Country::Belize => "Belize",
            Country::BosniaAndHerzegovina => "BosniaAndHerzegovina",
            Country::Guatemala => "Guatemala",
            Country::Italy => "Italy",
            Country::Burundi => "Burundi",
            Country::SaintKittsAndNevis => "SaintKittsAndNevis",
            Country::Indonesia => "Indonesia",
            Country::Latvia => "Latvia",
            Country::Zambia => "Zambia",
            Country::Andorra => "Andorra",
            Country::Moldova => "Moldova",
            Country::Comoros => "Comoros",
            Country::Tajikistan => "Tajikistan",
            Country::Greece => "Greece",
            Country::Jordan => "Jordan",
            Country::Libya => "Libya",
            Country::Kuwait => "Kuwait",
            Country::Liechtenstein => "Liechtenstein",
            Country::Morocco => "Morocco",
            Country::NewZealand => "NewZealand",
            Country::NorthKorea => "NorthKorea",
            Country::SaudiArabia => "SaudiArabia",
            Country::Slovakia => "Slovakia",
            Country::Syria => "Syria",
            Country::VaticanCity => "VaticanCity",
            Country::Haiti => "Haiti",
            Country::Seychelles => "Seychelles",
            Country::Angola => "Angola",
            Country::Sudan => "Sudan",
            Country::Vietnam => "Vietnam",
            Country::France => "France",
            Country::China => "China",
            Country::Iceland => "Iceland",
            Country::Lithuania => "Lithuania",
            Country::Peru => "Peru",
            Country::SanMarino => "SanMarino",
            Country::Cameroon => "Cameroon",
            Country::Georgia => "Georgia",
            Country::TrinidadAndTobago => "TrinidadAndTobago",
            Country::UnitedStates => "UnitedStates",
            Country::Croatia => "Croatia",
            Country::Tanzania => "Tanzania",
            Country::Iran => "Iran",
            Country::Argentina => "Argentina",
            Country::NorthMacedonia => "NorthMacedonia",
            Country::Suriname => "Suriname",
            Country::Turkmenistan => "Turkmenistan",
            Country::Liberia => "Liberia",
            Country::Armenia => "Armenia",
            Country::Austria => "Austria",
            Country::EquatorialGuinea => "EquatorialGuinea",
            Country::Ghana => "Ghana",
            Country::Paraguay => "Paraguay",
            Country::Qatar => "Qatar",
            Country::BurkinaFaso => "BurkinaFaso",
            Country::Ecuador => "Ecuador",
            Country::Senegal => "Senegal",
            Country::Finland => "Finland",
            Country::Singapore => "Singapore",
            Country::UnitedArabEmirates => "UnitedArabEmirates",
            Country::Laos => "Laos",
            Country::Kazakhstan => "Kazakhstan",
            Country::Afghanistan => "Afghanistan",
            Country::SouthAfrica => "SouthAfrica",
            Country::Uruguay => "Uruguay",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__Country_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Gambia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Gambia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mali\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mali")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Netherlands\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Netherlands")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Gabon\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Gabon")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DominicanRepublic\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "DominicanRepublic",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SaoTomeAndPrincipe\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "SaoTomeAndPrincipe",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Serbia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Serbia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PapuaNewGuinea\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PapuaNewGuinea")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Bulgaria\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bulgaria")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mexico\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mexico")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tunisia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tunisia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Uganda\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Uganda")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Hungary\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Hungary")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cambodia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cambodia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Luxembourg\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Luxembourg")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SouthKorea\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SouthKorea")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SolomonIslands\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SolomonIslands")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Myanmar\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Myanmar")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SouthSudan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SouthSudan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Turkey\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Turkey")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Mongolia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mongolia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Uzbekistan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Uzbekistan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Mozambique\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mozambique")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Kenya\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Kenya")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Mauritania\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mauritania")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CaboVerde\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CaboVerde")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Lesotho\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Lesotho")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Madagascar\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Madagascar")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Ethiopia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Ethiopia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Norway\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Norway")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Nepal\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Nepal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Eritrea\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Eritrea")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Nigeria\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Nigeria")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Germany\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Germany")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Ireland\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Ireland")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ElSalvador\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ElSalvador")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Mauritius\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mauritius")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Zimbabwe\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Zimbabwe")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Bolivia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bolivia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Israel\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Israel")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Palau\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Palau")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Kyrgyzstan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Kyrgyzstan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Albania\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Albania")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "GuineaBissau\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GuineaBissau")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Honduras\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Honduras")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "TimorLeste\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TimorLeste")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Kiribati\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Kiribati")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Bahrain\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bahrain")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Canada\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Canada")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Philippines\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Philippines")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Brunei\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Brunei")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Fiji\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Fiji")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Japan\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Japan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CentralAfricanRepublic\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CentralAfricanRepublic",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Monaco\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Monaco")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Azerbaijan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Azerbaijan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Samoa\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Samoa")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Chile\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Chile")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Maldives\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Maldives")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Malta\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Malta")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Algeria\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Algeria")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Chad\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Chad")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Cuba\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cuba")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Micronesia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Micronesia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Nauru\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Nauru")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Oman\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Oman")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Somalia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Somalia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tonga\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tonga")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Switzerland\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Switzerland")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Vanuatu\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Vanuatu")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CoteDIvoire\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CoteDIvoire")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Denmark\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Denmark")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Nicaragua\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Nicaragua")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Benin\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Benin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Spain\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Spain")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Taiwan\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Taiwan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SierraLeone\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SierraLeone")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Barbados\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Barbados")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Lebanon\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Lebanon")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Cyprus\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cyprus")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Niger\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Niger")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tuvalu\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tuvalu")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostaRica\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CostaRica")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Ukraine\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Ukraine")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "UnitedKingdom\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UnitedKingdom")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Togo\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Togo")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SaintVincentAndTheGrenadines\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "SaintVincentAndTheGrenadines",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Namibia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Namibia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Egypt\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Egypt")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Australia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Australia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Montenegro\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Montenegro")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Portugal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Portugal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Brazil\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Brazil")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Rwanda\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Rwanda")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Yemen\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Yemen")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Bahamas\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bahamas")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Guyana\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Guyana")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Slovenia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Slovenia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sweden\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sweden")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Poland\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Poland")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Eswatini\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Eswatini")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Russia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Russia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Botswana\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Botswana")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Colombia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Colombia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Malawi\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Malawi")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Romania\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Romania")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SriLanka\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SriLanka")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Iraq\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Iraq")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Thailand\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Thailand")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Guinea\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Guinea")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Pakistan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pakistan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Panama\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Panama")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Bangladesh\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bangladesh")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Belgium\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Belgium")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Djibouti\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Djibouti")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AntiguaAndBarbuda\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AntiguaAndBarbuda",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Belarus\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Belarus")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CongoRepublic\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CongoRepublic")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CongoDemocraticRepublic\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CongoDemocraticRepublic",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Dominica\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Dominica")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Estonia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Estonia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Malaysia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Malaysia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SaintLucia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SaintLucia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CzechRepublic\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CzechRepublic")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Palestine\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Palestine")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Venezuela\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Venezuela")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("India\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "India")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Bhutan\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bhutan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Grenada\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Grenada")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Jamaica\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Jamaica")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "MarshallIslands\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "MarshallIslands",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Belize\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Belize")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BosniaAndHerzegovina\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "BosniaAndHerzegovina",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Guatemala\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Guatemala")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Italy\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Italy")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Burundi\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Burundi")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SaintKittsAndNevis\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "SaintKittsAndNevis",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Indonesia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Indonesia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Latvia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Latvia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Zambia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Zambia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Andorra\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Andorra")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Moldova\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Moldova")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Comoros\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Comoros")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Tajikistan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tajikistan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Greece\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Greece")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Jordan\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Jordan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Libya\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Libya")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Kuwait\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Kuwait")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Liechtenstein\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Liechtenstein")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Morocco\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Morocco")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "NewZealand\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NewZealand")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "NorthKorea\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NorthKorea")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SaudiArabia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SaudiArabia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Slovakia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Slovakia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Syria\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Syria")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "VaticanCity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "VaticanCity")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Haiti\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Haiti")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Seychelles\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Seychelles")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Angola\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Angola")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sudan\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sudan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Vietnam\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Vietnam")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("France\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "France")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("China\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "China")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Iceland\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Iceland")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Lithuania\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Lithuania")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Peru\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Peru")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SanMarino\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SanMarino")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cameroon\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cameroon")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Georgia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Georgia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "TrinidadAndTobago\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "TrinidadAndTobago",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "UnitedStates\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UnitedStates")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Croatia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Croatia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Tanzania\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tanzania")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Iran\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Iran")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Argentina\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Argentina")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "NorthMacedonia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NorthMacedonia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suriname\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suriname")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Turkmenistan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Turkmenistan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Liberia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Liberia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Armenia\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Armenia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Austria\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Austria")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquatorialGuinea\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquatorialGuinea",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Ghana\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Ghana")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Paraguay\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Paraguay")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Qatar\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Qatar")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BurkinaFaso\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BurkinaFaso")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Ecuador\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Ecuador")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Senegal\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Senegal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Finland\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Finland")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Singapore\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Singapore")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "UnitedArabEmirates\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "UnitedArabEmirates",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Laos\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Laos")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Kazakhstan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Kazakhstan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Afghanistan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Afghanistan")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SouthAfrica\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SouthAfrica")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Uruguay\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Uruguay")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Country\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__Country_157() {
    napi::bindgen_prelude::register_module_export(
        None,
        "Country\0",
        __register__enum__Country_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__Country_157___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__Country_157___rust_ctor___ctor() -> usize {
        __napi_register__Country_157();
        0
    }
    __napi_register__Country_157___rust_ctor___ctor
};
pub enum FinancialTrackingCategories {
    Project,
    Employee,
    Vendor,
    Department,
    Service,
    Location,
    Class,
    CostCenter,
    Other,
    None,
    Customer,
    Division,
    Product,
}
#[automatically_derived]
impl ::core::marker::Copy for FinancialTrackingCategories {}
#[automatically_derived]
impl ::core::clone::Clone for FinancialTrackingCategories {
    #[inline]
    fn clone(&self) -> FinancialTrackingCategories {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FinancialTrackingCategories {
    fn type_name() -> &'static str {
        "FinancialTrackingCategories"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FinancialTrackingCategories {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FinancialTrackingCategories {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FinancialTrackingCategories",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Project" => Ok(FinancialTrackingCategories::Project),
            "Employee" => Ok(FinancialTrackingCategories::Employee),
            "Vendor" => Ok(FinancialTrackingCategories::Vendor),
            "Department" => Ok(FinancialTrackingCategories::Department),
            "Service" => Ok(FinancialTrackingCategories::Service),
            "Location" => Ok(FinancialTrackingCategories::Location),
            "Class" => Ok(FinancialTrackingCategories::Class),
            "CostCenter" => Ok(FinancialTrackingCategories::CostCenter),
            "Other" => Ok(FinancialTrackingCategories::Other),
            "None" => Ok(FinancialTrackingCategories::None),
            "Customer" => Ok(FinancialTrackingCategories::Customer),
            "Division" => Ok(FinancialTrackingCategories::Division),
            "Product" => Ok(FinancialTrackingCategories::Product),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FinancialTrackingCategories",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FinancialTrackingCategories {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FinancialTrackingCategories::Project => "Project",
            FinancialTrackingCategories::Employee => "Employee",
            FinancialTrackingCategories::Vendor => "Vendor",
            FinancialTrackingCategories::Department => "Department",
            FinancialTrackingCategories::Service => "Service",
            FinancialTrackingCategories::Location => "Location",
            FinancialTrackingCategories::Class => "Class",
            FinancialTrackingCategories::CostCenter => "CostCenter",
            FinancialTrackingCategories::Other => "Other",
            FinancialTrackingCategories::None => "None",
            FinancialTrackingCategories::Customer => "Customer",
            FinancialTrackingCategories::Division => "Division",
            FinancialTrackingCategories::Product => "Product",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FinancialTrackingCategories_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Project\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Project")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Employee\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Employee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Vendor\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Vendor")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Department\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Department")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Service\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Service")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Location\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Location")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Class\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Class")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostCenter\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CostCenter")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("None\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "None")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Customer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Customer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Division\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Division")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Product\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Product")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTrackingCategories\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FinancialTrackingCategories_158() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FinancialTrackingCategories\0",
        __register__enum__FinancialTrackingCategories_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FinancialTrackingCategories_158___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FinancialTrackingCategories_158___rust_ctor___ctor() -> usize {
        __napi_register__FinancialTrackingCategories_158();
        0
    }
    __napi_register__FinancialTrackingCategories_158___rust_ctor___ctor
};
pub enum CreditNoteStatus {
    Revised,
    Cancelled,
    Completed,
    Void,
    Applied,
    Disputed,
    Draft,
    Pending,
    Issued,
}
#[automatically_derived]
impl ::core::marker::Copy for CreditNoteStatus {}
#[automatically_derived]
impl ::core::clone::Clone for CreditNoteStatus {
    #[inline]
    fn clone(&self) -> CreditNoteStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CreditNoteStatus {
    fn type_name() -> &'static str {
        "CreditNoteStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CreditNoteStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CreditNoteStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CreditNoteStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Revised" => Ok(CreditNoteStatus::Revised),
            "Cancelled" => Ok(CreditNoteStatus::Cancelled),
            "Completed" => Ok(CreditNoteStatus::Completed),
            "Void" => Ok(CreditNoteStatus::Void),
            "Applied" => Ok(CreditNoteStatus::Applied),
            "Disputed" => Ok(CreditNoteStatus::Disputed),
            "Draft" => Ok(CreditNoteStatus::Draft),
            "Pending" => Ok(CreditNoteStatus::Pending),
            "Issued" => Ok(CreditNoteStatus::Issued),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CreditNoteStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CreditNoteStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CreditNoteStatus::Revised => "Revised",
            CreditNoteStatus::Cancelled => "Cancelled",
            CreditNoteStatus::Completed => "Completed",
            CreditNoteStatus::Void => "Void",
            CreditNoteStatus::Applied => "Applied",
            CreditNoteStatus::Disputed => "Disputed",
            CreditNoteStatus::Draft => "Draft",
            CreditNoteStatus::Pending => "Pending",
            CreditNoteStatus::Issued => "Issued",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CreditNoteStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Revised\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Revised")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Completed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Completed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Void\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Void")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Applied\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Applied")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Disputed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Disputed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Draft\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Draft")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Issued\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Issued")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CreditNoteStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CreditNoteStatus_159() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CreditNoteStatus\0",
        __register__enum__CreditNoteStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CreditNoteStatus_159___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CreditNoteStatus_159___rust_ctor___ctor() -> usize {
        __napi_register__CreditNoteStatus_159();
        0
    }
    __napi_register__CreditNoteStatus_159___rust_ctor___ctor
};
pub enum GlobalTaxType {
    PropertyTax,
    Gst,
    SalesTax,
    ExciseTax,
    Vat,
    CustomsDuty,
    Other,
}
#[automatically_derived]
impl ::core::marker::Copy for GlobalTaxType {}
#[automatically_derived]
impl ::core::clone::Clone for GlobalTaxType {
    #[inline]
    fn clone(&self) -> GlobalTaxType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for GlobalTaxType {
    fn type_name() -> &'static str {
        "GlobalTaxType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for GlobalTaxType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for GlobalTaxType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "GlobalTaxType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "PropertyTax" => Ok(GlobalTaxType::PropertyTax),
            "Gst" => Ok(GlobalTaxType::Gst),
            "SalesTax" => Ok(GlobalTaxType::SalesTax),
            "ExciseTax" => Ok(GlobalTaxType::ExciseTax),
            "Vat" => Ok(GlobalTaxType::Vat),
            "CustomsDuty" => Ok(GlobalTaxType::CustomsDuty),
            "Other" => Ok(GlobalTaxType::Other),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "GlobalTaxType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for GlobalTaxType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            GlobalTaxType::PropertyTax => "PropertyTax",
            GlobalTaxType::Gst => "Gst",
            GlobalTaxType::SalesTax => "SalesTax",
            GlobalTaxType::ExciseTax => "ExciseTax",
            GlobalTaxType::Vat => "Vat",
            GlobalTaxType::CustomsDuty => "CustomsDuty",
            GlobalTaxType::Other => "Other",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__GlobalTaxType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PropertyTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PropertyTax")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Gst\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Gst")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SalesTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SalesTax")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExciseTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExciseTax")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Vat\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Vat")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CustomsDuty\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CustomsDuty")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GlobalTaxType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__GlobalTaxType_160() {
    napi::bindgen_prelude::register_module_export(
        None,
        "GlobalTaxType\0",
        __register__enum__GlobalTaxType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__GlobalTaxType_160___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__GlobalTaxType_160___rust_ctor___ctor() -> usize {
        __napi_register__GlobalTaxType_160();
        0
    }
    __napi_register__GlobalTaxType_160___rust_ctor___ctor
};
pub enum JournalEntryStatus {
    Pending,
    Corrected,
    Draft,
    Voided,
    Error,
    Posted,
}
#[automatically_derived]
impl ::core::marker::Copy for JournalEntryStatus {}
#[automatically_derived]
impl ::core::clone::Clone for JournalEntryStatus {
    #[inline]
    fn clone(&self) -> JournalEntryStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for JournalEntryStatus {
    fn type_name() -> &'static str {
        "JournalEntryStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for JournalEntryStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for JournalEntryStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "JournalEntryStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Pending" => Ok(JournalEntryStatus::Pending),
            "Corrected" => Ok(JournalEntryStatus::Corrected),
            "Draft" => Ok(JournalEntryStatus::Draft),
            "Voided" => Ok(JournalEntryStatus::Voided),
            "Error" => Ok(JournalEntryStatus::Error),
            "Posted" => Ok(JournalEntryStatus::Posted),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "JournalEntryStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for JournalEntryStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            JournalEntryStatus::Pending => "Pending",
            JournalEntryStatus::Corrected => "Corrected",
            JournalEntryStatus::Draft => "Draft",
            JournalEntryStatus::Voided => "Voided",
            JournalEntryStatus::Error => "Error",
            JournalEntryStatus::Posted => "Posted",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__JournalEntryStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "JournalEntryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Corrected\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Corrected")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "JournalEntryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Draft\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Draft")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "JournalEntryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Voided\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Voided")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "JournalEntryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Error\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Error")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "JournalEntryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Posted\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Posted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "JournalEntryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__JournalEntryStatus_161() {
    napi::bindgen_prelude::register_module_export(
        None,
        "JournalEntryStatus\0",
        __register__enum__JournalEntryStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__JournalEntryStatus_161___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__JournalEntryStatus_161___rust_ctor___ctor() -> usize {
        __napi_register__JournalEntryStatus_161();
        0
    }
    __napi_register__JournalEntryStatus_161___rust_ctor___ctor
};
pub enum PaymentTerm {
    DueOnReceipt,
    DeferredPayment,
    Prepaid,
    UponCompletion,
    CashWithOrder,
    Prepayment,
    CashOnDelivery,
    Installment,
    CashBeforeShipment,
    CashInAdvance,
    Net,
    DueEndOfMonth,
    Net30,
    Net60,
    Net90,
    Custom,
}
#[automatically_derived]
impl ::core::marker::Copy for PaymentTerm {}
#[automatically_derived]
impl ::core::clone::Clone for PaymentTerm {
    #[inline]
    fn clone(&self) -> PaymentTerm {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for PaymentTerm {
    fn type_name() -> &'static str {
        "PaymentTerm"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PaymentTerm {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for PaymentTerm {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "PaymentTerm",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "DueOnReceipt" => Ok(PaymentTerm::DueOnReceipt),
            "DeferredPayment" => Ok(PaymentTerm::DeferredPayment),
            "Prepaid" => Ok(PaymentTerm::Prepaid),
            "UponCompletion" => Ok(PaymentTerm::UponCompletion),
            "CashWithOrder" => Ok(PaymentTerm::CashWithOrder),
            "Prepayment" => Ok(PaymentTerm::Prepayment),
            "CashOnDelivery" => Ok(PaymentTerm::CashOnDelivery),
            "Installment" => Ok(PaymentTerm::Installment),
            "CashBeforeShipment" => Ok(PaymentTerm::CashBeforeShipment),
            "CashInAdvance" => Ok(PaymentTerm::CashInAdvance),
            "Net" => Ok(PaymentTerm::Net),
            "DueEndOfMonth" => Ok(PaymentTerm::DueEndOfMonth),
            "Net30" => Ok(PaymentTerm::Net30),
            "Net60" => Ok(PaymentTerm::Net60),
            "Net90" => Ok(PaymentTerm::Net90),
            "Custom" => Ok(PaymentTerm::Custom),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "PaymentTerm",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for PaymentTerm {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            PaymentTerm::DueOnReceipt => "DueOnReceipt",
            PaymentTerm::DeferredPayment => "DeferredPayment",
            PaymentTerm::Prepaid => "Prepaid",
            PaymentTerm::UponCompletion => "UponCompletion",
            PaymentTerm::CashWithOrder => "CashWithOrder",
            PaymentTerm::Prepayment => "Prepayment",
            PaymentTerm::CashOnDelivery => "CashOnDelivery",
            PaymentTerm::Installment => "Installment",
            PaymentTerm::CashBeforeShipment => "CashBeforeShipment",
            PaymentTerm::CashInAdvance => "CashInAdvance",
            PaymentTerm::Net => "Net",
            PaymentTerm::DueEndOfMonth => "DueEndOfMonth",
            PaymentTerm::Net30 => "Net30",
            PaymentTerm::Net60 => "Net60",
            PaymentTerm::Net90 => "Net90",
            PaymentTerm::Custom => "Custom",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__PaymentTerm_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DueOnReceipt\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DueOnReceipt")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DeferredPayment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "DeferredPayment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Prepaid\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Prepaid")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "UponCompletion\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UponCompletion")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CashWithOrder\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CashWithOrder")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Prepayment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Prepayment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CashOnDelivery\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CashOnDelivery")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Installment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Installment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CashBeforeShipment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CashBeforeShipment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CashInAdvance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CashInAdvance")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Net\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Net")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DueEndOfMonth\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DueEndOfMonth")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Net30\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Net30")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Net60\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Net60")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Net90\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Net90")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Custom\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Custom")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentTerm\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__PaymentTerm_162() {
    napi::bindgen_prelude::register_module_export(
        None,
        "PaymentTerm\0",
        __register__enum__PaymentTerm_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__PaymentTerm_162___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__PaymentTerm_162___rust_ctor___ctor() -> usize {
        __napi_register__PaymentTerm_162();
        0
    }
    __napi_register__PaymentTerm_162___rust_ctor___ctor
};
pub enum IdentityProvider {
    Tumblr,
    Discord,
    Telegram,
    Twitter,
    Wechat,
    Other,
    Line,
    Google,
    Behance,
    Yahoo,
    Snapchat,
    Flickr,
    Microsoft,
    Pinterest,
    Signal,
    Qq,
    Whatsapp,
    Paypal,
    Dribbble,
    Github,
    Reddit,
    Instagram,
    Vimeo,
    Linkedin,
    Apple,
    Foursquare,
    Slack,
    Tiktok,
    Facebook,
    Amazon,
}
#[automatically_derived]
impl ::core::marker::Copy for IdentityProvider {}
#[automatically_derived]
impl ::core::clone::Clone for IdentityProvider {
    #[inline]
    fn clone(&self) -> IdentityProvider {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for IdentityProvider {
    fn type_name() -> &'static str {
        "IdentityProvider"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for IdentityProvider {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for IdentityProvider {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "IdentityProvider",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Tumblr" => Ok(IdentityProvider::Tumblr),
            "Discord" => Ok(IdentityProvider::Discord),
            "Telegram" => Ok(IdentityProvider::Telegram),
            "Twitter" => Ok(IdentityProvider::Twitter),
            "Wechat" => Ok(IdentityProvider::Wechat),
            "Other" => Ok(IdentityProvider::Other),
            "Line" => Ok(IdentityProvider::Line),
            "Google" => Ok(IdentityProvider::Google),
            "Behance" => Ok(IdentityProvider::Behance),
            "Yahoo" => Ok(IdentityProvider::Yahoo),
            "Snapchat" => Ok(IdentityProvider::Snapchat),
            "Flickr" => Ok(IdentityProvider::Flickr),
            "Microsoft" => Ok(IdentityProvider::Microsoft),
            "Pinterest" => Ok(IdentityProvider::Pinterest),
            "Signal" => Ok(IdentityProvider::Signal),
            "Qq" => Ok(IdentityProvider::Qq),
            "Whatsapp" => Ok(IdentityProvider::Whatsapp),
            "Paypal" => Ok(IdentityProvider::Paypal),
            "Dribbble" => Ok(IdentityProvider::Dribbble),
            "Github" => Ok(IdentityProvider::Github),
            "Reddit" => Ok(IdentityProvider::Reddit),
            "Instagram" => Ok(IdentityProvider::Instagram),
            "Vimeo" => Ok(IdentityProvider::Vimeo),
            "Linkedin" => Ok(IdentityProvider::Linkedin),
            "Apple" => Ok(IdentityProvider::Apple),
            "Foursquare" => Ok(IdentityProvider::Foursquare),
            "Slack" => Ok(IdentityProvider::Slack),
            "Tiktok" => Ok(IdentityProvider::Tiktok),
            "Facebook" => Ok(IdentityProvider::Facebook),
            "Amazon" => Ok(IdentityProvider::Amazon),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "IdentityProvider",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for IdentityProvider {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            IdentityProvider::Tumblr => "Tumblr",
            IdentityProvider::Discord => "Discord",
            IdentityProvider::Telegram => "Telegram",
            IdentityProvider::Twitter => "Twitter",
            IdentityProvider::Wechat => "Wechat",
            IdentityProvider::Other => "Other",
            IdentityProvider::Line => "Line",
            IdentityProvider::Google => "Google",
            IdentityProvider::Behance => "Behance",
            IdentityProvider::Yahoo => "Yahoo",
            IdentityProvider::Snapchat => "Snapchat",
            IdentityProvider::Flickr => "Flickr",
            IdentityProvider::Microsoft => "Microsoft",
            IdentityProvider::Pinterest => "Pinterest",
            IdentityProvider::Signal => "Signal",
            IdentityProvider::Qq => "Qq",
            IdentityProvider::Whatsapp => "Whatsapp",
            IdentityProvider::Paypal => "Paypal",
            IdentityProvider::Dribbble => "Dribbble",
            IdentityProvider::Github => "Github",
            IdentityProvider::Reddit => "Reddit",
            IdentityProvider::Instagram => "Instagram",
            IdentityProvider::Vimeo => "Vimeo",
            IdentityProvider::Linkedin => "Linkedin",
            IdentityProvider::Apple => "Apple",
            IdentityProvider::Foursquare => "Foursquare",
            IdentityProvider::Slack => "Slack",
            IdentityProvider::Tiktok => "Tiktok",
            IdentityProvider::Facebook => "Facebook",
            IdentityProvider::Amazon => "Amazon",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__IdentityProvider_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tumblr\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tumblr")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Discord\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Discord")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Telegram\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Telegram")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Twitter\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Twitter")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Wechat\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Wechat")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Line\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Line")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Google\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Google")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Behance\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Behance")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Yahoo\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Yahoo")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Snapchat\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Snapchat")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Flickr\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Flickr")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Microsoft\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Microsoft")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Pinterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pinterest")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Signal\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Signal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Qq\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Qq")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Whatsapp\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Whatsapp")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Paypal\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Paypal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Dribbble\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Dribbble")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Github\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Github")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Reddit\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Reddit")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Instagram\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Instagram")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Vimeo\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Vimeo")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Linkedin\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Linkedin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Apple\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Apple")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Foursquare\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Foursquare")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Slack\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Slack")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tiktok\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tiktok")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Facebook\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Facebook")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Amazon\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Amazon")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IdentityProvider\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__IdentityProvider_163() {
    napi::bindgen_prelude::register_module_export(
        None,
        "IdentityProvider\0",
        __register__enum__IdentityProvider_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__IdentityProvider_163___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__IdentityProvider_163___rust_ctor___ctor() -> usize {
        __napi_register__IdentityProvider_163();
        0
    }
    __napi_register__IdentityProvider_163___rust_ctor___ctor
};
pub enum EmploymentAndCandidateStatus {
    OnLeave,
    NotSelected,
    Hired,
    Active,
    Interviewing,
    Terminated,
    Other,
    New,
    InReview,
    OfferExtended,
    Inactive,
}
#[automatically_derived]
impl ::core::marker::Copy for EmploymentAndCandidateStatus {}
#[automatically_derived]
impl ::core::clone::Clone for EmploymentAndCandidateStatus {
    #[inline]
    fn clone(&self) -> EmploymentAndCandidateStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for EmploymentAndCandidateStatus {
    fn type_name() -> &'static str {
        "EmploymentAndCandidateStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for EmploymentAndCandidateStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for EmploymentAndCandidateStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "EmploymentAndCandidateStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "OnLeave" => Ok(EmploymentAndCandidateStatus::OnLeave),
            "NotSelected" => Ok(EmploymentAndCandidateStatus::NotSelected),
            "Hired" => Ok(EmploymentAndCandidateStatus::Hired),
            "Active" => Ok(EmploymentAndCandidateStatus::Active),
            "Interviewing" => Ok(EmploymentAndCandidateStatus::Interviewing),
            "Terminated" => Ok(EmploymentAndCandidateStatus::Terminated),
            "Other" => Ok(EmploymentAndCandidateStatus::Other),
            "New" => Ok(EmploymentAndCandidateStatus::New),
            "InReview" => Ok(EmploymentAndCandidateStatus::InReview),
            "OfferExtended" => Ok(EmploymentAndCandidateStatus::OfferExtended),
            "Inactive" => Ok(EmploymentAndCandidateStatus::Inactive),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "EmploymentAndCandidateStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for EmploymentAndCandidateStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            EmploymentAndCandidateStatus::OnLeave => "OnLeave",
            EmploymentAndCandidateStatus::NotSelected => "NotSelected",
            EmploymentAndCandidateStatus::Hired => "Hired",
            EmploymentAndCandidateStatus::Active => "Active",
            EmploymentAndCandidateStatus::Interviewing => "Interviewing",
            EmploymentAndCandidateStatus::Terminated => "Terminated",
            EmploymentAndCandidateStatus::Other => "Other",
            EmploymentAndCandidateStatus::New => "New",
            EmploymentAndCandidateStatus::InReview => "InReview",
            EmploymentAndCandidateStatus::OfferExtended => "OfferExtended",
            EmploymentAndCandidateStatus::Inactive => "Inactive",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__EmploymentAndCandidateStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("OnLeave\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OnLeave")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "NotSelected\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NotSelected")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Hired\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Hired")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Interviewing\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Interviewing")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Terminated\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Terminated")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("New\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "New")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InReview\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InReview")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OfferExtended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OfferExtended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmploymentAndCandidateStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__EmploymentAndCandidateStatus_164() {
    napi::bindgen_prelude::register_module_export(
        None,
        "EmploymentAndCandidateStatus\0",
        __register__enum__EmploymentAndCandidateStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__EmploymentAndCandidateStatus_164___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__EmploymentAndCandidateStatus_164___rust_ctor___ctor() -> usize {
        __napi_register__EmploymentAndCandidateStatus_164();
        0
    }
    __napi_register__EmploymentAndCandidateStatus_164___rust_ctor___ctor
};
pub enum DayOfWeek {
    Friday,
    Sunday,
    Wednesday,
    Monday,
    Tuesday,
    Saturday,
    Thursday,
}
#[automatically_derived]
impl ::core::marker::Copy for DayOfWeek {}
#[automatically_derived]
impl ::core::clone::Clone for DayOfWeek {
    #[inline]
    fn clone(&self) -> DayOfWeek {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for DayOfWeek {
    fn type_name() -> &'static str {
        "DayOfWeek"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for DayOfWeek {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for DayOfWeek {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "DayOfWeek",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Friday" => Ok(DayOfWeek::Friday),
            "Sunday" => Ok(DayOfWeek::Sunday),
            "Wednesday" => Ok(DayOfWeek::Wednesday),
            "Monday" => Ok(DayOfWeek::Monday),
            "Tuesday" => Ok(DayOfWeek::Tuesday),
            "Saturday" => Ok(DayOfWeek::Saturday),
            "Thursday" => Ok(DayOfWeek::Thursday),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "DayOfWeek",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for DayOfWeek {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            DayOfWeek::Friday => "Friday",
            DayOfWeek::Sunday => "Sunday",
            DayOfWeek::Wednesday => "Wednesday",
            DayOfWeek::Monday => "Monday",
            DayOfWeek::Tuesday => "Tuesday",
            DayOfWeek::Saturday => "Saturday",
            DayOfWeek::Thursday => "Thursday",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__DayOfWeek_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Friday\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Friday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sunday\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sunday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Wednesday\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Wednesday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Monday\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Monday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tuesday\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tuesday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Saturday\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Saturday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Thursday\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Thursday")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DayOfWeek\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__DayOfWeek_165() {
    napi::bindgen_prelude::register_module_export(
        None,
        "DayOfWeek\0",
        __register__enum__DayOfWeek_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__DayOfWeek_165___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__DayOfWeek_165___rust_ctor___ctor() -> usize {
        __napi_register__DayOfWeek_165();
        0
    }
    __napi_register__DayOfWeek_165___rust_ctor___ctor
};
pub enum OrganizationalRole {
    Other,
    Supervisor,
    Admin,
    Contractor,
    Director,
    Manager,
    Employee,
}
#[automatically_derived]
impl ::core::marker::Copy for OrganizationalRole {}
#[automatically_derived]
impl ::core::clone::Clone for OrganizationalRole {
    #[inline]
    fn clone(&self) -> OrganizationalRole {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for OrganizationalRole {
    fn type_name() -> &'static str {
        "OrganizationalRole"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for OrganizationalRole {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for OrganizationalRole {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "OrganizationalRole",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Other" => Ok(OrganizationalRole::Other),
            "Supervisor" => Ok(OrganizationalRole::Supervisor),
            "Admin" => Ok(OrganizationalRole::Admin),
            "Contractor" => Ok(OrganizationalRole::Contractor),
            "Director" => Ok(OrganizationalRole::Director),
            "Manager" => Ok(OrganizationalRole::Manager),
            "Employee" => Ok(OrganizationalRole::Employee),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "OrganizationalRole",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for OrganizationalRole {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            OrganizationalRole::Other => "Other",
            OrganizationalRole::Supervisor => "Supervisor",
            OrganizationalRole::Admin => "Admin",
            OrganizationalRole::Contractor => "Contractor",
            OrganizationalRole::Director => "Director",
            OrganizationalRole::Manager => "Manager",
            OrganizationalRole::Employee => "Employee",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__OrganizationalRole_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Supervisor\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Supervisor")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Admin\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Admin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Contractor\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Contractor")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Director\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Director")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Manager\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Manager")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Employee\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Employee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrganizationalRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__OrganizationalRole_166() {
    napi::bindgen_prelude::register_module_export(
        None,
        "OrganizationalRole\0",
        __register__enum__OrganizationalRole_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__OrganizationalRole_166___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__OrganizationalRole_166___rust_ctor___ctor() -> usize {
        __napi_register__OrganizationalRole_166();
        0
    }
    __napi_register__OrganizationalRole_166___rust_ctor___ctor
};
pub enum ReviewApprovalStatus {
    Rejected,
    InReview,
    Revised,
    Approved,
    Pending,
}
#[automatically_derived]
impl ::core::marker::Copy for ReviewApprovalStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ReviewApprovalStatus {
    #[inline]
    fn clone(&self) -> ReviewApprovalStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ReviewApprovalStatus {
    fn type_name() -> &'static str {
        "ReviewApprovalStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ReviewApprovalStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ReviewApprovalStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ReviewApprovalStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Rejected" => Ok(ReviewApprovalStatus::Rejected),
            "InReview" => Ok(ReviewApprovalStatus::InReview),
            "Revised" => Ok(ReviewApprovalStatus::Revised),
            "Approved" => Ok(ReviewApprovalStatus::Approved),
            "Pending" => Ok(ReviewApprovalStatus::Pending),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ReviewApprovalStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ReviewApprovalStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ReviewApprovalStatus::Rejected => "Rejected",
            ReviewApprovalStatus::InReview => "InReview",
            ReviewApprovalStatus::Revised => "Revised",
            ReviewApprovalStatus::Approved => "Approved",
            ReviewApprovalStatus::Pending => "Pending",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ReviewApprovalStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Rejected\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Rejected")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReviewApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InReview\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InReview")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReviewApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Revised\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Revised")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReviewApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Approved\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Approved")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReviewApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReviewApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ReviewApprovalStatus_167() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ReviewApprovalStatus\0",
        __register__enum__ReviewApprovalStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ReviewApprovalStatus_167___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ReviewApprovalStatus_167___rust_ctor___ctor() -> usize {
        __napi_register__ReviewApprovalStatus_167();
        0
    }
    __napi_register__ReviewApprovalStatus_167___rust_ctor___ctor
};
pub enum AccountEngagementLevel {
    Warm,
    Unknown,
    Hot,
    Cold,
}
#[automatically_derived]
impl ::core::marker::Copy for AccountEngagementLevel {}
#[automatically_derived]
impl ::core::clone::Clone for AccountEngagementLevel {
    #[inline]
    fn clone(&self) -> AccountEngagementLevel {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for AccountEngagementLevel {
    fn type_name() -> &'static str {
        "AccountEngagementLevel"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AccountEngagementLevel {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for AccountEngagementLevel {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "AccountEngagementLevel",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Warm" => Ok(AccountEngagementLevel::Warm),
            "Unknown" => Ok(AccountEngagementLevel::Unknown),
            "Hot" => Ok(AccountEngagementLevel::Hot),
            "Cold" => Ok(AccountEngagementLevel::Cold),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "AccountEngagementLevel",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for AccountEngagementLevel {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            AccountEngagementLevel::Warm => "Warm",
            AccountEngagementLevel::Unknown => "Unknown",
            AccountEngagementLevel::Hot => "Hot",
            AccountEngagementLevel::Cold => "Cold",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__AccountEngagementLevel_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Warm\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Warm")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountEngagementLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Unknown\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Unknown")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountEngagementLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Hot\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Hot")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountEngagementLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Cold\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cold")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountEngagementLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__AccountEngagementLevel_168() {
    napi::bindgen_prelude::register_module_export(
        None,
        "AccountEngagementLevel\0",
        __register__enum__AccountEngagementLevel_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__AccountEngagementLevel_168___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__AccountEngagementLevel_168___rust_ctor___ctor() -> usize {
        __napi_register__AccountEngagementLevel_168();
        0
    }
    __napi_register__AccountEngagementLevel_168___rust_ctor___ctor
};
pub enum StakeholderType {
    Vendor,
    Partner,
    Customer,
    Investor,
    Other,
    Competitor,
}
#[automatically_derived]
impl ::core::marker::Copy for StakeholderType {}
#[automatically_derived]
impl ::core::clone::Clone for StakeholderType {
    #[inline]
    fn clone(&self) -> StakeholderType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for StakeholderType {
    fn type_name() -> &'static str {
        "StakeholderType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for StakeholderType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for StakeholderType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "StakeholderType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Vendor" => Ok(StakeholderType::Vendor),
            "Partner" => Ok(StakeholderType::Partner),
            "Customer" => Ok(StakeholderType::Customer),
            "Investor" => Ok(StakeholderType::Investor),
            "Other" => Ok(StakeholderType::Other),
            "Competitor" => Ok(StakeholderType::Competitor),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "StakeholderType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for StakeholderType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            StakeholderType::Vendor => "Vendor",
            StakeholderType::Partner => "Partner",
            StakeholderType::Customer => "Customer",
            StakeholderType::Investor => "Investor",
            StakeholderType::Other => "Other",
            StakeholderType::Competitor => "Competitor",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__StakeholderType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Vendor\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Vendor")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "StakeholderType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Partner\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Partner")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "StakeholderType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Customer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Customer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "StakeholderType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Investor\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Investor")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "StakeholderType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "StakeholderType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Competitor\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Competitor")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "StakeholderType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__StakeholderType_169() {
    napi::bindgen_prelude::register_module_export(
        None,
        "StakeholderType\0",
        __register__enum__StakeholderType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__StakeholderType_169___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__StakeholderType_169___rust_ctor___ctor() -> usize {
        __napi_register__StakeholderType_169();
        0
    }
    __napi_register__StakeholderType_169___rust_ctor___ctor
};
pub enum CampaignType {
    SearchEngine,
    SocialMedia,
    Display,
    Other,
    Email,
}
#[automatically_derived]
impl ::core::marker::Copy for CampaignType {}
#[automatically_derived]
impl ::core::clone::Clone for CampaignType {
    #[inline]
    fn clone(&self) -> CampaignType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CampaignType {
    fn type_name() -> &'static str {
        "CampaignType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CampaignType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CampaignType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CampaignType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "SearchEngine" => Ok(CampaignType::SearchEngine),
            "SocialMedia" => Ok(CampaignType::SocialMedia),
            "Display" => Ok(CampaignType::Display),
            "Other" => Ok(CampaignType::Other),
            "Email" => Ok(CampaignType::Email),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CampaignType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CampaignType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CampaignType::SearchEngine => "SearchEngine",
            CampaignType::SocialMedia => "SocialMedia",
            CampaignType::Display => "Display",
            CampaignType::Other => "Other",
            CampaignType::Email => "Email",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CampaignType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SearchEngine\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SearchEngine")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SocialMedia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SocialMedia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Display\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Display")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Email\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Email")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CampaignType_170() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CampaignType\0",
        __register__enum__CampaignType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CampaignType_170___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CampaignType_170___rust_ctor___ctor() -> usize {
        __napi_register__CampaignType_170();
        0
    }
    __napi_register__CampaignType_170___rust_ctor___ctor
};
pub enum AccountStatus {
    Pending,
    Inactive,
    Active,
    Closed,
    Suspended,
}
#[automatically_derived]
impl ::core::marker::Copy for AccountStatus {}
#[automatically_derived]
impl ::core::clone::Clone for AccountStatus {
    #[inline]
    fn clone(&self) -> AccountStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for AccountStatus {
    fn type_name() -> &'static str {
        "AccountStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AccountStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for AccountStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "AccountStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Pending" => Ok(AccountStatus::Pending),
            "Inactive" => Ok(AccountStatus::Inactive),
            "Active" => Ok(AccountStatus::Active),
            "Closed" => Ok(AccountStatus::Closed),
            "Suspended" => Ok(AccountStatus::Suspended),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "AccountStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for AccountStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            AccountStatus::Pending => "Pending",
            AccountStatus::Inactive => "Inactive",
            AccountStatus::Active => "Active",
            AccountStatus::Closed => "Closed",
            AccountStatus::Suspended => "Suspended",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__AccountStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Closed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Closed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suspended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suspended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__AccountStatus_171() {
    napi::bindgen_prelude::register_module_export(
        None,
        "AccountStatus\0",
        __register__enum__AccountStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__AccountStatus_171___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__AccountStatus_171___rust_ctor___ctor() -> usize {
        __napi_register__AccountStatus_171();
        0
    }
    __napi_register__AccountStatus_171___rust_ctor___ctor
};
pub enum ContactAddressType {
    Shipping,
    Billing,
    Work,
    Other,
    Personal,
    Business,
    Temporary,
    Home,
}
#[automatically_derived]
impl ::core::marker::Copy for ContactAddressType {}
#[automatically_derived]
impl ::core::clone::Clone for ContactAddressType {
    #[inline]
    fn clone(&self) -> ContactAddressType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ContactAddressType {
    fn type_name() -> &'static str {
        "ContactAddressType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ContactAddressType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ContactAddressType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ContactAddressType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Shipping" => Ok(ContactAddressType::Shipping),
            "Billing" => Ok(ContactAddressType::Billing),
            "Work" => Ok(ContactAddressType::Work),
            "Other" => Ok(ContactAddressType::Other),
            "Personal" => Ok(ContactAddressType::Personal),
            "Business" => Ok(ContactAddressType::Business),
            "Temporary" => Ok(ContactAddressType::Temporary),
            "Home" => Ok(ContactAddressType::Home),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ContactAddressType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ContactAddressType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ContactAddressType::Shipping => "Shipping",
            ContactAddressType::Billing => "Billing",
            ContactAddressType::Work => "Work",
            ContactAddressType::Other => "Other",
            ContactAddressType::Personal => "Personal",
            ContactAddressType::Business => "Business",
            ContactAddressType::Temporary => "Temporary",
            ContactAddressType::Home => "Home",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ContactAddressType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Shipping\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Shipping")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Billing\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Billing")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Work\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Work")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Personal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Personal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Business\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Business")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Temporary\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Temporary")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Home\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Home")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContactAddressType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ContactAddressType_172() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ContactAddressType\0",
        __register__enum__ContactAddressType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ContactAddressType_172___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ContactAddressType_172___rust_ctor___ctor() -> usize {
        __napi_register__ContactAddressType_172();
        0
    }
    __napi_register__ContactAddressType_172___rust_ctor___ctor
};
pub enum CampaignStatus {
    Draft,
    Scheduled,
    Active,
    Cancelled,
    Archived,
    Planned,
    Completed,
    Paused,
}
#[automatically_derived]
impl ::core::marker::Copy for CampaignStatus {}
#[automatically_derived]
impl ::core::clone::Clone for CampaignStatus {
    #[inline]
    fn clone(&self) -> CampaignStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CampaignStatus {
    fn type_name() -> &'static str {
        "CampaignStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CampaignStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CampaignStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CampaignStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Draft" => Ok(CampaignStatus::Draft),
            "Scheduled" => Ok(CampaignStatus::Scheduled),
            "Active" => Ok(CampaignStatus::Active),
            "Cancelled" => Ok(CampaignStatus::Cancelled),
            "Archived" => Ok(CampaignStatus::Archived),
            "Planned" => Ok(CampaignStatus::Planned),
            "Completed" => Ok(CampaignStatus::Completed),
            "Paused" => Ok(CampaignStatus::Paused),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CampaignStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CampaignStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CampaignStatus::Draft => "Draft",
            CampaignStatus::Scheduled => "Scheduled",
            CampaignStatus::Active => "Active",
            CampaignStatus::Cancelled => "Cancelled",
            CampaignStatus::Archived => "Archived",
            CampaignStatus::Planned => "Planned",
            CampaignStatus::Completed => "Completed",
            CampaignStatus::Paused => "Paused",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CampaignStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Draft\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Draft")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Scheduled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Scheduled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Archived\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Archived")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Planned\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Planned")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Completed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Completed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Paused\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Paused")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CampaignStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CampaignStatus_173() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CampaignStatus\0",
        __register__enum__CampaignStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CampaignStatus_173___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CampaignStatus_173___rust_ctor___ctor() -> usize {
        __napi_register__CampaignStatus_173();
        0
    }
    __napi_register__CampaignStatus_173___rust_ctor___ctor
};
pub enum CustomerStatus {
    Active,
    Suspended,
    Archived,
    Pending,
    Inactive,
}
#[automatically_derived]
impl ::core::marker::Copy for CustomerStatus {}
#[automatically_derived]
impl ::core::clone::Clone for CustomerStatus {
    #[inline]
    fn clone(&self) -> CustomerStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CustomerStatus {
    fn type_name() -> &'static str {
        "CustomerStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CustomerStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CustomerStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CustomerStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Active" => Ok(CustomerStatus::Active),
            "Suspended" => Ok(CustomerStatus::Suspended),
            "Archived" => Ok(CustomerStatus::Archived),
            "Pending" => Ok(CustomerStatus::Pending),
            "Inactive" => Ok(CustomerStatus::Inactive),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CustomerStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CustomerStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CustomerStatus::Active => "Active",
            CustomerStatus::Suspended => "Suspended",
            CustomerStatus::Archived => "Archived",
            CustomerStatus::Pending => "Pending",
            CustomerStatus::Inactive => "Inactive",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CustomerStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suspended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suspended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Archived\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Archived")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CustomerStatus_174() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CustomerStatus\0",
        __register__enum__CustomerStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CustomerStatus_174___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CustomerStatus_174___rust_ctor___ctor() -> usize {
        __napi_register__CustomerStatus_174();
        0
    }
    __napi_register__CustomerStatus_174___rust_ctor___ctor
};
pub enum CustomerType {
    Corporate,
    Online,
    Retail,
    B2b,
    B2c,
    Wholesale,
}
#[automatically_derived]
impl ::core::marker::Copy for CustomerType {}
#[automatically_derived]
impl ::core::clone::Clone for CustomerType {
    #[inline]
    fn clone(&self) -> CustomerType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CustomerType {
    fn type_name() -> &'static str {
        "CustomerType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CustomerType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CustomerType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CustomerType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Corporate" => Ok(CustomerType::Corporate),
            "Online" => Ok(CustomerType::Online),
            "Retail" => Ok(CustomerType::Retail),
            "B2b" => Ok(CustomerType::B2b),
            "B2c" => Ok(CustomerType::B2c),
            "Wholesale" => Ok(CustomerType::Wholesale),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CustomerType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CustomerType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CustomerType::Corporate => "Corporate",
            CustomerType::Online => "Online",
            CustomerType::Retail => "Retail",
            CustomerType::B2b => "B2b",
            CustomerType::B2c => "B2c",
            CustomerType::Wholesale => "Wholesale",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CustomerType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Corporate\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Corporate")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Online\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Online")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Retail\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Retail")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("B2b\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "B2b")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("B2c\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "B2c")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Wholesale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Wholesale")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CustomerType_175() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CustomerType\0",
        __register__enum__CustomerType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CustomerType_175___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CustomerType_175___rust_ctor___ctor() -> usize {
        __napi_register__CustomerType_175();
        0
    }
    __napi_register__CustomerType_175___rust_ctor___ctor
};
pub enum SocialPlatform {
    Linkedin,
    Twitter,
    X,
    Pinterest,
    Instagram,
    Snapchat,
    Tiktok,
    Youtube,
    Tumblr,
    Reddit,
    Facebook,
    OtherSocialPlatform,
}
#[automatically_derived]
impl ::core::marker::Copy for SocialPlatform {}
#[automatically_derived]
impl ::core::clone::Clone for SocialPlatform {
    #[inline]
    fn clone(&self) -> SocialPlatform {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for SocialPlatform {
    fn type_name() -> &'static str {
        "SocialPlatform"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for SocialPlatform {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for SocialPlatform {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "SocialPlatform",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Linkedin" => Ok(SocialPlatform::Linkedin),
            "Twitter" => Ok(SocialPlatform::Twitter),
            "X" => Ok(SocialPlatform::X),
            "Pinterest" => Ok(SocialPlatform::Pinterest),
            "Instagram" => Ok(SocialPlatform::Instagram),
            "Snapchat" => Ok(SocialPlatform::Snapchat),
            "Tiktok" => Ok(SocialPlatform::Tiktok),
            "Youtube" => Ok(SocialPlatform::Youtube),
            "Tumblr" => Ok(SocialPlatform::Tumblr),
            "Reddit" => Ok(SocialPlatform::Reddit),
            "Facebook" => Ok(SocialPlatform::Facebook),
            "OtherSocialPlatform" => Ok(SocialPlatform::OtherSocialPlatform),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "SocialPlatform",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for SocialPlatform {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            SocialPlatform::Linkedin => "Linkedin",
            SocialPlatform::Twitter => "Twitter",
            SocialPlatform::X => "X",
            SocialPlatform::Pinterest => "Pinterest",
            SocialPlatform::Instagram => "Instagram",
            SocialPlatform::Snapchat => "Snapchat",
            SocialPlatform::Tiktok => "Tiktok",
            SocialPlatform::Youtube => "Youtube",
            SocialPlatform::Tumblr => "Tumblr",
            SocialPlatform::Reddit => "Reddit",
            SocialPlatform::Facebook => "Facebook",
            SocialPlatform::OtherSocialPlatform => "OtherSocialPlatform",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__SocialPlatform_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Linkedin\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Linkedin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Twitter\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Twitter")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("X\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "X")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Pinterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pinterest")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Instagram\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Instagram")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Snapchat\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Snapchat")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tiktok\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tiktok")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Youtube\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Youtube")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tumblr\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tumblr")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Reddit\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Reddit")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Facebook\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Facebook")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherSocialPlatform\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherSocialPlatform",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SocialPlatform\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__SocialPlatform_176() {
    napi::bindgen_prelude::register_module_export(
        None,
        "SocialPlatform\0",
        __register__enum__SocialPlatform_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__SocialPlatform_176___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__SocialPlatform_176___rust_ctor___ctor() -> usize {
        __napi_register__SocialPlatform_176();
        0
    }
    __napi_register__SocialPlatform_176___rust_ctor___ctor
};
pub enum LeadLifecycleStatus {
    Unqualified,
    AttemptedToContact,
    BadTiming,
    Revisited,
    New,
    Converted,
    Connected,
    Lost,
    Open,
    InProcess,
}
#[automatically_derived]
impl ::core::marker::Copy for LeadLifecycleStatus {}
#[automatically_derived]
impl ::core::clone::Clone for LeadLifecycleStatus {
    #[inline]
    fn clone(&self) -> LeadLifecycleStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for LeadLifecycleStatus {
    fn type_name() -> &'static str {
        "LeadLifecycleStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for LeadLifecycleStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for LeadLifecycleStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "LeadLifecycleStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Unqualified" => Ok(LeadLifecycleStatus::Unqualified),
            "AttemptedToContact" => Ok(LeadLifecycleStatus::AttemptedToContact),
            "BadTiming" => Ok(LeadLifecycleStatus::BadTiming),
            "Revisited" => Ok(LeadLifecycleStatus::Revisited),
            "New" => Ok(LeadLifecycleStatus::New),
            "Converted" => Ok(LeadLifecycleStatus::Converted),
            "Connected" => Ok(LeadLifecycleStatus::Connected),
            "Lost" => Ok(LeadLifecycleStatus::Lost),
            "Open" => Ok(LeadLifecycleStatus::Open),
            "InProcess" => Ok(LeadLifecycleStatus::InProcess),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "LeadLifecycleStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for LeadLifecycleStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            LeadLifecycleStatus::Unqualified => "Unqualified",
            LeadLifecycleStatus::AttemptedToContact => "AttemptedToContact",
            LeadLifecycleStatus::BadTiming => "BadTiming",
            LeadLifecycleStatus::Revisited => "Revisited",
            LeadLifecycleStatus::New => "New",
            LeadLifecycleStatus::Converted => "Converted",
            LeadLifecycleStatus::Connected => "Connected",
            LeadLifecycleStatus::Lost => "Lost",
            LeadLifecycleStatus::Open => "Open",
            LeadLifecycleStatus::InProcess => "InProcess",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__LeadLifecycleStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Unqualified\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Unqualified")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AttemptedToContact\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AttemptedToContact",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BadTiming\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BadTiming")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Revisited\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Revisited")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("New\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "New")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Converted\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Converted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Connected\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Connected")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Lost\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Lost")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Open\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Open")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InProcess\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InProcess")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LeadLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__LeadLifecycleStatus_177() {
    napi::bindgen_prelude::register_module_export(
        None,
        "LeadLifecycleStatus\0",
        __register__enum__LeadLifecycleStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__LeadLifecycleStatus_177___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__LeadLifecycleStatus_177___rust_ctor___ctor() -> usize {
        __napi_register__LeadLifecycleStatus_177();
        0
    }
    __napi_register__LeadLifecycleStatus_177___rust_ctor___ctor
};
pub enum AccountingAccountType {
    AssetLandAsset,
    AssetBalWithGovtAuthorities,
    ExpenseOtherBusinessExpenses,
    OtherCurrentLiabilitySundryDebtorsAndCreditors,
    ExpenseBadDebts,
    AssetLeaseholdImprovements,
    OtherExpenseIncomeTaxOtherExpense,
    ExpenseTravelExpensesGeneralAndAdminExpenses,
    LiabilityLongTermDebit,
    OtherExpenseParkingAndTolls,
    LiabilityShareholderNotesPayable,
    LiabilityOtherLongTermProvisions,
    RevenueSavingsByTaxScheme,
    ExpenseManagementCompensation,
    OtherExpenseMatCredit,
    OtherIncomeOtherMiscellaneousIncome,
    OtherExpenseDepletion,
    ExpenseStaffCosts,
    AssetOtherConsumables,
    LiabilityAccruedVacationPayable,
    AssetFixedAssetOtherToolsEquipment,
    AssetFixedAssetPhotoVideo,
    EquityOtherFreeReserves,
    AssetShortTermInvestmentsInRelatedParties,
    ExpenseIncomeTaxExpense,
    EquityCapitalReserves,
    OtherExpenseOtherVehicleExpenses,
    OtherCurrentLiabilitySocialSecurityAgencies,
    AccountsReceivable,
    AssetFurnitureAndFixtures,
    OtherExpenseExchangeGainOrLoss,
    OtherCurrentLiability,
    AssetInvestmentOther,
    RevenueUnappliedCashPaymentIncome,
    AssetTrustAccounts,
    LiabilityLongTermEmployeeBenefitObligations,
    OtherCurrentLiabilityPrepaidExpensesPayable,
    RevenueOperatingGrants,
    ExpenseInsurance,
    ExpenseOtherRentalCosts,
    EquityInvestmentGrants,
    LiabilityAccrualsAndDeferredIncome,
    AssetAccumulatedDepreciation,
    OtherIncomeDividendIncome,
    AssetFixedAsset,
    AssetEmployeeCashAdvances,
    AssetDepletableAssets,
    AssetOtherAsset,
    EquityHealthcare,
    OtherExpenseVehicleLoanInterest,
    OtherExpenseTaxRoundoffGainOrLoss,
    LiabilityDebtsRelatedToParticipatingInterests,
    ExpenseRepairMaintenance,
    OtherCurrentLiabilityGlobalTaxPayable,
    OtherCurrentLiabilityPayrollTaxPayable,
    AssetChecking,
    EquityPaidInCapitalOrSurplus,
    AssetVehicles,
    ExpensePayrollExpenses,
    CostOfGoodsSoldOtherCostsOfServiceCos,
    AssetUndepositedFunds,
    OtherExpenseVehicleRepairs,
    OtherCurrentLiabilityAccruedLiabilities,
    AssetCapitalWip,
    AssetDevelopmentCosts,
    LiabilityObligationsUnderFinanceLeases,
    OtherCurrentLiabilityFederalIncomeTaxPayable,
    RevenueOwnWorkCapitalized,
    EquityShareApplicationMoneyPendingAllotment,
    AssetInventory,
    AssetInvestmentTaxExemptSecurities,
    AssetLoansToStockholders,
    LiabilityLongTermBorrowings,
    OtherCurrentLiabilityProvisionForWarrantyObligations,
    OtherCurrentLiabilityTrustAccountsLiabilities,
    AssetBuildings,
    ExpenseOfficeGeneralAdministrativeExpenses,
    ExpenseOtherCurrentOperatingCharges,
    AssetFixedAssetSoftware,
    OtherIncome,
    AssetParticipatingInterests,
    AssetAssetsAvailableForSale,
    ExpenseDuesSubscriptions,
    OtherExpenseHomeOwnerRentalInsurance,
    OtherCurrentLiabilityDutiesAndTaxes,
    ExpenseAppropriationsToDepreciation,
    LiabilityProvisionsNonCurrentLiabilities,
    EquityFunds,
    AssetMachineryAndEquipment,
    AssetOtherCurrentAssets,
    CostOfGoodsSoldFreightAndDeliveryCost,
    ExpenseFinanceCosts,
    CostOfGoodsSoldEquipmentRentalCos,
    Asset,
    ExpenseCommissionsAndFees,
    ExpenseLossOnDiscontinuedOperationsNetOfTax,
    AssetSavings,
    ExpenseSundry,
    ExpenseEntertainmentMeals,
    ExpenseExternalServices,
    AssetLongTermLoansAndAdvancesToRelatedParties,
    ExpenseTaxesPaid,
    OtherCurrentLiabilityInterestPayables,
    EquityCommonStock,
    ExpenseCostOfLabor,
    OtherIncomeOtherOperatingIncome,
    AssetLoansToOthers,
    AssetRetainage,
    AssetRentsHeldInTrust,
    AssetInvestmentMortgageRealEstateLoans,
    EquityDividendDisbursed,
    AssetGlobalTaxRefund,
    OtherExpenseVehicleInsurance,
    CostOfGoodsSoldCostOfSales,
    OtherCurrentLiabilityCurrentTaxLiability,
    AssetAssetsHeldForSale,
    EquityPartnerDistributions,
    AssetAssetsInCourseOfConstruction,
    AssetLeaseBuyout,
    ExpenseRentOrLeaseOfBuildings,
    OtherExpenseOtherMiscellaneousExpense,
    OtherExpenseVehicleRegistration,
    OtherExpenseRentAndLease,
    LiabilityLiabilitiesRelatedToAssetsHeldForSale,
    OtherExpenseExtraordinaryItems,
    OtherCurrentLiabilityOtherCurrentLiabilities,
    OtherCurrentLiabilityRentsInTrustLiability,
    AssetProvisionsNonCurrentAssets,
    OtherExpense,
    AssetDeferredTax,
    OtherCurrentLiabilityDividendsPayable,
    OtherIncomeOtherInvestmentIncome,
    OtherExpenseAmortization,
    ExpenseUnappliedCashBillPaymentExpense,
    AssetNonCurrentAssets,
    AssetCashOnHand,
    ExpenseAdvertisingPromotional,
    ExpenseOtherMiscellaneousServiceCost,
    RevenueOtherCurrentOperatingIncome,
    OtherIncomeLossOnDisposalOfAssets,
    ExpenseSuppliesMaterials,
    OtherExpenseVehicleLease,
    AssetGoodwill,
    RevenueSalesOfProductIncome,
    LiabilityProvisionForLiabilities,
    RevenueIncome,
    EquityCalledUpShareCapital,
    OtherExpenseGasAndFuel,
    LiabilityCreditCard,
    ExpenseAmortizationExpense,
    LiabilityAccountsPayable,
    EquityMoneyReceivedAgainstShareWarrants,
    EquityPersonalIncome,
    OtherExpenseWashAndRoadServices,
    OtherIncomeUnrealisedLossOnSecuritiesNetOfTax,
    AssetProvisionsFixedAssets,
    ExpenseInterestPaid,
    RevenueNonProfitIncome,
    CostOfGoodsSoldSuppliesMaterialsCogs,
    ExpenseOfficeExpenses,
    AssetInvestments,
    EquityPartnersEquity,
    AssetAvailableForSaleFinancialAssets,
    AssetOtherLongTermLoansAndAdvances,
    OtherExpensePriorPeriodItems,
    AssetTradeAndOtherReceivables,
    AssetIntangibleAssetsUnderDevelopment,
    RevenueOtherPrimaryIncome,
    OtherCurrentLiabilityTradeAndOtherPayables,
    RevenueSalesRetail,
    EquityPartnerContributions,
    LiabilityNotesPayable,
    AssetExpenditureAuthorisationsAndLettersOfCredit,
    LiabilityGroupAndAssociates,
    AssetCumulativeDepreciationOnIntangibleAssets,
    AssetOtherCurrentAsset,
    OtherExpenseOtherHomeOfficeExpenses,
    Expense,
    AssetCalledUpShareCapitalNotPaid,
    ExpenseTravel,
    OtherExpensePenaltiesSettlements,
    CostOfGoodsSold,
    OtherCurrentLiabilityLoanPayable,
    RevenueRevenueGeneral,
    AssetAccumulatedDepletion,
    AssetOtherFixedAssets,
    AssetPrepaymentsAndAccruedIncome,
    OtherIncomeInterestEarned,
    AssetLicenses,
    EquityAccumulatedOtherComprehensiveIncome,
    ExpenseExtraordinaryCharges,
    AssetCashAndCashEquivalents,
    OtherCurrentLiabilitySalesTaxPayable,
    EquityEquityInEarningsOfSubsidiuaries,
    AssetOrganizationalCosts,
    ExpenseOtherExternalServices,
    AssetAccumulatedAmortizationOfOtherAssets,
    OtherExpenseMortgageInterest,
    OtherCurrentLiabilityStateLocalIncomeTaxPayable,
    ExpensePurchasesRebates,
    EquityAccumulatedAdjustment,
    OtherCurrentLiabilityInsurancePayable,
    ExpenseShippingFreightDelivery,
    AssetAllowanceForBadDebts,
    LiabilityStaffAndRelatedLongTermLiabilityAccounts,
    OtherExpenseVehicleLoan,
    OtherCurrentLiabilityCurrentLiabilities,
    OtherExpenseHomeOffice,
    OtherExpenseRepairsAndMaintenance,
    LiabilityOutstandingDuesOtherThanMicroSmallEnterprise,
    OtherCurrentLiabilityProvisionsCurrentLiabilities,
    OtherIncomeTaxExemptInterest,
    EquityPreferredStock,
    AssetOtherLongTermAssets,
    ExpenseDistributionCosts,
    AssetMoneyMarket,
    CostOfGoodsSoldCostOfLaborCos,
    AssetInvestmentUsGovernmentObligations,
    LiabilityOutstandingDuesMicroSmallEnterprise,
    ExpenseOtherSellingExpenses,
    EquityOpeningBalanceEquity,
    ExpenseUtilities,
    OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations,
    ExpenseTravelExpensesSellingExpense,
    EquityTreasuryStock,
    AssetLongTermInvestments,
    ExpenseEquipmentRental,
    OtherExpenseUtilities,
    AssetOtherIntangibleAssets,
    OtherCurrentLiabilityShortTermBorrowings,
    ExpenseCharitableContributions,
    OtherCurrentLiabilityLineOfCredit,
    EquityPersonalExpense,
    LiabilityAccruedLongTermLiabilities,
    AssetAccumulatedAmortization,
    OtherExpenseDeferredTaxExpense,
    AssetLoansToOfficers,
    AssetOtherLongTermInvestments,
    OtherExpenseDepreciation,
    LiabilityDeferredTaxLiabilities,
    EquityOwnersEquity,
    EquityShareCapital,
    RevenueSalesWholesale,
    AssetGlobalTaxDeferred,
    RevenueDiscountsRefundsGiven,
    LiabilityBankLoans,
    AssetProvisionsCurrentAssets,
    AssetPrepaidExpenses,
    LiabilityGovernmentAndOtherPublicAuthorities,
    RevenueCashReceiptIncome,
    OtherExpenseExceptionalItems,
    AssetFixedAssetCopiers,
    OtherCurrentLiabilityGlobalTaxSuspense,
    AssetBank,
    ExpenseEntertainment,
    ExpenseGlobalTaxExpense,
    OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts,
    AssetIntangibleAssets,
    ExpensePromotionalMeals,
    AssetShortTermLoansAndAdvancesToRelatedParties,
    ExpenseBorrowingCost,
    ExpenseShippingAndDeliveryExpense,
    LiabilityLongTermLiability,
    RevenueServiceFeeIncome,
    ExpenseProjectStudiesSurveysAssessments,
    OtherIncomeGainLossOnSaleOfFixedAssets,
    ExpenseLegalProfessionalFees,
    Equity,
    OtherExpenseVehicle,
    OtherCurrentLiabilityPayrollClearing,
    ExpenseBankCharges,
    AssetOtherEarMarkedBankAccounts,
    ExpenseAuto,
    AssetFixedAssetFurniture,
    OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases,
    AssetLand,
    OtherIncomeGainLossOnSaleOfInvestments,
    AssetFixedAssetPhone,
    EquityEstimatedTaxes,
    AssetSecurityDeposits,
    CostOfGoodsSoldShippingFreightDeliveryCos,
    EquityRetainedEarnings,
    AssetInternalTransfers,
    LiabilityOtherLongTermLiabilities,
    AssetFixedAssetComputers,
    ExpenseTravelMeals,
    OtherCurrentLiabilityDirectDepositPayable,
}
#[automatically_derived]
impl ::core::marker::Copy for AccountingAccountType {}
#[automatically_derived]
impl ::core::clone::Clone for AccountingAccountType {
    #[inline]
    fn clone(&self) -> AccountingAccountType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for AccountingAccountType {
    fn type_name() -> &'static str {
        "AccountingAccountType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AccountingAccountType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for AccountingAccountType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "AccountingAccountType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "AssetLandAsset" => Ok(AccountingAccountType::AssetLandAsset),
            "AssetBalWithGovtAuthorities" => {
                Ok(AccountingAccountType::AssetBalWithGovtAuthorities)
            }
            "ExpenseOtherBusinessExpenses" => {
                Ok(AccountingAccountType::ExpenseOtherBusinessExpenses)
            }
            "OtherCurrentLiabilitySundryDebtorsAndCreditors" => {
                Ok(AccountingAccountType::OtherCurrentLiabilitySundryDebtorsAndCreditors)
            }
            "ExpenseBadDebts" => Ok(AccountingAccountType::ExpenseBadDebts),
            "AssetLeaseholdImprovements" => {
                Ok(AccountingAccountType::AssetLeaseholdImprovements)
            }
            "OtherExpenseIncomeTaxOtherExpense" => {
                Ok(AccountingAccountType::OtherExpenseIncomeTaxOtherExpense)
            }
            "ExpenseTravelExpensesGeneralAndAdminExpenses" => {
                Ok(AccountingAccountType::ExpenseTravelExpensesGeneralAndAdminExpenses)
            }
            "LiabilityLongTermDebit" => Ok(AccountingAccountType::LiabilityLongTermDebit),
            "OtherExpenseParkingAndTolls" => {
                Ok(AccountingAccountType::OtherExpenseParkingAndTolls)
            }
            "LiabilityShareholderNotesPayable" => {
                Ok(AccountingAccountType::LiabilityShareholderNotesPayable)
            }
            "LiabilityOtherLongTermProvisions" => {
                Ok(AccountingAccountType::LiabilityOtherLongTermProvisions)
            }
            "RevenueSavingsByTaxScheme" => {
                Ok(AccountingAccountType::RevenueSavingsByTaxScheme)
            }
            "ExpenseManagementCompensation" => {
                Ok(AccountingAccountType::ExpenseManagementCompensation)
            }
            "OtherExpenseMatCredit" => Ok(AccountingAccountType::OtherExpenseMatCredit),
            "OtherIncomeOtherMiscellaneousIncome" => {
                Ok(AccountingAccountType::OtherIncomeOtherMiscellaneousIncome)
            }
            "OtherExpenseDepletion" => Ok(AccountingAccountType::OtherExpenseDepletion),
            "ExpenseStaffCosts" => Ok(AccountingAccountType::ExpenseStaffCosts),
            "AssetOtherConsumables" => Ok(AccountingAccountType::AssetOtherConsumables),
            "LiabilityAccruedVacationPayable" => {
                Ok(AccountingAccountType::LiabilityAccruedVacationPayable)
            }
            "AssetFixedAssetOtherToolsEquipment" => {
                Ok(AccountingAccountType::AssetFixedAssetOtherToolsEquipment)
            }
            "AssetFixedAssetPhotoVideo" => {
                Ok(AccountingAccountType::AssetFixedAssetPhotoVideo)
            }
            "EquityOtherFreeReserves" => {
                Ok(AccountingAccountType::EquityOtherFreeReserves)
            }
            "AssetShortTermInvestmentsInRelatedParties" => {
                Ok(AccountingAccountType::AssetShortTermInvestmentsInRelatedParties)
            }
            "ExpenseIncomeTaxExpense" => {
                Ok(AccountingAccountType::ExpenseIncomeTaxExpense)
            }
            "EquityCapitalReserves" => Ok(AccountingAccountType::EquityCapitalReserves),
            "OtherExpenseOtherVehicleExpenses" => {
                Ok(AccountingAccountType::OtherExpenseOtherVehicleExpenses)
            }
            "OtherCurrentLiabilitySocialSecurityAgencies" => {
                Ok(AccountingAccountType::OtherCurrentLiabilitySocialSecurityAgencies)
            }
            "AccountsReceivable" => Ok(AccountingAccountType::AccountsReceivable),
            "AssetFurnitureAndFixtures" => {
                Ok(AccountingAccountType::AssetFurnitureAndFixtures)
            }
            "OtherExpenseExchangeGainOrLoss" => {
                Ok(AccountingAccountType::OtherExpenseExchangeGainOrLoss)
            }
            "OtherCurrentLiability" => Ok(AccountingAccountType::OtherCurrentLiability),
            "AssetInvestmentOther" => Ok(AccountingAccountType::AssetInvestmentOther),
            "RevenueUnappliedCashPaymentIncome" => {
                Ok(AccountingAccountType::RevenueUnappliedCashPaymentIncome)
            }
            "AssetTrustAccounts" => Ok(AccountingAccountType::AssetTrustAccounts),
            "LiabilityLongTermEmployeeBenefitObligations" => {
                Ok(AccountingAccountType::LiabilityLongTermEmployeeBenefitObligations)
            }
            "OtherCurrentLiabilityPrepaidExpensesPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityPrepaidExpensesPayable)
            }
            "RevenueOperatingGrants" => Ok(AccountingAccountType::RevenueOperatingGrants),
            "ExpenseInsurance" => Ok(AccountingAccountType::ExpenseInsurance),
            "ExpenseOtherRentalCosts" => {
                Ok(AccountingAccountType::ExpenseOtherRentalCosts)
            }
            "EquityInvestmentGrants" => Ok(AccountingAccountType::EquityInvestmentGrants),
            "LiabilityAccrualsAndDeferredIncome" => {
                Ok(AccountingAccountType::LiabilityAccrualsAndDeferredIncome)
            }
            "AssetAccumulatedDepreciation" => {
                Ok(AccountingAccountType::AssetAccumulatedDepreciation)
            }
            "OtherIncomeDividendIncome" => {
                Ok(AccountingAccountType::OtherIncomeDividendIncome)
            }
            "AssetFixedAsset" => Ok(AccountingAccountType::AssetFixedAsset),
            "AssetEmployeeCashAdvances" => {
                Ok(AccountingAccountType::AssetEmployeeCashAdvances)
            }
            "AssetDepletableAssets" => Ok(AccountingAccountType::AssetDepletableAssets),
            "AssetOtherAsset" => Ok(AccountingAccountType::AssetOtherAsset),
            "EquityHealthcare" => Ok(AccountingAccountType::EquityHealthcare),
            "OtherExpenseVehicleLoanInterest" => {
                Ok(AccountingAccountType::OtherExpenseVehicleLoanInterest)
            }
            "OtherExpenseTaxRoundoffGainOrLoss" => {
                Ok(AccountingAccountType::OtherExpenseTaxRoundoffGainOrLoss)
            }
            "LiabilityDebtsRelatedToParticipatingInterests" => {
                Ok(AccountingAccountType::LiabilityDebtsRelatedToParticipatingInterests)
            }
            "ExpenseRepairMaintenance" => {
                Ok(AccountingAccountType::ExpenseRepairMaintenance)
            }
            "OtherCurrentLiabilityGlobalTaxPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityGlobalTaxPayable)
            }
            "OtherCurrentLiabilityPayrollTaxPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityPayrollTaxPayable)
            }
            "AssetChecking" => Ok(AccountingAccountType::AssetChecking),
            "EquityPaidInCapitalOrSurplus" => {
                Ok(AccountingAccountType::EquityPaidInCapitalOrSurplus)
            }
            "AssetVehicles" => Ok(AccountingAccountType::AssetVehicles),
            "ExpensePayrollExpenses" => Ok(AccountingAccountType::ExpensePayrollExpenses),
            "CostOfGoodsSoldOtherCostsOfServiceCos" => {
                Ok(AccountingAccountType::CostOfGoodsSoldOtherCostsOfServiceCos)
            }
            "AssetUndepositedFunds" => Ok(AccountingAccountType::AssetUndepositedFunds),
            "OtherExpenseVehicleRepairs" => {
                Ok(AccountingAccountType::OtherExpenseVehicleRepairs)
            }
            "OtherCurrentLiabilityAccruedLiabilities" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityAccruedLiabilities)
            }
            "AssetCapitalWip" => Ok(AccountingAccountType::AssetCapitalWip),
            "AssetDevelopmentCosts" => Ok(AccountingAccountType::AssetDevelopmentCosts),
            "LiabilityObligationsUnderFinanceLeases" => {
                Ok(AccountingAccountType::LiabilityObligationsUnderFinanceLeases)
            }
            "OtherCurrentLiabilityFederalIncomeTaxPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityFederalIncomeTaxPayable)
            }
            "RevenueOwnWorkCapitalized" => {
                Ok(AccountingAccountType::RevenueOwnWorkCapitalized)
            }
            "EquityShareApplicationMoneyPendingAllotment" => {
                Ok(AccountingAccountType::EquityShareApplicationMoneyPendingAllotment)
            }
            "AssetInventory" => Ok(AccountingAccountType::AssetInventory),
            "AssetInvestmentTaxExemptSecurities" => {
                Ok(AccountingAccountType::AssetInvestmentTaxExemptSecurities)
            }
            "AssetLoansToStockholders" => {
                Ok(AccountingAccountType::AssetLoansToStockholders)
            }
            "LiabilityLongTermBorrowings" => {
                Ok(AccountingAccountType::LiabilityLongTermBorrowings)
            }
            "OtherCurrentLiabilityProvisionForWarrantyObligations" => {
                Ok(
                    AccountingAccountType::OtherCurrentLiabilityProvisionForWarrantyObligations,
                )
            }
            "OtherCurrentLiabilityTrustAccountsLiabilities" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityTrustAccountsLiabilities)
            }
            "AssetBuildings" => Ok(AccountingAccountType::AssetBuildings),
            "ExpenseOfficeGeneralAdministrativeExpenses" => {
                Ok(AccountingAccountType::ExpenseOfficeGeneralAdministrativeExpenses)
            }
            "ExpenseOtherCurrentOperatingCharges" => {
                Ok(AccountingAccountType::ExpenseOtherCurrentOperatingCharges)
            }
            "AssetFixedAssetSoftware" => {
                Ok(AccountingAccountType::AssetFixedAssetSoftware)
            }
            "OtherIncome" => Ok(AccountingAccountType::OtherIncome),
            "AssetParticipatingInterests" => {
                Ok(AccountingAccountType::AssetParticipatingInterests)
            }
            "AssetAssetsAvailableForSale" => {
                Ok(AccountingAccountType::AssetAssetsAvailableForSale)
            }
            "ExpenseDuesSubscriptions" => {
                Ok(AccountingAccountType::ExpenseDuesSubscriptions)
            }
            "OtherExpenseHomeOwnerRentalInsurance" => {
                Ok(AccountingAccountType::OtherExpenseHomeOwnerRentalInsurance)
            }
            "OtherCurrentLiabilityDutiesAndTaxes" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityDutiesAndTaxes)
            }
            "ExpenseAppropriationsToDepreciation" => {
                Ok(AccountingAccountType::ExpenseAppropriationsToDepreciation)
            }
            "LiabilityProvisionsNonCurrentLiabilities" => {
                Ok(AccountingAccountType::LiabilityProvisionsNonCurrentLiabilities)
            }
            "EquityFunds" => Ok(AccountingAccountType::EquityFunds),
            "AssetMachineryAndEquipment" => {
                Ok(AccountingAccountType::AssetMachineryAndEquipment)
            }
            "AssetOtherCurrentAssets" => {
                Ok(AccountingAccountType::AssetOtherCurrentAssets)
            }
            "CostOfGoodsSoldFreightAndDeliveryCost" => {
                Ok(AccountingAccountType::CostOfGoodsSoldFreightAndDeliveryCost)
            }
            "ExpenseFinanceCosts" => Ok(AccountingAccountType::ExpenseFinanceCosts),
            "CostOfGoodsSoldEquipmentRentalCos" => {
                Ok(AccountingAccountType::CostOfGoodsSoldEquipmentRentalCos)
            }
            "Asset" => Ok(AccountingAccountType::Asset),
            "ExpenseCommissionsAndFees" => {
                Ok(AccountingAccountType::ExpenseCommissionsAndFees)
            }
            "ExpenseLossOnDiscontinuedOperationsNetOfTax" => {
                Ok(AccountingAccountType::ExpenseLossOnDiscontinuedOperationsNetOfTax)
            }
            "AssetSavings" => Ok(AccountingAccountType::AssetSavings),
            "ExpenseSundry" => Ok(AccountingAccountType::ExpenseSundry),
            "ExpenseEntertainmentMeals" => {
                Ok(AccountingAccountType::ExpenseEntertainmentMeals)
            }
            "ExpenseExternalServices" => {
                Ok(AccountingAccountType::ExpenseExternalServices)
            }
            "AssetLongTermLoansAndAdvancesToRelatedParties" => {
                Ok(AccountingAccountType::AssetLongTermLoansAndAdvancesToRelatedParties)
            }
            "ExpenseTaxesPaid" => Ok(AccountingAccountType::ExpenseTaxesPaid),
            "OtherCurrentLiabilityInterestPayables" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityInterestPayables)
            }
            "EquityCommonStock" => Ok(AccountingAccountType::EquityCommonStock),
            "ExpenseCostOfLabor" => Ok(AccountingAccountType::ExpenseCostOfLabor),
            "OtherIncomeOtherOperatingIncome" => {
                Ok(AccountingAccountType::OtherIncomeOtherOperatingIncome)
            }
            "AssetLoansToOthers" => Ok(AccountingAccountType::AssetLoansToOthers),
            "AssetRetainage" => Ok(AccountingAccountType::AssetRetainage),
            "AssetRentsHeldInTrust" => Ok(AccountingAccountType::AssetRentsHeldInTrust),
            "AssetInvestmentMortgageRealEstateLoans" => {
                Ok(AccountingAccountType::AssetInvestmentMortgageRealEstateLoans)
            }
            "EquityDividendDisbursed" => {
                Ok(AccountingAccountType::EquityDividendDisbursed)
            }
            "AssetGlobalTaxRefund" => Ok(AccountingAccountType::AssetGlobalTaxRefund),
            "OtherExpenseVehicleInsurance" => {
                Ok(AccountingAccountType::OtherExpenseVehicleInsurance)
            }
            "CostOfGoodsSoldCostOfSales" => {
                Ok(AccountingAccountType::CostOfGoodsSoldCostOfSales)
            }
            "OtherCurrentLiabilityCurrentTaxLiability" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityCurrentTaxLiability)
            }
            "AssetAssetsHeldForSale" => Ok(AccountingAccountType::AssetAssetsHeldForSale),
            "EquityPartnerDistributions" => {
                Ok(AccountingAccountType::EquityPartnerDistributions)
            }
            "AssetAssetsInCourseOfConstruction" => {
                Ok(AccountingAccountType::AssetAssetsInCourseOfConstruction)
            }
            "AssetLeaseBuyout" => Ok(AccountingAccountType::AssetLeaseBuyout),
            "ExpenseRentOrLeaseOfBuildings" => {
                Ok(AccountingAccountType::ExpenseRentOrLeaseOfBuildings)
            }
            "OtherExpenseOtherMiscellaneousExpense" => {
                Ok(AccountingAccountType::OtherExpenseOtherMiscellaneousExpense)
            }
            "OtherExpenseVehicleRegistration" => {
                Ok(AccountingAccountType::OtherExpenseVehicleRegistration)
            }
            "OtherExpenseRentAndLease" => {
                Ok(AccountingAccountType::OtherExpenseRentAndLease)
            }
            "LiabilityLiabilitiesRelatedToAssetsHeldForSale" => {
                Ok(AccountingAccountType::LiabilityLiabilitiesRelatedToAssetsHeldForSale)
            }
            "OtherExpenseExtraordinaryItems" => {
                Ok(AccountingAccountType::OtherExpenseExtraordinaryItems)
            }
            "OtherCurrentLiabilityOtherCurrentLiabilities" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityOtherCurrentLiabilities)
            }
            "OtherCurrentLiabilityRentsInTrustLiability" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityRentsInTrustLiability)
            }
            "AssetProvisionsNonCurrentAssets" => {
                Ok(AccountingAccountType::AssetProvisionsNonCurrentAssets)
            }
            "OtherExpense" => Ok(AccountingAccountType::OtherExpense),
            "AssetDeferredTax" => Ok(AccountingAccountType::AssetDeferredTax),
            "OtherCurrentLiabilityDividendsPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityDividendsPayable)
            }
            "OtherIncomeOtherInvestmentIncome" => {
                Ok(AccountingAccountType::OtherIncomeOtherInvestmentIncome)
            }
            "OtherExpenseAmortization" => {
                Ok(AccountingAccountType::OtherExpenseAmortization)
            }
            "ExpenseUnappliedCashBillPaymentExpense" => {
                Ok(AccountingAccountType::ExpenseUnappliedCashBillPaymentExpense)
            }
            "AssetNonCurrentAssets" => Ok(AccountingAccountType::AssetNonCurrentAssets),
            "AssetCashOnHand" => Ok(AccountingAccountType::AssetCashOnHand),
            "ExpenseAdvertisingPromotional" => {
                Ok(AccountingAccountType::ExpenseAdvertisingPromotional)
            }
            "ExpenseOtherMiscellaneousServiceCost" => {
                Ok(AccountingAccountType::ExpenseOtherMiscellaneousServiceCost)
            }
            "RevenueOtherCurrentOperatingIncome" => {
                Ok(AccountingAccountType::RevenueOtherCurrentOperatingIncome)
            }
            "OtherIncomeLossOnDisposalOfAssets" => {
                Ok(AccountingAccountType::OtherIncomeLossOnDisposalOfAssets)
            }
            "ExpenseSuppliesMaterials" => {
                Ok(AccountingAccountType::ExpenseSuppliesMaterials)
            }
            "OtherExpenseVehicleLease" => {
                Ok(AccountingAccountType::OtherExpenseVehicleLease)
            }
            "AssetGoodwill" => Ok(AccountingAccountType::AssetGoodwill),
            "RevenueSalesOfProductIncome" => {
                Ok(AccountingAccountType::RevenueSalesOfProductIncome)
            }
            "LiabilityProvisionForLiabilities" => {
                Ok(AccountingAccountType::LiabilityProvisionForLiabilities)
            }
            "RevenueIncome" => Ok(AccountingAccountType::RevenueIncome),
            "EquityCalledUpShareCapital" => {
                Ok(AccountingAccountType::EquityCalledUpShareCapital)
            }
            "OtherExpenseGasAndFuel" => Ok(AccountingAccountType::OtherExpenseGasAndFuel),
            "LiabilityCreditCard" => Ok(AccountingAccountType::LiabilityCreditCard),
            "ExpenseAmortizationExpense" => {
                Ok(AccountingAccountType::ExpenseAmortizationExpense)
            }
            "LiabilityAccountsPayable" => {
                Ok(AccountingAccountType::LiabilityAccountsPayable)
            }
            "EquityMoneyReceivedAgainstShareWarrants" => {
                Ok(AccountingAccountType::EquityMoneyReceivedAgainstShareWarrants)
            }
            "EquityPersonalIncome" => Ok(AccountingAccountType::EquityPersonalIncome),
            "OtherExpenseWashAndRoadServices" => {
                Ok(AccountingAccountType::OtherExpenseWashAndRoadServices)
            }
            "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax" => {
                Ok(AccountingAccountType::OtherIncomeUnrealisedLossOnSecuritiesNetOfTax)
            }
            "AssetProvisionsFixedAssets" => {
                Ok(AccountingAccountType::AssetProvisionsFixedAssets)
            }
            "ExpenseInterestPaid" => Ok(AccountingAccountType::ExpenseInterestPaid),
            "RevenueNonProfitIncome" => Ok(AccountingAccountType::RevenueNonProfitIncome),
            "CostOfGoodsSoldSuppliesMaterialsCogs" => {
                Ok(AccountingAccountType::CostOfGoodsSoldSuppliesMaterialsCogs)
            }
            "ExpenseOfficeExpenses" => Ok(AccountingAccountType::ExpenseOfficeExpenses),
            "AssetInvestments" => Ok(AccountingAccountType::AssetInvestments),
            "EquityPartnersEquity" => Ok(AccountingAccountType::EquityPartnersEquity),
            "AssetAvailableForSaleFinancialAssets" => {
                Ok(AccountingAccountType::AssetAvailableForSaleFinancialAssets)
            }
            "AssetOtherLongTermLoansAndAdvances" => {
                Ok(AccountingAccountType::AssetOtherLongTermLoansAndAdvances)
            }
            "OtherExpensePriorPeriodItems" => {
                Ok(AccountingAccountType::OtherExpensePriorPeriodItems)
            }
            "AssetTradeAndOtherReceivables" => {
                Ok(AccountingAccountType::AssetTradeAndOtherReceivables)
            }
            "AssetIntangibleAssetsUnderDevelopment" => {
                Ok(AccountingAccountType::AssetIntangibleAssetsUnderDevelopment)
            }
            "RevenueOtherPrimaryIncome" => {
                Ok(AccountingAccountType::RevenueOtherPrimaryIncome)
            }
            "OtherCurrentLiabilityTradeAndOtherPayables" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityTradeAndOtherPayables)
            }
            "RevenueSalesRetail" => Ok(AccountingAccountType::RevenueSalesRetail),
            "EquityPartnerContributions" => {
                Ok(AccountingAccountType::EquityPartnerContributions)
            }
            "LiabilityNotesPayable" => Ok(AccountingAccountType::LiabilityNotesPayable),
            "AssetExpenditureAuthorisationsAndLettersOfCredit" => {
                Ok(
                    AccountingAccountType::AssetExpenditureAuthorisationsAndLettersOfCredit,
                )
            }
            "LiabilityGroupAndAssociates" => {
                Ok(AccountingAccountType::LiabilityGroupAndAssociates)
            }
            "AssetCumulativeDepreciationOnIntangibleAssets" => {
                Ok(AccountingAccountType::AssetCumulativeDepreciationOnIntangibleAssets)
            }
            "AssetOtherCurrentAsset" => Ok(AccountingAccountType::AssetOtherCurrentAsset),
            "OtherExpenseOtherHomeOfficeExpenses" => {
                Ok(AccountingAccountType::OtherExpenseOtherHomeOfficeExpenses)
            }
            "Expense" => Ok(AccountingAccountType::Expense),
            "AssetCalledUpShareCapitalNotPaid" => {
                Ok(AccountingAccountType::AssetCalledUpShareCapitalNotPaid)
            }
            "ExpenseTravel" => Ok(AccountingAccountType::ExpenseTravel),
            "OtherExpensePenaltiesSettlements" => {
                Ok(AccountingAccountType::OtherExpensePenaltiesSettlements)
            }
            "CostOfGoodsSold" => Ok(AccountingAccountType::CostOfGoodsSold),
            "OtherCurrentLiabilityLoanPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityLoanPayable)
            }
            "RevenueRevenueGeneral" => Ok(AccountingAccountType::RevenueRevenueGeneral),
            "AssetAccumulatedDepletion" => {
                Ok(AccountingAccountType::AssetAccumulatedDepletion)
            }
            "AssetOtherFixedAssets" => Ok(AccountingAccountType::AssetOtherFixedAssets),
            "AssetPrepaymentsAndAccruedIncome" => {
                Ok(AccountingAccountType::AssetPrepaymentsAndAccruedIncome)
            }
            "OtherIncomeInterestEarned" => {
                Ok(AccountingAccountType::OtherIncomeInterestEarned)
            }
            "AssetLicenses" => Ok(AccountingAccountType::AssetLicenses),
            "EquityAccumulatedOtherComprehensiveIncome" => {
                Ok(AccountingAccountType::EquityAccumulatedOtherComprehensiveIncome)
            }
            "ExpenseExtraordinaryCharges" => {
                Ok(AccountingAccountType::ExpenseExtraordinaryCharges)
            }
            "AssetCashAndCashEquivalents" => {
                Ok(AccountingAccountType::AssetCashAndCashEquivalents)
            }
            "OtherCurrentLiabilitySalesTaxPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilitySalesTaxPayable)
            }
            "EquityEquityInEarningsOfSubsidiuaries" => {
                Ok(AccountingAccountType::EquityEquityInEarningsOfSubsidiuaries)
            }
            "AssetOrganizationalCosts" => {
                Ok(AccountingAccountType::AssetOrganizationalCosts)
            }
            "ExpenseOtherExternalServices" => {
                Ok(AccountingAccountType::ExpenseOtherExternalServices)
            }
            "AssetAccumulatedAmortizationOfOtherAssets" => {
                Ok(AccountingAccountType::AssetAccumulatedAmortizationOfOtherAssets)
            }
            "OtherExpenseMortgageInterest" => {
                Ok(AccountingAccountType::OtherExpenseMortgageInterest)
            }
            "OtherCurrentLiabilityStateLocalIncomeTaxPayable" => {
                Ok(
                    AccountingAccountType::OtherCurrentLiabilityStateLocalIncomeTaxPayable,
                )
            }
            "ExpensePurchasesRebates" => {
                Ok(AccountingAccountType::ExpensePurchasesRebates)
            }
            "EquityAccumulatedAdjustment" => {
                Ok(AccountingAccountType::EquityAccumulatedAdjustment)
            }
            "OtherCurrentLiabilityInsurancePayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityInsurancePayable)
            }
            "ExpenseShippingFreightDelivery" => {
                Ok(AccountingAccountType::ExpenseShippingFreightDelivery)
            }
            "AssetAllowanceForBadDebts" => {
                Ok(AccountingAccountType::AssetAllowanceForBadDebts)
            }
            "LiabilityStaffAndRelatedLongTermLiabilityAccounts" => {
                Ok(
                    AccountingAccountType::LiabilityStaffAndRelatedLongTermLiabilityAccounts,
                )
            }
            "OtherExpenseVehicleLoan" => {
                Ok(AccountingAccountType::OtherExpenseVehicleLoan)
            }
            "OtherCurrentLiabilityCurrentLiabilities" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityCurrentLiabilities)
            }
            "OtherExpenseHomeOffice" => Ok(AccountingAccountType::OtherExpenseHomeOffice),
            "OtherExpenseRepairsAndMaintenance" => {
                Ok(AccountingAccountType::OtherExpenseRepairsAndMaintenance)
            }
            "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise" => {
                Ok(
                    AccountingAccountType::LiabilityOutstandingDuesOtherThanMicroSmallEnterprise,
                )
            }
            "OtherCurrentLiabilityProvisionsCurrentLiabilities" => {
                Ok(
                    AccountingAccountType::OtherCurrentLiabilityProvisionsCurrentLiabilities,
                )
            }
            "OtherIncomeTaxExemptInterest" => {
                Ok(AccountingAccountType::OtherIncomeTaxExemptInterest)
            }
            "EquityPreferredStock" => Ok(AccountingAccountType::EquityPreferredStock),
            "AssetOtherLongTermAssets" => {
                Ok(AccountingAccountType::AssetOtherLongTermAssets)
            }
            "ExpenseDistributionCosts" => {
                Ok(AccountingAccountType::ExpenseDistributionCosts)
            }
            "AssetMoneyMarket" => Ok(AccountingAccountType::AssetMoneyMarket),
            "CostOfGoodsSoldCostOfLaborCos" => {
                Ok(AccountingAccountType::CostOfGoodsSoldCostOfLaborCos)
            }
            "AssetInvestmentUsGovernmentObligations" => {
                Ok(AccountingAccountType::AssetInvestmentUsGovernmentObligations)
            }
            "LiabilityOutstandingDuesMicroSmallEnterprise" => {
                Ok(AccountingAccountType::LiabilityOutstandingDuesMicroSmallEnterprise)
            }
            "ExpenseOtherSellingExpenses" => {
                Ok(AccountingAccountType::ExpenseOtherSellingExpenses)
            }
            "EquityOpeningBalanceEquity" => {
                Ok(AccountingAccountType::EquityOpeningBalanceEquity)
            }
            "ExpenseUtilities" => Ok(AccountingAccountType::ExpenseUtilities),
            "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations" => {
                Ok(
                    AccountingAccountType::OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations,
                )
            }
            "ExpenseTravelExpensesSellingExpense" => {
                Ok(AccountingAccountType::ExpenseTravelExpensesSellingExpense)
            }
            "EquityTreasuryStock" => Ok(AccountingAccountType::EquityTreasuryStock),
            "AssetLongTermInvestments" => {
                Ok(AccountingAccountType::AssetLongTermInvestments)
            }
            "ExpenseEquipmentRental" => Ok(AccountingAccountType::ExpenseEquipmentRental),
            "OtherExpenseUtilities" => Ok(AccountingAccountType::OtherExpenseUtilities),
            "AssetOtherIntangibleAssets" => {
                Ok(AccountingAccountType::AssetOtherIntangibleAssets)
            }
            "OtherCurrentLiabilityShortTermBorrowings" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityShortTermBorrowings)
            }
            "ExpenseCharitableContributions" => {
                Ok(AccountingAccountType::ExpenseCharitableContributions)
            }
            "OtherCurrentLiabilityLineOfCredit" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityLineOfCredit)
            }
            "EquityPersonalExpense" => Ok(AccountingAccountType::EquityPersonalExpense),
            "LiabilityAccruedLongTermLiabilities" => {
                Ok(AccountingAccountType::LiabilityAccruedLongTermLiabilities)
            }
            "AssetAccumulatedAmortization" => {
                Ok(AccountingAccountType::AssetAccumulatedAmortization)
            }
            "OtherExpenseDeferredTaxExpense" => {
                Ok(AccountingAccountType::OtherExpenseDeferredTaxExpense)
            }
            "AssetLoansToOfficers" => Ok(AccountingAccountType::AssetLoansToOfficers),
            "AssetOtherLongTermInvestments" => {
                Ok(AccountingAccountType::AssetOtherLongTermInvestments)
            }
            "OtherExpenseDepreciation" => {
                Ok(AccountingAccountType::OtherExpenseDepreciation)
            }
            "LiabilityDeferredTaxLiabilities" => {
                Ok(AccountingAccountType::LiabilityDeferredTaxLiabilities)
            }
            "EquityOwnersEquity" => Ok(AccountingAccountType::EquityOwnersEquity),
            "EquityShareCapital" => Ok(AccountingAccountType::EquityShareCapital),
            "RevenueSalesWholesale" => Ok(AccountingAccountType::RevenueSalesWholesale),
            "AssetGlobalTaxDeferred" => Ok(AccountingAccountType::AssetGlobalTaxDeferred),
            "RevenueDiscountsRefundsGiven" => {
                Ok(AccountingAccountType::RevenueDiscountsRefundsGiven)
            }
            "LiabilityBankLoans" => Ok(AccountingAccountType::LiabilityBankLoans),
            "AssetProvisionsCurrentAssets" => {
                Ok(AccountingAccountType::AssetProvisionsCurrentAssets)
            }
            "AssetPrepaidExpenses" => Ok(AccountingAccountType::AssetPrepaidExpenses),
            "LiabilityGovernmentAndOtherPublicAuthorities" => {
                Ok(AccountingAccountType::LiabilityGovernmentAndOtherPublicAuthorities)
            }
            "RevenueCashReceiptIncome" => {
                Ok(AccountingAccountType::RevenueCashReceiptIncome)
            }
            "OtherExpenseExceptionalItems" => {
                Ok(AccountingAccountType::OtherExpenseExceptionalItems)
            }
            "AssetFixedAssetCopiers" => Ok(AccountingAccountType::AssetFixedAssetCopiers),
            "OtherCurrentLiabilityGlobalTaxSuspense" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityGlobalTaxSuspense)
            }
            "AssetBank" => Ok(AccountingAccountType::AssetBank),
            "ExpenseEntertainment" => Ok(AccountingAccountType::ExpenseEntertainment),
            "ExpenseGlobalTaxExpense" => {
                Ok(AccountingAccountType::ExpenseGlobalTaxExpense)
            }
            "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts" => {
                Ok(
                    AccountingAccountType::OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts,
                )
            }
            "AssetIntangibleAssets" => Ok(AccountingAccountType::AssetIntangibleAssets),
            "ExpensePromotionalMeals" => {
                Ok(AccountingAccountType::ExpensePromotionalMeals)
            }
            "AssetShortTermLoansAndAdvancesToRelatedParties" => {
                Ok(AccountingAccountType::AssetShortTermLoansAndAdvancesToRelatedParties)
            }
            "ExpenseBorrowingCost" => Ok(AccountingAccountType::ExpenseBorrowingCost),
            "ExpenseShippingAndDeliveryExpense" => {
                Ok(AccountingAccountType::ExpenseShippingAndDeliveryExpense)
            }
            "LiabilityLongTermLiability" => {
                Ok(AccountingAccountType::LiabilityLongTermLiability)
            }
            "RevenueServiceFeeIncome" => {
                Ok(AccountingAccountType::RevenueServiceFeeIncome)
            }
            "ExpenseProjectStudiesSurveysAssessments" => {
                Ok(AccountingAccountType::ExpenseProjectStudiesSurveysAssessments)
            }
            "OtherIncomeGainLossOnSaleOfFixedAssets" => {
                Ok(AccountingAccountType::OtherIncomeGainLossOnSaleOfFixedAssets)
            }
            "ExpenseLegalProfessionalFees" => {
                Ok(AccountingAccountType::ExpenseLegalProfessionalFees)
            }
            "Equity" => Ok(AccountingAccountType::Equity),
            "OtherExpenseVehicle" => Ok(AccountingAccountType::OtherExpenseVehicle),
            "OtherCurrentLiabilityPayrollClearing" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityPayrollClearing)
            }
            "ExpenseBankCharges" => Ok(AccountingAccountType::ExpenseBankCharges),
            "AssetOtherEarMarkedBankAccounts" => {
                Ok(AccountingAccountType::AssetOtherEarMarkedBankAccounts)
            }
            "ExpenseAuto" => Ok(AccountingAccountType::ExpenseAuto),
            "AssetFixedAssetFurniture" => {
                Ok(AccountingAccountType::AssetFixedAssetFurniture)
            }
            "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases" => {
                Ok(
                    AccountingAccountType::OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases,
                )
            }
            "AssetLand" => Ok(AccountingAccountType::AssetLand),
            "OtherIncomeGainLossOnSaleOfInvestments" => {
                Ok(AccountingAccountType::OtherIncomeGainLossOnSaleOfInvestments)
            }
            "AssetFixedAssetPhone" => Ok(AccountingAccountType::AssetFixedAssetPhone),
            "EquityEstimatedTaxes" => Ok(AccountingAccountType::EquityEstimatedTaxes),
            "AssetSecurityDeposits" => Ok(AccountingAccountType::AssetSecurityDeposits),
            "CostOfGoodsSoldShippingFreightDeliveryCos" => {
                Ok(AccountingAccountType::CostOfGoodsSoldShippingFreightDeliveryCos)
            }
            "EquityRetainedEarnings" => Ok(AccountingAccountType::EquityRetainedEarnings),
            "AssetInternalTransfers" => Ok(AccountingAccountType::AssetInternalTransfers),
            "LiabilityOtherLongTermLiabilities" => {
                Ok(AccountingAccountType::LiabilityOtherLongTermLiabilities)
            }
            "AssetFixedAssetComputers" => {
                Ok(AccountingAccountType::AssetFixedAssetComputers)
            }
            "ExpenseTravelMeals" => Ok(AccountingAccountType::ExpenseTravelMeals),
            "OtherCurrentLiabilityDirectDepositPayable" => {
                Ok(AccountingAccountType::OtherCurrentLiabilityDirectDepositPayable)
            }
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "AccountingAccountType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for AccountingAccountType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            AccountingAccountType::AssetLandAsset => "AssetLandAsset",
            AccountingAccountType::AssetBalWithGovtAuthorities => {
                "AssetBalWithGovtAuthorities"
            }
            AccountingAccountType::ExpenseOtherBusinessExpenses => {
                "ExpenseOtherBusinessExpenses"
            }
            AccountingAccountType::OtherCurrentLiabilitySundryDebtorsAndCreditors => {
                "OtherCurrentLiabilitySundryDebtorsAndCreditors"
            }
            AccountingAccountType::ExpenseBadDebts => "ExpenseBadDebts",
            AccountingAccountType::AssetLeaseholdImprovements => {
                "AssetLeaseholdImprovements"
            }
            AccountingAccountType::OtherExpenseIncomeTaxOtherExpense => {
                "OtherExpenseIncomeTaxOtherExpense"
            }
            AccountingAccountType::ExpenseTravelExpensesGeneralAndAdminExpenses => {
                "ExpenseTravelExpensesGeneralAndAdminExpenses"
            }
            AccountingAccountType::LiabilityLongTermDebit => "LiabilityLongTermDebit",
            AccountingAccountType::OtherExpenseParkingAndTolls => {
                "OtherExpenseParkingAndTolls"
            }
            AccountingAccountType::LiabilityShareholderNotesPayable => {
                "LiabilityShareholderNotesPayable"
            }
            AccountingAccountType::LiabilityOtherLongTermProvisions => {
                "LiabilityOtherLongTermProvisions"
            }
            AccountingAccountType::RevenueSavingsByTaxScheme => {
                "RevenueSavingsByTaxScheme"
            }
            AccountingAccountType::ExpenseManagementCompensation => {
                "ExpenseManagementCompensation"
            }
            AccountingAccountType::OtherExpenseMatCredit => "OtherExpenseMatCredit",
            AccountingAccountType::OtherIncomeOtherMiscellaneousIncome => {
                "OtherIncomeOtherMiscellaneousIncome"
            }
            AccountingAccountType::OtherExpenseDepletion => "OtherExpenseDepletion",
            AccountingAccountType::ExpenseStaffCosts => "ExpenseStaffCosts",
            AccountingAccountType::AssetOtherConsumables => "AssetOtherConsumables",
            AccountingAccountType::LiabilityAccruedVacationPayable => {
                "LiabilityAccruedVacationPayable"
            }
            AccountingAccountType::AssetFixedAssetOtherToolsEquipment => {
                "AssetFixedAssetOtherToolsEquipment"
            }
            AccountingAccountType::AssetFixedAssetPhotoVideo => {
                "AssetFixedAssetPhotoVideo"
            }
            AccountingAccountType::EquityOtherFreeReserves => "EquityOtherFreeReserves",
            AccountingAccountType::AssetShortTermInvestmentsInRelatedParties => {
                "AssetShortTermInvestmentsInRelatedParties"
            }
            AccountingAccountType::ExpenseIncomeTaxExpense => "ExpenseIncomeTaxExpense",
            AccountingAccountType::EquityCapitalReserves => "EquityCapitalReserves",
            AccountingAccountType::OtherExpenseOtherVehicleExpenses => {
                "OtherExpenseOtherVehicleExpenses"
            }
            AccountingAccountType::OtherCurrentLiabilitySocialSecurityAgencies => {
                "OtherCurrentLiabilitySocialSecurityAgencies"
            }
            AccountingAccountType::AccountsReceivable => "AccountsReceivable",
            AccountingAccountType::AssetFurnitureAndFixtures => {
                "AssetFurnitureAndFixtures"
            }
            AccountingAccountType::OtherExpenseExchangeGainOrLoss => {
                "OtherExpenseExchangeGainOrLoss"
            }
            AccountingAccountType::OtherCurrentLiability => "OtherCurrentLiability",
            AccountingAccountType::AssetInvestmentOther => "AssetInvestmentOther",
            AccountingAccountType::RevenueUnappliedCashPaymentIncome => {
                "RevenueUnappliedCashPaymentIncome"
            }
            AccountingAccountType::AssetTrustAccounts => "AssetTrustAccounts",
            AccountingAccountType::LiabilityLongTermEmployeeBenefitObligations => {
                "LiabilityLongTermEmployeeBenefitObligations"
            }
            AccountingAccountType::OtherCurrentLiabilityPrepaidExpensesPayable => {
                "OtherCurrentLiabilityPrepaidExpensesPayable"
            }
            AccountingAccountType::RevenueOperatingGrants => "RevenueOperatingGrants",
            AccountingAccountType::ExpenseInsurance => "ExpenseInsurance",
            AccountingAccountType::ExpenseOtherRentalCosts => "ExpenseOtherRentalCosts",
            AccountingAccountType::EquityInvestmentGrants => "EquityInvestmentGrants",
            AccountingAccountType::LiabilityAccrualsAndDeferredIncome => {
                "LiabilityAccrualsAndDeferredIncome"
            }
            AccountingAccountType::AssetAccumulatedDepreciation => {
                "AssetAccumulatedDepreciation"
            }
            AccountingAccountType::OtherIncomeDividendIncome => {
                "OtherIncomeDividendIncome"
            }
            AccountingAccountType::AssetFixedAsset => "AssetFixedAsset",
            AccountingAccountType::AssetEmployeeCashAdvances => {
                "AssetEmployeeCashAdvances"
            }
            AccountingAccountType::AssetDepletableAssets => "AssetDepletableAssets",
            AccountingAccountType::AssetOtherAsset => "AssetOtherAsset",
            AccountingAccountType::EquityHealthcare => "EquityHealthcare",
            AccountingAccountType::OtherExpenseVehicleLoanInterest => {
                "OtherExpenseVehicleLoanInterest"
            }
            AccountingAccountType::OtherExpenseTaxRoundoffGainOrLoss => {
                "OtherExpenseTaxRoundoffGainOrLoss"
            }
            AccountingAccountType::LiabilityDebtsRelatedToParticipatingInterests => {
                "LiabilityDebtsRelatedToParticipatingInterests"
            }
            AccountingAccountType::ExpenseRepairMaintenance => "ExpenseRepairMaintenance",
            AccountingAccountType::OtherCurrentLiabilityGlobalTaxPayable => {
                "OtherCurrentLiabilityGlobalTaxPayable"
            }
            AccountingAccountType::OtherCurrentLiabilityPayrollTaxPayable => {
                "OtherCurrentLiabilityPayrollTaxPayable"
            }
            AccountingAccountType::AssetChecking => "AssetChecking",
            AccountingAccountType::EquityPaidInCapitalOrSurplus => {
                "EquityPaidInCapitalOrSurplus"
            }
            AccountingAccountType::AssetVehicles => "AssetVehicles",
            AccountingAccountType::ExpensePayrollExpenses => "ExpensePayrollExpenses",
            AccountingAccountType::CostOfGoodsSoldOtherCostsOfServiceCos => {
                "CostOfGoodsSoldOtherCostsOfServiceCos"
            }
            AccountingAccountType::AssetUndepositedFunds => "AssetUndepositedFunds",
            AccountingAccountType::OtherExpenseVehicleRepairs => {
                "OtherExpenseVehicleRepairs"
            }
            AccountingAccountType::OtherCurrentLiabilityAccruedLiabilities => {
                "OtherCurrentLiabilityAccruedLiabilities"
            }
            AccountingAccountType::AssetCapitalWip => "AssetCapitalWip",
            AccountingAccountType::AssetDevelopmentCosts => "AssetDevelopmentCosts",
            AccountingAccountType::LiabilityObligationsUnderFinanceLeases => {
                "LiabilityObligationsUnderFinanceLeases"
            }
            AccountingAccountType::OtherCurrentLiabilityFederalIncomeTaxPayable => {
                "OtherCurrentLiabilityFederalIncomeTaxPayable"
            }
            AccountingAccountType::RevenueOwnWorkCapitalized => {
                "RevenueOwnWorkCapitalized"
            }
            AccountingAccountType::EquityShareApplicationMoneyPendingAllotment => {
                "EquityShareApplicationMoneyPendingAllotment"
            }
            AccountingAccountType::AssetInventory => "AssetInventory",
            AccountingAccountType::AssetInvestmentTaxExemptSecurities => {
                "AssetInvestmentTaxExemptSecurities"
            }
            AccountingAccountType::AssetLoansToStockholders => "AssetLoansToStockholders",
            AccountingAccountType::LiabilityLongTermBorrowings => {
                "LiabilityLongTermBorrowings"
            }
            AccountingAccountType::OtherCurrentLiabilityProvisionForWarrantyObligations => {
                "OtherCurrentLiabilityProvisionForWarrantyObligations"
            }
            AccountingAccountType::OtherCurrentLiabilityTrustAccountsLiabilities => {
                "OtherCurrentLiabilityTrustAccountsLiabilities"
            }
            AccountingAccountType::AssetBuildings => "AssetBuildings",
            AccountingAccountType::ExpenseOfficeGeneralAdministrativeExpenses => {
                "ExpenseOfficeGeneralAdministrativeExpenses"
            }
            AccountingAccountType::ExpenseOtherCurrentOperatingCharges => {
                "ExpenseOtherCurrentOperatingCharges"
            }
            AccountingAccountType::AssetFixedAssetSoftware => "AssetFixedAssetSoftware",
            AccountingAccountType::OtherIncome => "OtherIncome",
            AccountingAccountType::AssetParticipatingInterests => {
                "AssetParticipatingInterests"
            }
            AccountingAccountType::AssetAssetsAvailableForSale => {
                "AssetAssetsAvailableForSale"
            }
            AccountingAccountType::ExpenseDuesSubscriptions => "ExpenseDuesSubscriptions",
            AccountingAccountType::OtherExpenseHomeOwnerRentalInsurance => {
                "OtherExpenseHomeOwnerRentalInsurance"
            }
            AccountingAccountType::OtherCurrentLiabilityDutiesAndTaxes => {
                "OtherCurrentLiabilityDutiesAndTaxes"
            }
            AccountingAccountType::ExpenseAppropriationsToDepreciation => {
                "ExpenseAppropriationsToDepreciation"
            }
            AccountingAccountType::LiabilityProvisionsNonCurrentLiabilities => {
                "LiabilityProvisionsNonCurrentLiabilities"
            }
            AccountingAccountType::EquityFunds => "EquityFunds",
            AccountingAccountType::AssetMachineryAndEquipment => {
                "AssetMachineryAndEquipment"
            }
            AccountingAccountType::AssetOtherCurrentAssets => "AssetOtherCurrentAssets",
            AccountingAccountType::CostOfGoodsSoldFreightAndDeliveryCost => {
                "CostOfGoodsSoldFreightAndDeliveryCost"
            }
            AccountingAccountType::ExpenseFinanceCosts => "ExpenseFinanceCosts",
            AccountingAccountType::CostOfGoodsSoldEquipmentRentalCos => {
                "CostOfGoodsSoldEquipmentRentalCos"
            }
            AccountingAccountType::Asset => "Asset",
            AccountingAccountType::ExpenseCommissionsAndFees => {
                "ExpenseCommissionsAndFees"
            }
            AccountingAccountType::ExpenseLossOnDiscontinuedOperationsNetOfTax => {
                "ExpenseLossOnDiscontinuedOperationsNetOfTax"
            }
            AccountingAccountType::AssetSavings => "AssetSavings",
            AccountingAccountType::ExpenseSundry => "ExpenseSundry",
            AccountingAccountType::ExpenseEntertainmentMeals => {
                "ExpenseEntertainmentMeals"
            }
            AccountingAccountType::ExpenseExternalServices => "ExpenseExternalServices",
            AccountingAccountType::AssetLongTermLoansAndAdvancesToRelatedParties => {
                "AssetLongTermLoansAndAdvancesToRelatedParties"
            }
            AccountingAccountType::ExpenseTaxesPaid => "ExpenseTaxesPaid",
            AccountingAccountType::OtherCurrentLiabilityInterestPayables => {
                "OtherCurrentLiabilityInterestPayables"
            }
            AccountingAccountType::EquityCommonStock => "EquityCommonStock",
            AccountingAccountType::ExpenseCostOfLabor => "ExpenseCostOfLabor",
            AccountingAccountType::OtherIncomeOtherOperatingIncome => {
                "OtherIncomeOtherOperatingIncome"
            }
            AccountingAccountType::AssetLoansToOthers => "AssetLoansToOthers",
            AccountingAccountType::AssetRetainage => "AssetRetainage",
            AccountingAccountType::AssetRentsHeldInTrust => "AssetRentsHeldInTrust",
            AccountingAccountType::AssetInvestmentMortgageRealEstateLoans => {
                "AssetInvestmentMortgageRealEstateLoans"
            }
            AccountingAccountType::EquityDividendDisbursed => "EquityDividendDisbursed",
            AccountingAccountType::AssetGlobalTaxRefund => "AssetGlobalTaxRefund",
            AccountingAccountType::OtherExpenseVehicleInsurance => {
                "OtherExpenseVehicleInsurance"
            }
            AccountingAccountType::CostOfGoodsSoldCostOfSales => {
                "CostOfGoodsSoldCostOfSales"
            }
            AccountingAccountType::OtherCurrentLiabilityCurrentTaxLiability => {
                "OtherCurrentLiabilityCurrentTaxLiability"
            }
            AccountingAccountType::AssetAssetsHeldForSale => "AssetAssetsHeldForSale",
            AccountingAccountType::EquityPartnerDistributions => {
                "EquityPartnerDistributions"
            }
            AccountingAccountType::AssetAssetsInCourseOfConstruction => {
                "AssetAssetsInCourseOfConstruction"
            }
            AccountingAccountType::AssetLeaseBuyout => "AssetLeaseBuyout",
            AccountingAccountType::ExpenseRentOrLeaseOfBuildings => {
                "ExpenseRentOrLeaseOfBuildings"
            }
            AccountingAccountType::OtherExpenseOtherMiscellaneousExpense => {
                "OtherExpenseOtherMiscellaneousExpense"
            }
            AccountingAccountType::OtherExpenseVehicleRegistration => {
                "OtherExpenseVehicleRegistration"
            }
            AccountingAccountType::OtherExpenseRentAndLease => "OtherExpenseRentAndLease",
            AccountingAccountType::LiabilityLiabilitiesRelatedToAssetsHeldForSale => {
                "LiabilityLiabilitiesRelatedToAssetsHeldForSale"
            }
            AccountingAccountType::OtherExpenseExtraordinaryItems => {
                "OtherExpenseExtraordinaryItems"
            }
            AccountingAccountType::OtherCurrentLiabilityOtherCurrentLiabilities => {
                "OtherCurrentLiabilityOtherCurrentLiabilities"
            }
            AccountingAccountType::OtherCurrentLiabilityRentsInTrustLiability => {
                "OtherCurrentLiabilityRentsInTrustLiability"
            }
            AccountingAccountType::AssetProvisionsNonCurrentAssets => {
                "AssetProvisionsNonCurrentAssets"
            }
            AccountingAccountType::OtherExpense => "OtherExpense",
            AccountingAccountType::AssetDeferredTax => "AssetDeferredTax",
            AccountingAccountType::OtherCurrentLiabilityDividendsPayable => {
                "OtherCurrentLiabilityDividendsPayable"
            }
            AccountingAccountType::OtherIncomeOtherInvestmentIncome => {
                "OtherIncomeOtherInvestmentIncome"
            }
            AccountingAccountType::OtherExpenseAmortization => "OtherExpenseAmortization",
            AccountingAccountType::ExpenseUnappliedCashBillPaymentExpense => {
                "ExpenseUnappliedCashBillPaymentExpense"
            }
            AccountingAccountType::AssetNonCurrentAssets => "AssetNonCurrentAssets",
            AccountingAccountType::AssetCashOnHand => "AssetCashOnHand",
            AccountingAccountType::ExpenseAdvertisingPromotional => {
                "ExpenseAdvertisingPromotional"
            }
            AccountingAccountType::ExpenseOtherMiscellaneousServiceCost => {
                "ExpenseOtherMiscellaneousServiceCost"
            }
            AccountingAccountType::RevenueOtherCurrentOperatingIncome => {
                "RevenueOtherCurrentOperatingIncome"
            }
            AccountingAccountType::OtherIncomeLossOnDisposalOfAssets => {
                "OtherIncomeLossOnDisposalOfAssets"
            }
            AccountingAccountType::ExpenseSuppliesMaterials => "ExpenseSuppliesMaterials",
            AccountingAccountType::OtherExpenseVehicleLease => "OtherExpenseVehicleLease",
            AccountingAccountType::AssetGoodwill => "AssetGoodwill",
            AccountingAccountType::RevenueSalesOfProductIncome => {
                "RevenueSalesOfProductIncome"
            }
            AccountingAccountType::LiabilityProvisionForLiabilities => {
                "LiabilityProvisionForLiabilities"
            }
            AccountingAccountType::RevenueIncome => "RevenueIncome",
            AccountingAccountType::EquityCalledUpShareCapital => {
                "EquityCalledUpShareCapital"
            }
            AccountingAccountType::OtherExpenseGasAndFuel => "OtherExpenseGasAndFuel",
            AccountingAccountType::LiabilityCreditCard => "LiabilityCreditCard",
            AccountingAccountType::ExpenseAmortizationExpense => {
                "ExpenseAmortizationExpense"
            }
            AccountingAccountType::LiabilityAccountsPayable => "LiabilityAccountsPayable",
            AccountingAccountType::EquityMoneyReceivedAgainstShareWarrants => {
                "EquityMoneyReceivedAgainstShareWarrants"
            }
            AccountingAccountType::EquityPersonalIncome => "EquityPersonalIncome",
            AccountingAccountType::OtherExpenseWashAndRoadServices => {
                "OtherExpenseWashAndRoadServices"
            }
            AccountingAccountType::OtherIncomeUnrealisedLossOnSecuritiesNetOfTax => {
                "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax"
            }
            AccountingAccountType::AssetProvisionsFixedAssets => {
                "AssetProvisionsFixedAssets"
            }
            AccountingAccountType::ExpenseInterestPaid => "ExpenseInterestPaid",
            AccountingAccountType::RevenueNonProfitIncome => "RevenueNonProfitIncome",
            AccountingAccountType::CostOfGoodsSoldSuppliesMaterialsCogs => {
                "CostOfGoodsSoldSuppliesMaterialsCogs"
            }
            AccountingAccountType::ExpenseOfficeExpenses => "ExpenseOfficeExpenses",
            AccountingAccountType::AssetInvestments => "AssetInvestments",
            AccountingAccountType::EquityPartnersEquity => "EquityPartnersEquity",
            AccountingAccountType::AssetAvailableForSaleFinancialAssets => {
                "AssetAvailableForSaleFinancialAssets"
            }
            AccountingAccountType::AssetOtherLongTermLoansAndAdvances => {
                "AssetOtherLongTermLoansAndAdvances"
            }
            AccountingAccountType::OtherExpensePriorPeriodItems => {
                "OtherExpensePriorPeriodItems"
            }
            AccountingAccountType::AssetTradeAndOtherReceivables => {
                "AssetTradeAndOtherReceivables"
            }
            AccountingAccountType::AssetIntangibleAssetsUnderDevelopment => {
                "AssetIntangibleAssetsUnderDevelopment"
            }
            AccountingAccountType::RevenueOtherPrimaryIncome => {
                "RevenueOtherPrimaryIncome"
            }
            AccountingAccountType::OtherCurrentLiabilityTradeAndOtherPayables => {
                "OtherCurrentLiabilityTradeAndOtherPayables"
            }
            AccountingAccountType::RevenueSalesRetail => "RevenueSalesRetail",
            AccountingAccountType::EquityPartnerContributions => {
                "EquityPartnerContributions"
            }
            AccountingAccountType::LiabilityNotesPayable => "LiabilityNotesPayable",
            AccountingAccountType::AssetExpenditureAuthorisationsAndLettersOfCredit => {
                "AssetExpenditureAuthorisationsAndLettersOfCredit"
            }
            AccountingAccountType::LiabilityGroupAndAssociates => {
                "LiabilityGroupAndAssociates"
            }
            AccountingAccountType::AssetCumulativeDepreciationOnIntangibleAssets => {
                "AssetCumulativeDepreciationOnIntangibleAssets"
            }
            AccountingAccountType::AssetOtherCurrentAsset => "AssetOtherCurrentAsset",
            AccountingAccountType::OtherExpenseOtherHomeOfficeExpenses => {
                "OtherExpenseOtherHomeOfficeExpenses"
            }
            AccountingAccountType::Expense => "Expense",
            AccountingAccountType::AssetCalledUpShareCapitalNotPaid => {
                "AssetCalledUpShareCapitalNotPaid"
            }
            AccountingAccountType::ExpenseTravel => "ExpenseTravel",
            AccountingAccountType::OtherExpensePenaltiesSettlements => {
                "OtherExpensePenaltiesSettlements"
            }
            AccountingAccountType::CostOfGoodsSold => "CostOfGoodsSold",
            AccountingAccountType::OtherCurrentLiabilityLoanPayable => {
                "OtherCurrentLiabilityLoanPayable"
            }
            AccountingAccountType::RevenueRevenueGeneral => "RevenueRevenueGeneral",
            AccountingAccountType::AssetAccumulatedDepletion => {
                "AssetAccumulatedDepletion"
            }
            AccountingAccountType::AssetOtherFixedAssets => "AssetOtherFixedAssets",
            AccountingAccountType::AssetPrepaymentsAndAccruedIncome => {
                "AssetPrepaymentsAndAccruedIncome"
            }
            AccountingAccountType::OtherIncomeInterestEarned => {
                "OtherIncomeInterestEarned"
            }
            AccountingAccountType::AssetLicenses => "AssetLicenses",
            AccountingAccountType::EquityAccumulatedOtherComprehensiveIncome => {
                "EquityAccumulatedOtherComprehensiveIncome"
            }
            AccountingAccountType::ExpenseExtraordinaryCharges => {
                "ExpenseExtraordinaryCharges"
            }
            AccountingAccountType::AssetCashAndCashEquivalents => {
                "AssetCashAndCashEquivalents"
            }
            AccountingAccountType::OtherCurrentLiabilitySalesTaxPayable => {
                "OtherCurrentLiabilitySalesTaxPayable"
            }
            AccountingAccountType::EquityEquityInEarningsOfSubsidiuaries => {
                "EquityEquityInEarningsOfSubsidiuaries"
            }
            AccountingAccountType::AssetOrganizationalCosts => "AssetOrganizationalCosts",
            AccountingAccountType::ExpenseOtherExternalServices => {
                "ExpenseOtherExternalServices"
            }
            AccountingAccountType::AssetAccumulatedAmortizationOfOtherAssets => {
                "AssetAccumulatedAmortizationOfOtherAssets"
            }
            AccountingAccountType::OtherExpenseMortgageInterest => {
                "OtherExpenseMortgageInterest"
            }
            AccountingAccountType::OtherCurrentLiabilityStateLocalIncomeTaxPayable => {
                "OtherCurrentLiabilityStateLocalIncomeTaxPayable"
            }
            AccountingAccountType::ExpensePurchasesRebates => "ExpensePurchasesRebates",
            AccountingAccountType::EquityAccumulatedAdjustment => {
                "EquityAccumulatedAdjustment"
            }
            AccountingAccountType::OtherCurrentLiabilityInsurancePayable => {
                "OtherCurrentLiabilityInsurancePayable"
            }
            AccountingAccountType::ExpenseShippingFreightDelivery => {
                "ExpenseShippingFreightDelivery"
            }
            AccountingAccountType::AssetAllowanceForBadDebts => {
                "AssetAllowanceForBadDebts"
            }
            AccountingAccountType::LiabilityStaffAndRelatedLongTermLiabilityAccounts => {
                "LiabilityStaffAndRelatedLongTermLiabilityAccounts"
            }
            AccountingAccountType::OtherExpenseVehicleLoan => "OtherExpenseVehicleLoan",
            AccountingAccountType::OtherCurrentLiabilityCurrentLiabilities => {
                "OtherCurrentLiabilityCurrentLiabilities"
            }
            AccountingAccountType::OtherExpenseHomeOffice => "OtherExpenseHomeOffice",
            AccountingAccountType::OtherExpenseRepairsAndMaintenance => {
                "OtherExpenseRepairsAndMaintenance"
            }
            AccountingAccountType::LiabilityOutstandingDuesOtherThanMicroSmallEnterprise => {
                "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise"
            }
            AccountingAccountType::OtherCurrentLiabilityProvisionsCurrentLiabilities => {
                "OtherCurrentLiabilityProvisionsCurrentLiabilities"
            }
            AccountingAccountType::OtherIncomeTaxExemptInterest => {
                "OtherIncomeTaxExemptInterest"
            }
            AccountingAccountType::EquityPreferredStock => "EquityPreferredStock",
            AccountingAccountType::AssetOtherLongTermAssets => "AssetOtherLongTermAssets",
            AccountingAccountType::ExpenseDistributionCosts => "ExpenseDistributionCosts",
            AccountingAccountType::AssetMoneyMarket => "AssetMoneyMarket",
            AccountingAccountType::CostOfGoodsSoldCostOfLaborCos => {
                "CostOfGoodsSoldCostOfLaborCos"
            }
            AccountingAccountType::AssetInvestmentUsGovernmentObligations => {
                "AssetInvestmentUsGovernmentObligations"
            }
            AccountingAccountType::LiabilityOutstandingDuesMicroSmallEnterprise => {
                "LiabilityOutstandingDuesMicroSmallEnterprise"
            }
            AccountingAccountType::ExpenseOtherSellingExpenses => {
                "ExpenseOtherSellingExpenses"
            }
            AccountingAccountType::EquityOpeningBalanceEquity => {
                "EquityOpeningBalanceEquity"
            }
            AccountingAccountType::ExpenseUtilities => "ExpenseUtilities",
            AccountingAccountType::OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations => {
                "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations"
            }
            AccountingAccountType::ExpenseTravelExpensesSellingExpense => {
                "ExpenseTravelExpensesSellingExpense"
            }
            AccountingAccountType::EquityTreasuryStock => "EquityTreasuryStock",
            AccountingAccountType::AssetLongTermInvestments => "AssetLongTermInvestments",
            AccountingAccountType::ExpenseEquipmentRental => "ExpenseEquipmentRental",
            AccountingAccountType::OtherExpenseUtilities => "OtherExpenseUtilities",
            AccountingAccountType::AssetOtherIntangibleAssets => {
                "AssetOtherIntangibleAssets"
            }
            AccountingAccountType::OtherCurrentLiabilityShortTermBorrowings => {
                "OtherCurrentLiabilityShortTermBorrowings"
            }
            AccountingAccountType::ExpenseCharitableContributions => {
                "ExpenseCharitableContributions"
            }
            AccountingAccountType::OtherCurrentLiabilityLineOfCredit => {
                "OtherCurrentLiabilityLineOfCredit"
            }
            AccountingAccountType::EquityPersonalExpense => "EquityPersonalExpense",
            AccountingAccountType::LiabilityAccruedLongTermLiabilities => {
                "LiabilityAccruedLongTermLiabilities"
            }
            AccountingAccountType::AssetAccumulatedAmortization => {
                "AssetAccumulatedAmortization"
            }
            AccountingAccountType::OtherExpenseDeferredTaxExpense => {
                "OtherExpenseDeferredTaxExpense"
            }
            AccountingAccountType::AssetLoansToOfficers => "AssetLoansToOfficers",
            AccountingAccountType::AssetOtherLongTermInvestments => {
                "AssetOtherLongTermInvestments"
            }
            AccountingAccountType::OtherExpenseDepreciation => "OtherExpenseDepreciation",
            AccountingAccountType::LiabilityDeferredTaxLiabilities => {
                "LiabilityDeferredTaxLiabilities"
            }
            AccountingAccountType::EquityOwnersEquity => "EquityOwnersEquity",
            AccountingAccountType::EquityShareCapital => "EquityShareCapital",
            AccountingAccountType::RevenueSalesWholesale => "RevenueSalesWholesale",
            AccountingAccountType::AssetGlobalTaxDeferred => "AssetGlobalTaxDeferred",
            AccountingAccountType::RevenueDiscountsRefundsGiven => {
                "RevenueDiscountsRefundsGiven"
            }
            AccountingAccountType::LiabilityBankLoans => "LiabilityBankLoans",
            AccountingAccountType::AssetProvisionsCurrentAssets => {
                "AssetProvisionsCurrentAssets"
            }
            AccountingAccountType::AssetPrepaidExpenses => "AssetPrepaidExpenses",
            AccountingAccountType::LiabilityGovernmentAndOtherPublicAuthorities => {
                "LiabilityGovernmentAndOtherPublicAuthorities"
            }
            AccountingAccountType::RevenueCashReceiptIncome => "RevenueCashReceiptIncome",
            AccountingAccountType::OtherExpenseExceptionalItems => {
                "OtherExpenseExceptionalItems"
            }
            AccountingAccountType::AssetFixedAssetCopiers => "AssetFixedAssetCopiers",
            AccountingAccountType::OtherCurrentLiabilityGlobalTaxSuspense => {
                "OtherCurrentLiabilityGlobalTaxSuspense"
            }
            AccountingAccountType::AssetBank => "AssetBank",
            AccountingAccountType::ExpenseEntertainment => "ExpenseEntertainment",
            AccountingAccountType::ExpenseGlobalTaxExpense => "ExpenseGlobalTaxExpense",
            AccountingAccountType::OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts => {
                "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts"
            }
            AccountingAccountType::AssetIntangibleAssets => "AssetIntangibleAssets",
            AccountingAccountType::ExpensePromotionalMeals => "ExpensePromotionalMeals",
            AccountingAccountType::AssetShortTermLoansAndAdvancesToRelatedParties => {
                "AssetShortTermLoansAndAdvancesToRelatedParties"
            }
            AccountingAccountType::ExpenseBorrowingCost => "ExpenseBorrowingCost",
            AccountingAccountType::ExpenseShippingAndDeliveryExpense => {
                "ExpenseShippingAndDeliveryExpense"
            }
            AccountingAccountType::LiabilityLongTermLiability => {
                "LiabilityLongTermLiability"
            }
            AccountingAccountType::RevenueServiceFeeIncome => "RevenueServiceFeeIncome",
            AccountingAccountType::ExpenseProjectStudiesSurveysAssessments => {
                "ExpenseProjectStudiesSurveysAssessments"
            }
            AccountingAccountType::OtherIncomeGainLossOnSaleOfFixedAssets => {
                "OtherIncomeGainLossOnSaleOfFixedAssets"
            }
            AccountingAccountType::ExpenseLegalProfessionalFees => {
                "ExpenseLegalProfessionalFees"
            }
            AccountingAccountType::Equity => "Equity",
            AccountingAccountType::OtherExpenseVehicle => "OtherExpenseVehicle",
            AccountingAccountType::OtherCurrentLiabilityPayrollClearing => {
                "OtherCurrentLiabilityPayrollClearing"
            }
            AccountingAccountType::ExpenseBankCharges => "ExpenseBankCharges",
            AccountingAccountType::AssetOtherEarMarkedBankAccounts => {
                "AssetOtherEarMarkedBankAccounts"
            }
            AccountingAccountType::ExpenseAuto => "ExpenseAuto",
            AccountingAccountType::AssetFixedAssetFurniture => "AssetFixedAssetFurniture",
            AccountingAccountType::OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases => {
                "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases"
            }
            AccountingAccountType::AssetLand => "AssetLand",
            AccountingAccountType::OtherIncomeGainLossOnSaleOfInvestments => {
                "OtherIncomeGainLossOnSaleOfInvestments"
            }
            AccountingAccountType::AssetFixedAssetPhone => "AssetFixedAssetPhone",
            AccountingAccountType::EquityEstimatedTaxes => "EquityEstimatedTaxes",
            AccountingAccountType::AssetSecurityDeposits => "AssetSecurityDeposits",
            AccountingAccountType::CostOfGoodsSoldShippingFreightDeliveryCos => {
                "CostOfGoodsSoldShippingFreightDeliveryCos"
            }
            AccountingAccountType::EquityRetainedEarnings => "EquityRetainedEarnings",
            AccountingAccountType::AssetInternalTransfers => "AssetInternalTransfers",
            AccountingAccountType::LiabilityOtherLongTermLiabilities => {
                "LiabilityOtherLongTermLiabilities"
            }
            AccountingAccountType::AssetFixedAssetComputers => "AssetFixedAssetComputers",
            AccountingAccountType::ExpenseTravelMeals => "ExpenseTravelMeals",
            AccountingAccountType::OtherCurrentLiabilityDirectDepositPayable => {
                "OtherCurrentLiabilityDirectDepositPayable"
            }
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__AccountingAccountType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLandAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetLandAsset")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetBalWithGovtAuthorities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetBalWithGovtAuthorities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherBusinessExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherBusinessExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilitySundryDebtorsAndCreditors\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilitySundryDebtorsAndCreditors",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseBadDebts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseBadDebts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLeaseholdImprovements\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLeaseholdImprovements",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseIncomeTaxOtherExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseIncomeTaxOtherExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravelExpensesGeneralAndAdminExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTravelExpensesGeneralAndAdminExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermDebit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermDebit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseParkingAndTolls\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseParkingAndTolls",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityShareholderNotesPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityShareholderNotesPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOtherLongTermProvisions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOtherLongTermProvisions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSavingsByTaxScheme\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSavingsByTaxScheme",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseManagementCompensation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseManagementCompensation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseMatCredit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseMatCredit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeOtherMiscellaneousIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeOtherMiscellaneousIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseDepletion\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseDepletion",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseStaffCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseStaffCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherConsumables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherConsumables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccruedVacationPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccruedVacationPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetOtherToolsEquipment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetOtherToolsEquipment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetPhotoVideo\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetPhotoVideo",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityOtherFreeReserves\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityOtherFreeReserves",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetShortTermInvestmentsInRelatedParties\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetShortTermInvestmentsInRelatedParties",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseIncomeTaxExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseIncomeTaxExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityCapitalReserves\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityCapitalReserves",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseOtherVehicleExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseOtherVehicleExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilitySocialSecurityAgencies\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilitySocialSecurityAgencies",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AccountsReceivable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AccountsReceivable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFurnitureAndFixtures\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFurnitureAndFixtures",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseExchangeGainOrLoss\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseExchangeGainOrLoss",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentOther\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentOther",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueUnappliedCashPaymentIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueUnappliedCashPaymentIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetTrustAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetTrustAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermEmployeeBenefitObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermEmployeeBenefitObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityPrepaidExpensesPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityPrepaidExpensesPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOperatingGrants\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOperatingGrants",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseInsurance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseInsurance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherRentalCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherRentalCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityInvestmentGrants\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityInvestmentGrants",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccrualsAndDeferredIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccrualsAndDeferredIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedDepreciation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedDepreciation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeDividendIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeDividendIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAsset",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetEmployeeCashAdvances\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetEmployeeCashAdvances",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetDepletableAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetDepletableAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherAsset",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityHealthcare\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityHealthcare",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleLoanInterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleLoanInterest",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseTaxRoundoffGainOrLoss\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseTaxRoundoffGainOrLoss",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityDebtsRelatedToParticipatingInterests\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityDebtsRelatedToParticipatingInterests",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseRepairMaintenance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseRepairMaintenance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityGlobalTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityGlobalTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityPayrollTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityPayrollTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetChecking\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetChecking")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPaidInCapitalOrSurplus\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPaidInCapitalOrSurplus",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetVehicles\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetVehicles")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePayrollExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePayrollExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldOtherCostsOfServiceCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldOtherCostsOfServiceCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetUndepositedFunds\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetUndepositedFunds",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleRepairs\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleRepairs",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityAccruedLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityAccruedLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCapitalWip\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCapitalWip",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetDevelopmentCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetDevelopmentCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityObligationsUnderFinanceLeases\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityObligationsUnderFinanceLeases",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityFederalIncomeTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityFederalIncomeTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOwnWorkCapitalized\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOwnWorkCapitalized",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityShareApplicationMoneyPendingAllotment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityShareApplicationMoneyPendingAllotment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInventory\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetInventory")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentTaxExemptSecurities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentTaxExemptSecurities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLoansToStockholders\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLoansToStockholders",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermBorrowings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermBorrowings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityProvisionForWarrantyObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityProvisionForWarrantyObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityTrustAccountsLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityTrustAccountsLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetBuildings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetBuildings")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOfficeGeneralAdministrativeExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOfficeGeneralAdministrativeExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherCurrentOperatingCharges\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherCurrentOperatingCharges",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetSoftware\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetSoftware",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OtherIncome")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetParticipatingInterests\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetParticipatingInterests",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAssetsAvailableForSale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAssetsAvailableForSale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseDuesSubscriptions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseDuesSubscriptions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseHomeOwnerRentalInsurance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseHomeOwnerRentalInsurance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityDutiesAndTaxes\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityDutiesAndTaxes",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAppropriationsToDepreciation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseAppropriationsToDepreciation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityProvisionsNonCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityProvisionsNonCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityFunds\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "EquityFunds")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetMachineryAndEquipment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetMachineryAndEquipment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldFreightAndDeliveryCost\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldFreightAndDeliveryCost",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseFinanceCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseFinanceCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldEquipmentRentalCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldEquipmentRentalCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Asset\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Asset")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseCommissionsAndFees\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseCommissionsAndFees",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseLossOnDiscontinuedOperationsNetOfTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseLossOnDiscontinuedOperationsNetOfTax",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetSavings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetSavings")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseSundry\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExpenseSundry")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseEntertainmentMeals\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseEntertainmentMeals",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseExternalServices\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseExternalServices",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLongTermLoansAndAdvancesToRelatedParties\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLongTermLoansAndAdvancesToRelatedParties",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTaxesPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTaxesPaid",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityInterestPayables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityInterestPayables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityCommonStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityCommonStock",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseCostOfLabor\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseCostOfLabor",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeOtherOperatingIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeOtherOperatingIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLoansToOthers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLoansToOthers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetRetainage\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetRetainage")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetRentsHeldInTrust\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetRentsHeldInTrust",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentMortgageRealEstateLoans\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentMortgageRealEstateLoans",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityDividendDisbursed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityDividendDisbursed",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetGlobalTaxRefund\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetGlobalTaxRefund",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleInsurance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleInsurance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldCostOfSales\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldCostOfSales",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentTaxLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentTaxLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAssetsHeldForSale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAssetsHeldForSale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPartnerDistributions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPartnerDistributions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAssetsInCourseOfConstruction\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAssetsInCourseOfConstruction",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLeaseBuyout\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLeaseBuyout",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseRentOrLeaseOfBuildings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseRentOrLeaseOfBuildings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseOtherMiscellaneousExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseOtherMiscellaneousExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleRegistration\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleRegistration",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseRentAndLease\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseRentAndLease",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLiabilitiesRelatedToAssetsHeldForSale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLiabilitiesRelatedToAssetsHeldForSale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseExtraordinaryItems\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseExtraordinaryItems",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityOtherCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityOtherCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityRentsInTrustLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityRentsInTrustLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetProvisionsNonCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetProvisionsNonCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OtherExpense")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetDeferredTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetDeferredTax",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityDividendsPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityDividendsPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeOtherInvestmentIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeOtherInvestmentIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseAmortization\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseAmortization",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseUnappliedCashBillPaymentExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseUnappliedCashBillPaymentExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetNonCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetNonCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCashOnHand\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCashOnHand",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAdvertisingPromotional\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseAdvertisingPromotional",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherMiscellaneousServiceCost\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherMiscellaneousServiceCost",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOtherCurrentOperatingIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOtherCurrentOperatingIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeLossOnDisposalOfAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeLossOnDisposalOfAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseSuppliesMaterials\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseSuppliesMaterials",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleLease\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleLease",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetGoodwill\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetGoodwill")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSalesOfProductIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSalesOfProductIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityProvisionForLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityProvisionForLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RevenueIncome")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityCalledUpShareCapital\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityCalledUpShareCapital",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseGasAndFuel\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseGasAndFuel",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityCreditCard\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityCreditCard",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAmortizationExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseAmortizationExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccountsPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccountsPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityMoneyReceivedAgainstShareWarrants\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityMoneyReceivedAgainstShareWarrants",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPersonalIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPersonalIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseWashAndRoadServices\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseWashAndRoadServices",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeUnrealisedLossOnSecuritiesNetOfTax",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetProvisionsFixedAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetProvisionsFixedAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseInterestPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseInterestPaid",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueNonProfitIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueNonProfitIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldSuppliesMaterialsCogs\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldSuppliesMaterialsCogs",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOfficeExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOfficeExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPartnersEquity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPartnersEquity",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAvailableForSaleFinancialAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAvailableForSaleFinancialAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherLongTermLoansAndAdvances\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherLongTermLoansAndAdvances",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpensePriorPeriodItems\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpensePriorPeriodItems",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetTradeAndOtherReceivables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetTradeAndOtherReceivables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetIntangibleAssetsUnderDevelopment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetIntangibleAssetsUnderDevelopment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueOtherPrimaryIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueOtherPrimaryIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityTradeAndOtherPayables\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityTradeAndOtherPayables",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSalesRetail\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSalesRetail",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPartnerContributions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPartnerContributions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityNotesPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityNotesPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetExpenditureAuthorisationsAndLettersOfCredit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetExpenditureAuthorisationsAndLettersOfCredit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityGroupAndAssociates\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityGroupAndAssociates",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCumulativeDepreciationOnIntangibleAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCumulativeDepreciationOnIntangibleAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherCurrentAsset\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherCurrentAsset",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseOtherHomeOfficeExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseOtherHomeOfficeExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Expense\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Expense")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCalledUpShareCapitalNotPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCalledUpShareCapitalNotPaid",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravel\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExpenseTravel")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpensePenaltiesSettlements\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpensePenaltiesSettlements",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSold\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSold",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityLoanPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityLoanPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueRevenueGeneral\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueRevenueGeneral",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedDepletion\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedDepletion",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherFixedAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherFixedAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetPrepaymentsAndAccruedIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetPrepaymentsAndAccruedIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeInterestEarned\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeInterestEarned",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLicenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetLicenses")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityAccumulatedOtherComprehensiveIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityAccumulatedOtherComprehensiveIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseExtraordinaryCharges\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseExtraordinaryCharges",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetCashAndCashEquivalents\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetCashAndCashEquivalents",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilitySalesTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilitySalesTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityEquityInEarningsOfSubsidiuaries\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityEquityInEarningsOfSubsidiuaries",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOrganizationalCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOrganizationalCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherExternalServices\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherExternalServices",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedAmortizationOfOtherAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedAmortizationOfOtherAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseMortgageInterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseMortgageInterest",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityStateLocalIncomeTaxPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityStateLocalIncomeTaxPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePurchasesRebates\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePurchasesRebates",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityAccumulatedAdjustment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityAccumulatedAdjustment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityInsurancePayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityInsurancePayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseShippingFreightDelivery\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseShippingFreightDelivery",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAllowanceForBadDebts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAllowanceForBadDebts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityStaffAndRelatedLongTermLiabilityAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityStaffAndRelatedLongTermLiabilityAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicleLoan\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicleLoan",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseHomeOffice\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseHomeOffice",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseRepairsAndMaintenance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseRepairsAndMaintenance",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOutstandingDuesOtherThanMicroSmallEnterprise",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityProvisionsCurrentLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityProvisionsCurrentLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeTaxExemptInterest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeTaxExemptInterest",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPreferredStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPreferredStock",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherLongTermAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherLongTermAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseDistributionCosts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseDistributionCosts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetMoneyMarket\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetMoneyMarket",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldCostOfLaborCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldCostOfLaborCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInvestmentUsGovernmentObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInvestmentUsGovernmentObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOutstandingDuesMicroSmallEnterprise\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOutstandingDuesMicroSmallEnterprise",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseOtherSellingExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseOtherSellingExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityOpeningBalanceEquity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityOpeningBalanceEquity",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseUtilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseUtilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentPortionEmployeeBenefitsObligations",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravelExpensesSellingExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTravelExpensesSellingExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityTreasuryStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityTreasuryStock",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLongTermInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLongTermInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseEquipmentRental\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseEquipmentRental",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseUtilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseUtilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherIntangibleAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherIntangibleAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityShortTermBorrowings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityShortTermBorrowings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseCharitableContributions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseCharitableContributions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityLineOfCredit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityLineOfCredit",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityPersonalExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityPersonalExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityAccruedLongTermLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityAccruedLongTermLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetAccumulatedAmortization\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetAccumulatedAmortization",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseDeferredTaxExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseDeferredTaxExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLoansToOfficers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetLoansToOfficers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherLongTermInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherLongTermInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseDepreciation\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseDepreciation",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityDeferredTaxLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityDeferredTaxLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityOwnersEquity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityOwnersEquity",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityShareCapital\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityShareCapital",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueSalesWholesale\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueSalesWholesale",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetGlobalTaxDeferred\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetGlobalTaxDeferred",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueDiscountsRefundsGiven\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueDiscountsRefundsGiven",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityBankLoans\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityBankLoans",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetProvisionsCurrentAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetProvisionsCurrentAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetPrepaidExpenses\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetPrepaidExpenses",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityGovernmentAndOtherPublicAuthorities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityGovernmentAndOtherPublicAuthorities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueCashReceiptIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueCashReceiptIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseExceptionalItems\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseExceptionalItems",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetCopiers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetCopiers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityGlobalTaxSuspense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityGlobalTaxSuspense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetBank\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetBank")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseEntertainment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseEntertainment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseGlobalTaxExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseGlobalTaxExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityStaffAndRelatedLiabilityAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetIntangibleAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetIntangibleAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpensePromotionalMeals\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpensePromotionalMeals",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetShortTermLoansAndAdvancesToRelatedParties\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetShortTermLoansAndAdvancesToRelatedParties",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseBorrowingCost\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseBorrowingCost",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseShippingAndDeliveryExpense\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseShippingAndDeliveryExpense",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityLongTermLiability\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityLongTermLiability",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RevenueServiceFeeIncome\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "RevenueServiceFeeIncome",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseProjectStudiesSurveysAssessments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseProjectStudiesSurveysAssessments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeGainLossOnSaleOfFixedAssets\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeGainLossOnSaleOfFixedAssets",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseLegalProfessionalFees\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseLegalProfessionalFees",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Equity\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Equity")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherExpenseVehicle\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherExpenseVehicle",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityPayrollClearing\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityPayrollClearing",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseBankCharges\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseBankCharges",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetOtherEarMarkedBankAccounts\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetOtherEarMarkedBankAccounts",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseAuto\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ExpenseAuto")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetFurniture\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetFurniture",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases\0"
                .as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityCurrentPortionOfObligationsUnderFinanceLeases",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetLand\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AssetLand")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherIncomeGainLossOnSaleOfInvestments\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherIncomeGainLossOnSaleOfInvestments",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetPhone\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetPhone",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityEstimatedTaxes\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityEstimatedTaxes",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetSecurityDeposits\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetSecurityDeposits",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CostOfGoodsSoldShippingFreightDeliveryCos\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "CostOfGoodsSoldShippingFreightDeliveryCos",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "EquityRetainedEarnings\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "EquityRetainedEarnings",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetInternalTransfers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetInternalTransfers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "LiabilityOtherLongTermLiabilities\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "LiabilityOtherLongTermLiabilities",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AssetFixedAssetComputers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AssetFixedAssetComputers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExpenseTravelMeals\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExpenseTravelMeals",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OtherCurrentLiabilityDirectDepositPayable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OtherCurrentLiabilityDirectDepositPayable",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccountingAccountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__AccountingAccountType_178() {
    napi::bindgen_prelude::register_module_export(
        None,
        "AccountingAccountType\0",
        __register__enum__AccountingAccountType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__AccountingAccountType_178___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__AccountingAccountType_178___rust_ctor___ctor() -> usize {
        __napi_register__AccountingAccountType_178();
        0
    }
    __napi_register__AccountingAccountType_178___rust_ctor___ctor
};
pub enum ConversationStatus {
    Active,
    Deleted,
    Archived,
}
#[automatically_derived]
impl ::core::marker::Copy for ConversationStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ConversationStatus {
    #[inline]
    fn clone(&self) -> ConversationStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ConversationStatus {
    fn type_name() -> &'static str {
        "ConversationStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ConversationStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ConversationStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ConversationStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Active" => Ok(ConversationStatus::Active),
            "Deleted" => Ok(ConversationStatus::Deleted),
            "Archived" => Ok(ConversationStatus::Archived),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ConversationStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ConversationStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ConversationStatus::Active => "Active",
            ConversationStatus::Deleted => "Deleted",
            ConversationStatus::Archived => "Archived",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ConversationStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ConversationStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Deleted\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Deleted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ConversationStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Archived\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Archived")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ConversationStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ConversationStatus_179() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ConversationStatus\0",
        __register__enum__ConversationStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ConversationStatus_179___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ConversationStatus_179___rust_ctor___ctor() -> usize {
        __napi_register__ConversationStatus_179();
        0
    }
    __napi_register__ConversationStatus_179___rust_ctor___ctor
};
pub enum MessageReadStatus {
    Sent,
    Unsent,
    Failed,
    Read,
    Delivered,
}
#[automatically_derived]
impl ::core::marker::Copy for MessageReadStatus {}
#[automatically_derived]
impl ::core::clone::Clone for MessageReadStatus {
    #[inline]
    fn clone(&self) -> MessageReadStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for MessageReadStatus {
    fn type_name() -> &'static str {
        "MessageReadStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for MessageReadStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for MessageReadStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "MessageReadStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Sent" => Ok(MessageReadStatus::Sent),
            "Unsent" => Ok(MessageReadStatus::Unsent),
            "Failed" => Ok(MessageReadStatus::Failed),
            "Read" => Ok(MessageReadStatus::Read),
            "Delivered" => Ok(MessageReadStatus::Delivered),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "MessageReadStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for MessageReadStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            MessageReadStatus::Sent => "Sent",
            MessageReadStatus::Unsent => "Unsent",
            MessageReadStatus::Failed => "Failed",
            MessageReadStatus::Read => "Read",
            MessageReadStatus::Delivered => "Delivered",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__MessageReadStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sent\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageReadStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Unsent\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Unsent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageReadStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageReadStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Read\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Read")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageReadStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Delivered\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Delivered")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageReadStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__MessageReadStatus_180() {
    napi::bindgen_prelude::register_module_export(
        None,
        "MessageReadStatus\0",
        __register__enum__MessageReadStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__MessageReadStatus_180___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__MessageReadStatus_180___rust_ctor___ctor() -> usize {
        __napi_register__MessageReadStatus_180();
        0
    }
    __napi_register__MessageReadStatus_180___rust_ctor___ctor
};
pub enum MessageContentType {
    Video,
    Contact,
    File,
    Audio,
    Link,
    Gif,
    Document,
    Location,
    Voice,
    Text,
    Image,
    Sticker,
}
#[automatically_derived]
impl ::core::marker::Copy for MessageContentType {}
#[automatically_derived]
impl ::core::clone::Clone for MessageContentType {
    #[inline]
    fn clone(&self) -> MessageContentType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for MessageContentType {
    fn type_name() -> &'static str {
        "MessageContentType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for MessageContentType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for MessageContentType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "MessageContentType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Video" => Ok(MessageContentType::Video),
            "Contact" => Ok(MessageContentType::Contact),
            "File" => Ok(MessageContentType::File),
            "Audio" => Ok(MessageContentType::Audio),
            "Link" => Ok(MessageContentType::Link),
            "Gif" => Ok(MessageContentType::Gif),
            "Document" => Ok(MessageContentType::Document),
            "Location" => Ok(MessageContentType::Location),
            "Voice" => Ok(MessageContentType::Voice),
            "Text" => Ok(MessageContentType::Text),
            "Image" => Ok(MessageContentType::Image),
            "Sticker" => Ok(MessageContentType::Sticker),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "MessageContentType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for MessageContentType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            MessageContentType::Video => "Video",
            MessageContentType::Contact => "Contact",
            MessageContentType::File => "File",
            MessageContentType::Audio => "Audio",
            MessageContentType::Link => "Link",
            MessageContentType::Gif => "Gif",
            MessageContentType::Document => "Document",
            MessageContentType::Location => "Location",
            MessageContentType::Voice => "Voice",
            MessageContentType::Text => "Text",
            MessageContentType::Image => "Image",
            MessageContentType::Sticker => "Sticker",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__MessageContentType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Video\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Video")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Contact\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Contact")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("File\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "File")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Audio\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Audio")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Link\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Link")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Gif\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Gif")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Document\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Document")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Location\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Location")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Voice\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Voice")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Text\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Text")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Image\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Image")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sticker\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sticker")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageContentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__MessageContentType_181() {
    napi::bindgen_prelude::register_module_export(
        None,
        "MessageContentType\0",
        __register__enum__MessageContentType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__MessageContentType_181___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__MessageContentType_181___rust_ctor___ctor() -> usize {
        __napi_register__MessageContentType_181();
        0
    }
    __napi_register__MessageContentType_181___rust_ctor___ctor
};
pub enum MessageDeliveryStatus {
    Read,
    Failed,
    Pending,
    Delivered,
    Error,
    Sent,
    Undeliverable,
}
#[automatically_derived]
impl ::core::marker::Copy for MessageDeliveryStatus {}
#[automatically_derived]
impl ::core::clone::Clone for MessageDeliveryStatus {
    #[inline]
    fn clone(&self) -> MessageDeliveryStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for MessageDeliveryStatus {
    fn type_name() -> &'static str {
        "MessageDeliveryStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for MessageDeliveryStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for MessageDeliveryStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "MessageDeliveryStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Read" => Ok(MessageDeliveryStatus::Read),
            "Failed" => Ok(MessageDeliveryStatus::Failed),
            "Pending" => Ok(MessageDeliveryStatus::Pending),
            "Delivered" => Ok(MessageDeliveryStatus::Delivered),
            "Error" => Ok(MessageDeliveryStatus::Error),
            "Sent" => Ok(MessageDeliveryStatus::Sent),
            "Undeliverable" => Ok(MessageDeliveryStatus::Undeliverable),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "MessageDeliveryStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for MessageDeliveryStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            MessageDeliveryStatus::Read => "Read",
            MessageDeliveryStatus::Failed => "Failed",
            MessageDeliveryStatus::Pending => "Pending",
            MessageDeliveryStatus::Delivered => "Delivered",
            MessageDeliveryStatus::Error => "Error",
            MessageDeliveryStatus::Sent => "Sent",
            MessageDeliveryStatus::Undeliverable => "Undeliverable",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__MessageDeliveryStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Read\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Read")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Delivered\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Delivered")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Error\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Error")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sent\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Undeliverable\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Undeliverable")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "MessageDeliveryStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__MessageDeliveryStatus_182() {
    napi::bindgen_prelude::register_module_export(
        None,
        "MessageDeliveryStatus\0",
        __register__enum__MessageDeliveryStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__MessageDeliveryStatus_182___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__MessageDeliveryStatus_182___rust_ctor___ctor() -> usize {
        __napi_register__MessageDeliveryStatus_182();
        0
    }
    __napi_register__MessageDeliveryStatus_182___rust_ctor___ctor
};
pub enum CommunicationRole {
    Member,
    Guest,
    Channel,
    System,
    User,
    Assistant,
    Service,
    Moderator,
    Group,
    Bot,
    Admin,
    Owner,
}
#[automatically_derived]
impl ::core::marker::Copy for CommunicationRole {}
#[automatically_derived]
impl ::core::clone::Clone for CommunicationRole {
    #[inline]
    fn clone(&self) -> CommunicationRole {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CommunicationRole {
    fn type_name() -> &'static str {
        "CommunicationRole"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CommunicationRole {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CommunicationRole {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CommunicationRole",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Member" => Ok(CommunicationRole::Member),
            "Guest" => Ok(CommunicationRole::Guest),
            "Channel" => Ok(CommunicationRole::Channel),
            "System" => Ok(CommunicationRole::System),
            "User" => Ok(CommunicationRole::User),
            "Assistant" => Ok(CommunicationRole::Assistant),
            "Service" => Ok(CommunicationRole::Service),
            "Moderator" => Ok(CommunicationRole::Moderator),
            "Group" => Ok(CommunicationRole::Group),
            "Bot" => Ok(CommunicationRole::Bot),
            "Admin" => Ok(CommunicationRole::Admin),
            "Owner" => Ok(CommunicationRole::Owner),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CommunicationRole",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CommunicationRole {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CommunicationRole::Member => "Member",
            CommunicationRole::Guest => "Guest",
            CommunicationRole::Channel => "Channel",
            CommunicationRole::System => "System",
            CommunicationRole::User => "User",
            CommunicationRole::Assistant => "Assistant",
            CommunicationRole::Service => "Service",
            CommunicationRole::Moderator => "Moderator",
            CommunicationRole::Group => "Group",
            CommunicationRole::Bot => "Bot",
            CommunicationRole::Admin => "Admin",
            CommunicationRole::Owner => "Owner",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CommunicationRole_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Member\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Member")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Guest\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Guest")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Channel\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Channel")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("System\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "System")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("User\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "User")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Assistant\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Assistant")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Service\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Service")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Moderator\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Moderator")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Group\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Group")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Bot\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bot")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Admin\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Admin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Owner\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Owner")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationRole\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CommunicationRole_183() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CommunicationRole\0",
        __register__enum__CommunicationRole_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CommunicationRole_183___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CommunicationRole_183___rust_ctor___ctor() -> usize {
        __napi_register__CommunicationRole_183();
        0
    }
    __napi_register__CommunicationRole_183___rust_ctor___ctor
};
pub enum ParticipantEngagementStatus {
    Inactive,
    Active,
    Left,
    Guest,
    Moderator,
    Banned,
    Admin,
}
#[automatically_derived]
impl ::core::marker::Copy for ParticipantEngagementStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ParticipantEngagementStatus {
    #[inline]
    fn clone(&self) -> ParticipantEngagementStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ParticipantEngagementStatus {
    fn type_name() -> &'static str {
        "ParticipantEngagementStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ParticipantEngagementStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ParticipantEngagementStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ParticipantEngagementStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Inactive" => Ok(ParticipantEngagementStatus::Inactive),
            "Active" => Ok(ParticipantEngagementStatus::Active),
            "Left" => Ok(ParticipantEngagementStatus::Left),
            "Guest" => Ok(ParticipantEngagementStatus::Guest),
            "Moderator" => Ok(ParticipantEngagementStatus::Moderator),
            "Banned" => Ok(ParticipantEngagementStatus::Banned),
            "Admin" => Ok(ParticipantEngagementStatus::Admin),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ParticipantEngagementStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ParticipantEngagementStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ParticipantEngagementStatus::Inactive => "Inactive",
            ParticipantEngagementStatus::Active => "Active",
            ParticipantEngagementStatus::Left => "Left",
            ParticipantEngagementStatus::Guest => "Guest",
            ParticipantEngagementStatus::Moderator => "Moderator",
            ParticipantEngagementStatus::Banned => "Banned",
            ParticipantEngagementStatus::Admin => "Admin",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ParticipantEngagementStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Left\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Left")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Guest\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Guest")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Moderator\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Moderator")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Banned\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Banned")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Admin\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Admin")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantEngagementStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ParticipantEngagementStatus_184() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ParticipantEngagementStatus\0",
        __register__enum__ParticipantEngagementStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ParticipantEngagementStatus_184___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ParticipantEngagementStatus_184___rust_ctor___ctor() -> usize {
        __napi_register__ParticipantEngagementStatus_184();
        0
    }
    __napi_register__ParticipantEngagementStatus_184___rust_ctor___ctor
};
pub enum ReactionType {
    Sad,
    Dislike,
    Angry,
    Laugh,
    Love,
    Bookmark,
    Wow,
    Interested,
    Like,
}
#[automatically_derived]
impl ::core::marker::Copy for ReactionType {}
#[automatically_derived]
impl ::core::clone::Clone for ReactionType {
    #[inline]
    fn clone(&self) -> ReactionType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ReactionType {
    fn type_name() -> &'static str {
        "ReactionType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ReactionType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ReactionType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ReactionType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Sad" => Ok(ReactionType::Sad),
            "Dislike" => Ok(ReactionType::Dislike),
            "Angry" => Ok(ReactionType::Angry),
            "Laugh" => Ok(ReactionType::Laugh),
            "Love" => Ok(ReactionType::Love),
            "Bookmark" => Ok(ReactionType::Bookmark),
            "Wow" => Ok(ReactionType::Wow),
            "Interested" => Ok(ReactionType::Interested),
            "Like" => Ok(ReactionType::Like),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ReactionType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ReactionType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ReactionType::Sad => "Sad",
            ReactionType::Dislike => "Dislike",
            ReactionType::Angry => "Angry",
            ReactionType::Laugh => "Laugh",
            ReactionType::Love => "Love",
            ReactionType::Bookmark => "Bookmark",
            ReactionType::Wow => "Wow",
            ReactionType::Interested => "Interested",
            ReactionType::Like => "Like",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ReactionType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sad\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sad")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Dislike\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Dislike")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Angry\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Angry")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Laugh\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Laugh")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Love\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Love")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Bookmark\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bookmark")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Wow\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Wow")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Interested\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Interested")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Like\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Like")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ReactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ReactionType_185() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ReactionType\0",
        __register__enum__ReactionType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ReactionType_185___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ReactionType_185___rust_ctor___ctor() -> usize {
        __napi_register__ReactionType_185();
        0
    }
    __napi_register__ReactionType_185___rust_ctor___ctor
};
pub enum SupportTicketPriority {
    Medium,
    Low,
    Immediate,
    High,
    Urgent,
}
#[automatically_derived]
impl ::core::marker::Copy for SupportTicketPriority {}
#[automatically_derived]
impl ::core::clone::Clone for SupportTicketPriority {
    #[inline]
    fn clone(&self) -> SupportTicketPriority {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for SupportTicketPriority {
    fn type_name() -> &'static str {
        "SupportTicketPriority"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for SupportTicketPriority {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for SupportTicketPriority {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "SupportTicketPriority",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Medium" => Ok(SupportTicketPriority::Medium),
            "Low" => Ok(SupportTicketPriority::Low),
            "Immediate" => Ok(SupportTicketPriority::Immediate),
            "High" => Ok(SupportTicketPriority::High),
            "Urgent" => Ok(SupportTicketPriority::Urgent),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "SupportTicketPriority",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for SupportTicketPriority {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            SupportTicketPriority::Medium => "Medium",
            SupportTicketPriority::Low => "Low",
            SupportTicketPriority::Immediate => "Immediate",
            SupportTicketPriority::High => "High",
            SupportTicketPriority::Urgent => "Urgent",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__SupportTicketPriority_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Medium\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Medium")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportTicketPriority\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Low\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Low")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportTicketPriority\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Immediate\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Immediate")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportTicketPriority\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("High\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "High")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportTicketPriority\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Urgent\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Urgent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportTicketPriority\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__SupportTicketPriority_186() {
    napi::bindgen_prelude::register_module_export(
        None,
        "SupportTicketPriority\0",
        __register__enum__SupportTicketPriority_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__SupportTicketPriority_186___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__SupportTicketPriority_186___rust_ctor___ctor() -> usize {
        __napi_register__SupportTicketPriority_186();
        0
    }
    __napi_register__SupportTicketPriority_186___rust_ctor___ctor
};
pub enum IssueLifecycleStatus {
    Pending,
    OnHold,
    InProgress,
    Cancelled,
    Resolved,
    Closed,
    Open,
}
#[automatically_derived]
impl ::core::marker::Copy for IssueLifecycleStatus {}
#[automatically_derived]
impl ::core::clone::Clone for IssueLifecycleStatus {
    #[inline]
    fn clone(&self) -> IssueLifecycleStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for IssueLifecycleStatus {
    fn type_name() -> &'static str {
        "IssueLifecycleStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for IssueLifecycleStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for IssueLifecycleStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "IssueLifecycleStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Pending" => Ok(IssueLifecycleStatus::Pending),
            "OnHold" => Ok(IssueLifecycleStatus::OnHold),
            "InProgress" => Ok(IssueLifecycleStatus::InProgress),
            "Cancelled" => Ok(IssueLifecycleStatus::Cancelled),
            "Resolved" => Ok(IssueLifecycleStatus::Resolved),
            "Closed" => Ok(IssueLifecycleStatus::Closed),
            "Open" => Ok(IssueLifecycleStatus::Open),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "IssueLifecycleStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for IssueLifecycleStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            IssueLifecycleStatus::Pending => "Pending",
            IssueLifecycleStatus::OnHold => "OnHold",
            IssueLifecycleStatus::InProgress => "InProgress",
            IssueLifecycleStatus::Cancelled => "Cancelled",
            IssueLifecycleStatus::Resolved => "Resolved",
            IssueLifecycleStatus::Closed => "Closed",
            IssueLifecycleStatus::Open => "Open",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__IssueLifecycleStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("OnHold\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OnHold")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InProgress\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InProgress")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Resolved\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Resolved")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Closed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Closed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Open\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Open")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "IssueLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__IssueLifecycleStatus_187() {
    napi::bindgen_prelude::register_module_export(
        None,
        "IssueLifecycleStatus\0",
        __register__enum__IssueLifecycleStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__IssueLifecycleStatus_187___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__IssueLifecycleStatus_187___rust_ctor___ctor() -> usize {
        __napi_register__IssueLifecycleStatus_187();
        0
    }
    __napi_register__IssueLifecycleStatus_187___rust_ctor___ctor
};
pub enum SupportQueryType {
    Problem,
    Task,
    Bug,
    FeatureRequest,
    Feedback,
    Question,
    Incident,
}
#[automatically_derived]
impl ::core::marker::Copy for SupportQueryType {}
#[automatically_derived]
impl ::core::clone::Clone for SupportQueryType {
    #[inline]
    fn clone(&self) -> SupportQueryType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for SupportQueryType {
    fn type_name() -> &'static str {
        "SupportQueryType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for SupportQueryType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for SupportQueryType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "SupportQueryType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Problem" => Ok(SupportQueryType::Problem),
            "Task" => Ok(SupportQueryType::Task),
            "Bug" => Ok(SupportQueryType::Bug),
            "FeatureRequest" => Ok(SupportQueryType::FeatureRequest),
            "Feedback" => Ok(SupportQueryType::Feedback),
            "Question" => Ok(SupportQueryType::Question),
            "Incident" => Ok(SupportQueryType::Incident),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "SupportQueryType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for SupportQueryType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            SupportQueryType::Problem => "Problem",
            SupportQueryType::Task => "Task",
            SupportQueryType::Bug => "Bug",
            SupportQueryType::FeatureRequest => "FeatureRequest",
            SupportQueryType::Feedback => "Feedback",
            SupportQueryType::Question => "Question",
            SupportQueryType::Incident => "Incident",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__SupportQueryType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Problem\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Problem")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Task\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Task")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Bug\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Bug")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "FeatureRequest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FeatureRequest")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Feedback\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Feedback")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Question\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Question")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Incident\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Incident")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "SupportQueryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__SupportQueryType_188() {
    napi::bindgen_prelude::register_module_export(
        None,
        "SupportQueryType\0",
        __register__enum__SupportQueryType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__SupportQueryType_188___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__SupportQueryType_188___rust_ctor___ctor() -> usize {
        __napi_register__SupportQueryType_188();
        0
    }
    __napi_register__SupportQueryType_188___rust_ctor___ctor
};
pub enum ItemEntityStatus {
    Archived,
    Suspended,
    Deleted,
    Pending,
    Completed,
    Active,
    Inactive,
}
#[automatically_derived]
impl ::core::marker::Copy for ItemEntityStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ItemEntityStatus {
    #[inline]
    fn clone(&self) -> ItemEntityStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ItemEntityStatus {
    fn type_name() -> &'static str {
        "ItemEntityStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ItemEntityStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ItemEntityStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ItemEntityStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Archived" => Ok(ItemEntityStatus::Archived),
            "Suspended" => Ok(ItemEntityStatus::Suspended),
            "Deleted" => Ok(ItemEntityStatus::Deleted),
            "Pending" => Ok(ItemEntityStatus::Pending),
            "Completed" => Ok(ItemEntityStatus::Completed),
            "Active" => Ok(ItemEntityStatus::Active),
            "Inactive" => Ok(ItemEntityStatus::Inactive),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ItemEntityStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ItemEntityStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ItemEntityStatus::Archived => "Archived",
            ItemEntityStatus::Suspended => "Suspended",
            ItemEntityStatus::Deleted => "Deleted",
            ItemEntityStatus::Pending => "Pending",
            ItemEntityStatus::Completed => "Completed",
            ItemEntityStatus::Active => "Active",
            ItemEntityStatus::Inactive => "Inactive",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ItemEntityStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Archived\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Archived")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suspended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suspended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Deleted\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Deleted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Completed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Completed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemEntityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ItemEntityStatus_189() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ItemEntityStatus\0",
        __register__enum__ItemEntityStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ItemEntityStatus_189___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ItemEntityStatus_189___rust_ctor___ctor() -> usize {
        __napi_register__ItemEntityStatus_189();
        0
    }
    __napi_register__ItemEntityStatus_189___rust_ctor___ctor
};
pub enum Currency {
    JPY,
    SGD,
    BRL,
    PLN,
    VND,
    OMR,
    JOD,
    DKK,
    BAM,
    GBP,
    SYP,
    RWF,
    BSD,
    AOA,
    FKP,
    IQD,
    JMD,
    JEP,
    NPR,
    AED,
    AWG,
    PYG,
    CZK,
    MNT,
    CNY,
    IDR,
    XPF,
    DOP,
    KES,
    LYD,
    GHS,
    SAR,
    KHR,
    TVD,
    MUR,
    SBD,
    KPW,
    AMD,
    GEL,
    BHD,
    RSD,
    MYR,
    TOP,
    LAK,
    VES,
    ISK,
    USD,
    COP,
    CLP,
    GTQ,
    HRK,
    NZD,
    ZMW,
    FJD,
    IMP,
    KID,
    MWK,
    CAD,
    GYD,
    RON,
    EGP,
    SCR,
    SHP,
    XAF,
    LBP,
    CHF,
    INR,
    TND,
    DZD,
    NIO,
    TRY,
    YER,
    BZD,
    HKD,
    HNL,
    MMK,
    HTG,
    SRD,
    IRR,
    NGN,
    KWD,
    BOB,
    PEN,
    MOP,
    STN,
    SOS,
    ZAR,
    MGA,
    ILS,
    ANG,
    LKR,
    BGN,
    LRD,
    PKR,
    SSP,
    UGX,
    MZN,
    UZS,
    KZT,
    KGS,
    ERN,
    THB,
    TWD,
    SEK,
    HUF,
    MXN,
    XCD,
    AZN,
    XDR,
    CDF,
    GMD,
    ALL,
    PAB,
    ZWL,
    PGK,
    AFN,
    BYN,
    MRU,
    QAR,
    BWP,
    CUC,
    ETB,
    MDL,
    PHP,
    CUP,
    KMF,
    LSL,
    TZS,
    TTD,
    NAD,
    BMD,
    RUB,
    MAD,
    VUV,
    BDT,
    EUR,
    KYD,
    BND,
    TMT,
    ARS,
    BIF,
    CRC,
    DJF,
    GNF,
    MVR,
    SDG,
    GGP,
    SZL,
    FOK,
    SLL,
    MKD,
    BTN,
    TJS,
    UAH,
    CVE,
    UYU,
    GIP,
    KRW,
    WST,
    XOF,
    NOK,
    AUD,
    BBD,
}
#[automatically_derived]
impl ::core::marker::Copy for Currency {}
#[automatically_derived]
impl ::core::clone::Clone for Currency {
    #[inline]
    fn clone(&self) -> Currency {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for Currency {
    fn type_name() -> &'static str {
        "Currency"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for Currency {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for Currency {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "Currency",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "JPY" => Ok(Currency::JPY),
            "SGD" => Ok(Currency::SGD),
            "BRL" => Ok(Currency::BRL),
            "PLN" => Ok(Currency::PLN),
            "VND" => Ok(Currency::VND),
            "OMR" => Ok(Currency::OMR),
            "JOD" => Ok(Currency::JOD),
            "DKK" => Ok(Currency::DKK),
            "BAM" => Ok(Currency::BAM),
            "GBP" => Ok(Currency::GBP),
            "SYP" => Ok(Currency::SYP),
            "RWF" => Ok(Currency::RWF),
            "BSD" => Ok(Currency::BSD),
            "AOA" => Ok(Currency::AOA),
            "FKP" => Ok(Currency::FKP),
            "IQD" => Ok(Currency::IQD),
            "JMD" => Ok(Currency::JMD),
            "JEP" => Ok(Currency::JEP),
            "NPR" => Ok(Currency::NPR),
            "AED" => Ok(Currency::AED),
            "AWG" => Ok(Currency::AWG),
            "PYG" => Ok(Currency::PYG),
            "CZK" => Ok(Currency::CZK),
            "MNT" => Ok(Currency::MNT),
            "CNY" => Ok(Currency::CNY),
            "IDR" => Ok(Currency::IDR),
            "XPF" => Ok(Currency::XPF),
            "DOP" => Ok(Currency::DOP),
            "KES" => Ok(Currency::KES),
            "LYD" => Ok(Currency::LYD),
            "GHS" => Ok(Currency::GHS),
            "SAR" => Ok(Currency::SAR),
            "KHR" => Ok(Currency::KHR),
            "TVD" => Ok(Currency::TVD),
            "MUR" => Ok(Currency::MUR),
            "SBD" => Ok(Currency::SBD),
            "KPW" => Ok(Currency::KPW),
            "AMD" => Ok(Currency::AMD),
            "GEL" => Ok(Currency::GEL),
            "BHD" => Ok(Currency::BHD),
            "RSD" => Ok(Currency::RSD),
            "MYR" => Ok(Currency::MYR),
            "TOP" => Ok(Currency::TOP),
            "LAK" => Ok(Currency::LAK),
            "VES" => Ok(Currency::VES),
            "ISK" => Ok(Currency::ISK),
            "USD" => Ok(Currency::USD),
            "COP" => Ok(Currency::COP),
            "CLP" => Ok(Currency::CLP),
            "GTQ" => Ok(Currency::GTQ),
            "HRK" => Ok(Currency::HRK),
            "NZD" => Ok(Currency::NZD),
            "ZMW" => Ok(Currency::ZMW),
            "FJD" => Ok(Currency::FJD),
            "IMP" => Ok(Currency::IMP),
            "KID" => Ok(Currency::KID),
            "MWK" => Ok(Currency::MWK),
            "CAD" => Ok(Currency::CAD),
            "GYD" => Ok(Currency::GYD),
            "RON" => Ok(Currency::RON),
            "EGP" => Ok(Currency::EGP),
            "SCR" => Ok(Currency::SCR),
            "SHP" => Ok(Currency::SHP),
            "XAF" => Ok(Currency::XAF),
            "LBP" => Ok(Currency::LBP),
            "CHF" => Ok(Currency::CHF),
            "INR" => Ok(Currency::INR),
            "TND" => Ok(Currency::TND),
            "DZD" => Ok(Currency::DZD),
            "NIO" => Ok(Currency::NIO),
            "TRY" => Ok(Currency::TRY),
            "YER" => Ok(Currency::YER),
            "BZD" => Ok(Currency::BZD),
            "HKD" => Ok(Currency::HKD),
            "HNL" => Ok(Currency::HNL),
            "MMK" => Ok(Currency::MMK),
            "HTG" => Ok(Currency::HTG),
            "SRD" => Ok(Currency::SRD),
            "IRR" => Ok(Currency::IRR),
            "NGN" => Ok(Currency::NGN),
            "KWD" => Ok(Currency::KWD),
            "BOB" => Ok(Currency::BOB),
            "PEN" => Ok(Currency::PEN),
            "MOP" => Ok(Currency::MOP),
            "STN" => Ok(Currency::STN),
            "SOS" => Ok(Currency::SOS),
            "ZAR" => Ok(Currency::ZAR),
            "MGA" => Ok(Currency::MGA),
            "ILS" => Ok(Currency::ILS),
            "ANG" => Ok(Currency::ANG),
            "LKR" => Ok(Currency::LKR),
            "BGN" => Ok(Currency::BGN),
            "LRD" => Ok(Currency::LRD),
            "PKR" => Ok(Currency::PKR),
            "SSP" => Ok(Currency::SSP),
            "UGX" => Ok(Currency::UGX),
            "MZN" => Ok(Currency::MZN),
            "UZS" => Ok(Currency::UZS),
            "KZT" => Ok(Currency::KZT),
            "KGS" => Ok(Currency::KGS),
            "ERN" => Ok(Currency::ERN),
            "THB" => Ok(Currency::THB),
            "TWD" => Ok(Currency::TWD),
            "SEK" => Ok(Currency::SEK),
            "HUF" => Ok(Currency::HUF),
            "MXN" => Ok(Currency::MXN),
            "XCD" => Ok(Currency::XCD),
            "AZN" => Ok(Currency::AZN),
            "XDR" => Ok(Currency::XDR),
            "CDF" => Ok(Currency::CDF),
            "GMD" => Ok(Currency::GMD),
            "ALL" => Ok(Currency::ALL),
            "PAB" => Ok(Currency::PAB),
            "ZWL" => Ok(Currency::ZWL),
            "PGK" => Ok(Currency::PGK),
            "AFN" => Ok(Currency::AFN),
            "BYN" => Ok(Currency::BYN),
            "MRU" => Ok(Currency::MRU),
            "QAR" => Ok(Currency::QAR),
            "BWP" => Ok(Currency::BWP),
            "CUC" => Ok(Currency::CUC),
            "ETB" => Ok(Currency::ETB),
            "MDL" => Ok(Currency::MDL),
            "PHP" => Ok(Currency::PHP),
            "CUP" => Ok(Currency::CUP),
            "KMF" => Ok(Currency::KMF),
            "LSL" => Ok(Currency::LSL),
            "TZS" => Ok(Currency::TZS),
            "TTD" => Ok(Currency::TTD),
            "NAD" => Ok(Currency::NAD),
            "BMD" => Ok(Currency::BMD),
            "RUB" => Ok(Currency::RUB),
            "MAD" => Ok(Currency::MAD),
            "VUV" => Ok(Currency::VUV),
            "BDT" => Ok(Currency::BDT),
            "EUR" => Ok(Currency::EUR),
            "KYD" => Ok(Currency::KYD),
            "BND" => Ok(Currency::BND),
            "TMT" => Ok(Currency::TMT),
            "ARS" => Ok(Currency::ARS),
            "BIF" => Ok(Currency::BIF),
            "CRC" => Ok(Currency::CRC),
            "DJF" => Ok(Currency::DJF),
            "GNF" => Ok(Currency::GNF),
            "MVR" => Ok(Currency::MVR),
            "SDG" => Ok(Currency::SDG),
            "GGP" => Ok(Currency::GGP),
            "SZL" => Ok(Currency::SZL),
            "FOK" => Ok(Currency::FOK),
            "SLL" => Ok(Currency::SLL),
            "MKD" => Ok(Currency::MKD),
            "BTN" => Ok(Currency::BTN),
            "TJS" => Ok(Currency::TJS),
            "UAH" => Ok(Currency::UAH),
            "CVE" => Ok(Currency::CVE),
            "UYU" => Ok(Currency::UYU),
            "GIP" => Ok(Currency::GIP),
            "KRW" => Ok(Currency::KRW),
            "WST" => Ok(Currency::WST),
            "XOF" => Ok(Currency::XOF),
            "NOK" => Ok(Currency::NOK),
            "AUD" => Ok(Currency::AUD),
            "BBD" => Ok(Currency::BBD),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "Currency",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for Currency {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            Currency::JPY => "JPY",
            Currency::SGD => "SGD",
            Currency::BRL => "BRL",
            Currency::PLN => "PLN",
            Currency::VND => "VND",
            Currency::OMR => "OMR",
            Currency::JOD => "JOD",
            Currency::DKK => "DKK",
            Currency::BAM => "BAM",
            Currency::GBP => "GBP",
            Currency::SYP => "SYP",
            Currency::RWF => "RWF",
            Currency::BSD => "BSD",
            Currency::AOA => "AOA",
            Currency::FKP => "FKP",
            Currency::IQD => "IQD",
            Currency::JMD => "JMD",
            Currency::JEP => "JEP",
            Currency::NPR => "NPR",
            Currency::AED => "AED",
            Currency::AWG => "AWG",
            Currency::PYG => "PYG",
            Currency::CZK => "CZK",
            Currency::MNT => "MNT",
            Currency::CNY => "CNY",
            Currency::IDR => "IDR",
            Currency::XPF => "XPF",
            Currency::DOP => "DOP",
            Currency::KES => "KES",
            Currency::LYD => "LYD",
            Currency::GHS => "GHS",
            Currency::SAR => "SAR",
            Currency::KHR => "KHR",
            Currency::TVD => "TVD",
            Currency::MUR => "MUR",
            Currency::SBD => "SBD",
            Currency::KPW => "KPW",
            Currency::AMD => "AMD",
            Currency::GEL => "GEL",
            Currency::BHD => "BHD",
            Currency::RSD => "RSD",
            Currency::MYR => "MYR",
            Currency::TOP => "TOP",
            Currency::LAK => "LAK",
            Currency::VES => "VES",
            Currency::ISK => "ISK",
            Currency::USD => "USD",
            Currency::COP => "COP",
            Currency::CLP => "CLP",
            Currency::GTQ => "GTQ",
            Currency::HRK => "HRK",
            Currency::NZD => "NZD",
            Currency::ZMW => "ZMW",
            Currency::FJD => "FJD",
            Currency::IMP => "IMP",
            Currency::KID => "KID",
            Currency::MWK => "MWK",
            Currency::CAD => "CAD",
            Currency::GYD => "GYD",
            Currency::RON => "RON",
            Currency::EGP => "EGP",
            Currency::SCR => "SCR",
            Currency::SHP => "SHP",
            Currency::XAF => "XAF",
            Currency::LBP => "LBP",
            Currency::CHF => "CHF",
            Currency::INR => "INR",
            Currency::TND => "TND",
            Currency::DZD => "DZD",
            Currency::NIO => "NIO",
            Currency::TRY => "TRY",
            Currency::YER => "YER",
            Currency::BZD => "BZD",
            Currency::HKD => "HKD",
            Currency::HNL => "HNL",
            Currency::MMK => "MMK",
            Currency::HTG => "HTG",
            Currency::SRD => "SRD",
            Currency::IRR => "IRR",
            Currency::NGN => "NGN",
            Currency::KWD => "KWD",
            Currency::BOB => "BOB",
            Currency::PEN => "PEN",
            Currency::MOP => "MOP",
            Currency::STN => "STN",
            Currency::SOS => "SOS",
            Currency::ZAR => "ZAR",
            Currency::MGA => "MGA",
            Currency::ILS => "ILS",
            Currency::ANG => "ANG",
            Currency::LKR => "LKR",
            Currency::BGN => "BGN",
            Currency::LRD => "LRD",
            Currency::PKR => "PKR",
            Currency::SSP => "SSP",
            Currency::UGX => "UGX",
            Currency::MZN => "MZN",
            Currency::UZS => "UZS",
            Currency::KZT => "KZT",
            Currency::KGS => "KGS",
            Currency::ERN => "ERN",
            Currency::THB => "THB",
            Currency::TWD => "TWD",
            Currency::SEK => "SEK",
            Currency::HUF => "HUF",
            Currency::MXN => "MXN",
            Currency::XCD => "XCD",
            Currency::AZN => "AZN",
            Currency::XDR => "XDR",
            Currency::CDF => "CDF",
            Currency::GMD => "GMD",
            Currency::ALL => "ALL",
            Currency::PAB => "PAB",
            Currency::ZWL => "ZWL",
            Currency::PGK => "PGK",
            Currency::AFN => "AFN",
            Currency::BYN => "BYN",
            Currency::MRU => "MRU",
            Currency::QAR => "QAR",
            Currency::BWP => "BWP",
            Currency::CUC => "CUC",
            Currency::ETB => "ETB",
            Currency::MDL => "MDL",
            Currency::PHP => "PHP",
            Currency::CUP => "CUP",
            Currency::KMF => "KMF",
            Currency::LSL => "LSL",
            Currency::TZS => "TZS",
            Currency::TTD => "TTD",
            Currency::NAD => "NAD",
            Currency::BMD => "BMD",
            Currency::RUB => "RUB",
            Currency::MAD => "MAD",
            Currency::VUV => "VUV",
            Currency::BDT => "BDT",
            Currency::EUR => "EUR",
            Currency::KYD => "KYD",
            Currency::BND => "BND",
            Currency::TMT => "TMT",
            Currency::ARS => "ARS",
            Currency::BIF => "BIF",
            Currency::CRC => "CRC",
            Currency::DJF => "DJF",
            Currency::GNF => "GNF",
            Currency::MVR => "MVR",
            Currency::SDG => "SDG",
            Currency::GGP => "GGP",
            Currency::SZL => "SZL",
            Currency::FOK => "FOK",
            Currency::SLL => "SLL",
            Currency::MKD => "MKD",
            Currency::BTN => "BTN",
            Currency::TJS => "TJS",
            Currency::UAH => "UAH",
            Currency::CVE => "CVE",
            Currency::UYU => "UYU",
            Currency::GIP => "GIP",
            Currency::KRW => "KRW",
            Currency::WST => "WST",
            Currency::XOF => "XOF",
            Currency::NOK => "NOK",
            Currency::AUD => "AUD",
            Currency::BBD => "BBD",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__Currency_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("JPY\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "JPY")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SGD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SGD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BRL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BRL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PLN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PLN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("VND\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "VND")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("OMR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OMR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("JOD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "JOD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("DKK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DKK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BAM\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BAM")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GBP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GBP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SYP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SYP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("RWF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RWF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BSD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BSD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AOA\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AOA")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("FKP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FKP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("IQD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "IQD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("JMD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "JMD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("JEP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "JEP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("NPR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NPR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AED\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AED")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AWG\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AWG")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PYG\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PYG")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CZK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CZK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MNT\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MNT")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CNY\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CNY")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("IDR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "IDR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("XPF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "XPF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("DOP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DOP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KES\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KES")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LYD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LYD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GHS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GHS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SAR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SAR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KHR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KHR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TVD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TVD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MUR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MUR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SBD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SBD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KPW\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KPW")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AMD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AMD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GEL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GEL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BHD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BHD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("RSD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RSD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MYR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MYR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TOP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TOP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LAK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LAK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("VES\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "VES")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ISK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ISK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("USD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "USD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("COP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "COP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CLP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CLP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GTQ\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GTQ")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("HRK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "HRK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("NZD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NZD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ZMW\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ZMW")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("FJD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FJD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("IMP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "IMP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KID\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KID")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MWK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MWK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CAD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CAD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GYD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GYD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("RON\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RON")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("EGP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "EGP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SCR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SCR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SHP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SHP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("XAF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "XAF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LBP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LBP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CHF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CHF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("INR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "INR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TND\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TND")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("DZD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DZD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("NIO\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NIO")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TRY\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TRY")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("YER\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "YER")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BZD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BZD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("HKD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "HKD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("HNL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "HNL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MMK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MMK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("HTG\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "HTG")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SRD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SRD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("IRR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "IRR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("NGN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NGN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KWD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KWD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BOB\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BOB")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PEN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PEN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MOP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MOP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("STN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "STN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SOS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SOS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ZAR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ZAR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MGA\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MGA")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ILS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ILS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ANG\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ANG")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LKR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LKR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BGN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BGN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LRD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LRD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PKR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PKR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SSP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SSP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("UGX\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UGX")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MZN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MZN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("UZS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UZS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KZT\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KZT")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KGS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KGS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ERN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ERN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("THB\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "THB")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TWD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TWD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SEK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SEK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("HUF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "HUF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MXN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MXN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("XCD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "XCD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AZN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AZN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("XDR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "XDR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CDF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CDF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GMD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GMD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ALL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ALL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PAB\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PAB")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ZWL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ZWL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PGK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PGK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AFN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AFN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BYN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BYN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MRU\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MRU")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("QAR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "QAR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BWP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BWP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CUC\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CUC")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ETB\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ETB")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MDL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MDL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("PHP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PHP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CUP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CUP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KMF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KMF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LSL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LSL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TZS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TZS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TTD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TTD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("NAD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NAD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BMD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BMD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("RUB\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RUB")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MAD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MAD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("VUV\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "VUV")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BDT\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BDT")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("EUR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "EUR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KYD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KYD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BND\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BND")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TMT\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TMT")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("ARS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ARS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BIF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BIF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CRC\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CRC")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("DJF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DJF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GNF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GNF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MVR\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MVR")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SDG\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SDG")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GGP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GGP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SZL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SZL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("FOK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FOK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("SLL\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SLL")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("MKD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MKD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BTN\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BTN")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("TJS\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TJS")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("UAH\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UAH")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("CVE\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CVE")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("UYU\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UYU")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("GIP\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "GIP")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("KRW\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "KRW")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("WST\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "WST")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("XOF\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "XOF")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("NOK\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NOK")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("AUD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AUD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("BBD\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BBD")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "Currency\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__Currency_190() {
    napi::bindgen_prelude::register_module_export(
        None,
        "Currency\0",
        __register__enum__Currency_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__Currency_190___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__Currency_190___rust_ctor___ctor() -> usize {
        __napi_register__Currency_190();
        0
    }
    __napi_register__Currency_190___rust_ctor___ctor
};
pub enum OrderStatus {
    Refunded,
    Cancelled,
    Disputed,
    Failed,
    OnHold,
    AwaitingPayment,
    AwaitingPickup,
    Processing,
    Delivered,
    Shipped,
    Returned,
    Completed,
    Pending,
    AwaitingShipment,
    Abandoned,
}
#[automatically_derived]
impl ::core::marker::Copy for OrderStatus {}
#[automatically_derived]
impl ::core::clone::Clone for OrderStatus {
    #[inline]
    fn clone(&self) -> OrderStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for OrderStatus {
    fn type_name() -> &'static str {
        "OrderStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for OrderStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for OrderStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "OrderStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Refunded" => Ok(OrderStatus::Refunded),
            "Cancelled" => Ok(OrderStatus::Cancelled),
            "Disputed" => Ok(OrderStatus::Disputed),
            "Failed" => Ok(OrderStatus::Failed),
            "OnHold" => Ok(OrderStatus::OnHold),
            "AwaitingPayment" => Ok(OrderStatus::AwaitingPayment),
            "AwaitingPickup" => Ok(OrderStatus::AwaitingPickup),
            "Processing" => Ok(OrderStatus::Processing),
            "Delivered" => Ok(OrderStatus::Delivered),
            "Shipped" => Ok(OrderStatus::Shipped),
            "Returned" => Ok(OrderStatus::Returned),
            "Completed" => Ok(OrderStatus::Completed),
            "Pending" => Ok(OrderStatus::Pending),
            "AwaitingShipment" => Ok(OrderStatus::AwaitingShipment),
            "Abandoned" => Ok(OrderStatus::Abandoned),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "OrderStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for OrderStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            OrderStatus::Refunded => "Refunded",
            OrderStatus::Cancelled => "Cancelled",
            OrderStatus::Disputed => "Disputed",
            OrderStatus::Failed => "Failed",
            OrderStatus::OnHold => "OnHold",
            OrderStatus::AwaitingPayment => "AwaitingPayment",
            OrderStatus::AwaitingPickup => "AwaitingPickup",
            OrderStatus::Processing => "Processing",
            OrderStatus::Delivered => "Delivered",
            OrderStatus::Shipped => "Shipped",
            OrderStatus::Returned => "Returned",
            OrderStatus::Completed => "Completed",
            OrderStatus::Pending => "Pending",
            OrderStatus::AwaitingShipment => "AwaitingShipment",
            OrderStatus::Abandoned => "Abandoned",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__OrderStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Refunded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Refunded")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Disputed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Disputed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("OnHold\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OnHold")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AwaitingPayment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AwaitingPayment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AwaitingPickup\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AwaitingPickup")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Processing\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Processing")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Delivered\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Delivered")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Shipped\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Shipped")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Returned\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Returned")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Completed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Completed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AwaitingShipment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AwaitingShipment",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Abandoned\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Abandoned")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__OrderStatus_191() {
    napi::bindgen_prelude::register_module_export(
        None,
        "OrderStatus\0",
        __register__enum__OrderStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__OrderStatus_191___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__OrderStatus_191___rust_ctor___ctor() -> usize {
        __napi_register__OrderStatus_191();
        0
    }
    __napi_register__OrderStatus_191___rust_ctor___ctor
};
pub enum DiscountType {
    BuyOneGetOne,
    Percentage,
    ConditionalDiscount,
    FixedAmount,
    TieredDiscount,
}
#[automatically_derived]
impl ::core::marker::Copy for DiscountType {}
#[automatically_derived]
impl ::core::clone::Clone for DiscountType {
    #[inline]
    fn clone(&self) -> DiscountType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for DiscountType {
    fn type_name() -> &'static str {
        "DiscountType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for DiscountType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for DiscountType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "DiscountType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "BuyOneGetOne" => Ok(DiscountType::BuyOneGetOne),
            "Percentage" => Ok(DiscountType::Percentage),
            "ConditionalDiscount" => Ok(DiscountType::ConditionalDiscount),
            "FixedAmount" => Ok(DiscountType::FixedAmount),
            "TieredDiscount" => Ok(DiscountType::TieredDiscount),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "DiscountType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for DiscountType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            DiscountType::BuyOneGetOne => "BuyOneGetOne",
            DiscountType::Percentage => "Percentage",
            DiscountType::ConditionalDiscount => "ConditionalDiscount",
            DiscountType::FixedAmount => "FixedAmount",
            DiscountType::TieredDiscount => "TieredDiscount",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__DiscountType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BuyOneGetOne\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BuyOneGetOne")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DiscountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Percentage\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Percentage")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DiscountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ConditionalDiscount\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ConditionalDiscount",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DiscountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "FixedAmount\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FixedAmount")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DiscountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "TieredDiscount\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TieredDiscount")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DiscountType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__DiscountType_192() {
    napi::bindgen_prelude::register_module_export(
        None,
        "DiscountType\0",
        __register__enum__DiscountType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__DiscountType_192___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__DiscountType_192___rust_ctor___ctor() -> usize {
        __napi_register__DiscountType_192();
        0
    }
    __napi_register__DiscountType_192___rust_ctor___ctor
};
pub enum CustomerEligibilityStatus {
    ReturningCustomers,
    VipCustomers,
    AllCustomers,
    NewCustomers,
    SpecificConditions,
    Other,
}
#[automatically_derived]
impl ::core::marker::Copy for CustomerEligibilityStatus {}
#[automatically_derived]
impl ::core::clone::Clone for CustomerEligibilityStatus {
    #[inline]
    fn clone(&self) -> CustomerEligibilityStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CustomerEligibilityStatus {
    fn type_name() -> &'static str {
        "CustomerEligibilityStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CustomerEligibilityStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CustomerEligibilityStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CustomerEligibilityStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "ReturningCustomers" => Ok(CustomerEligibilityStatus::ReturningCustomers),
            "VipCustomers" => Ok(CustomerEligibilityStatus::VipCustomers),
            "AllCustomers" => Ok(CustomerEligibilityStatus::AllCustomers),
            "NewCustomers" => Ok(CustomerEligibilityStatus::NewCustomers),
            "SpecificConditions" => Ok(CustomerEligibilityStatus::SpecificConditions),
            "Other" => Ok(CustomerEligibilityStatus::Other),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CustomerEligibilityStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CustomerEligibilityStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CustomerEligibilityStatus::ReturningCustomers => "ReturningCustomers",
            CustomerEligibilityStatus::VipCustomers => "VipCustomers",
            CustomerEligibilityStatus::AllCustomers => "AllCustomers",
            CustomerEligibilityStatus::NewCustomers => "NewCustomers",
            CustomerEligibilityStatus::SpecificConditions => "SpecificConditions",
            CustomerEligibilityStatus::Other => "Other",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CustomerEligibilityStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ReturningCustomers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ReturningCustomers",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerEligibilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "VipCustomers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "VipCustomers")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerEligibilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AllCustomers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "AllCustomers")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerEligibilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "NewCustomers\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NewCustomers")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerEligibilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SpecificConditions\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "SpecificConditions",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerEligibilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CustomerEligibilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CustomerEligibilityStatus_193() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CustomerEligibilityStatus\0",
        __register__enum__CustomerEligibilityStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CustomerEligibilityStatus_193___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CustomerEligibilityStatus_193___rust_ctor___ctor() -> usize {
        __napi_register__CustomerEligibilityStatus_193();
        0
    }
    __napi_register__CustomerEligibilityStatus_193___rust_ctor___ctor
};
pub enum ImageMimeType {
    ImageTiff,
    ImagePng,
    ImageBmp,
    ImageSvgXml,
    ImageHeic,
    ImageWebp,
    ImageGif,
    ImageJpeg,
}
#[automatically_derived]
impl ::core::marker::Copy for ImageMimeType {}
#[automatically_derived]
impl ::core::clone::Clone for ImageMimeType {
    #[inline]
    fn clone(&self) -> ImageMimeType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ImageMimeType {
    fn type_name() -> &'static str {
        "ImageMimeType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ImageMimeType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ImageMimeType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ImageMimeType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "ImageTiff" => Ok(ImageMimeType::ImageTiff),
            "ImagePng" => Ok(ImageMimeType::ImagePng),
            "ImageBmp" => Ok(ImageMimeType::ImageBmp),
            "ImageSvgXml" => Ok(ImageMimeType::ImageSvgXml),
            "ImageHeic" => Ok(ImageMimeType::ImageHeic),
            "ImageWebp" => Ok(ImageMimeType::ImageWebp),
            "ImageGif" => Ok(ImageMimeType::ImageGif),
            "ImageJpeg" => Ok(ImageMimeType::ImageJpeg),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ImageMimeType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ImageMimeType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ImageMimeType::ImageTiff => "ImageTiff",
            ImageMimeType::ImagePng => "ImagePng",
            ImageMimeType::ImageBmp => "ImageBmp",
            ImageMimeType::ImageSvgXml => "ImageSvgXml",
            ImageMimeType::ImageHeic => "ImageHeic",
            ImageMimeType::ImageWebp => "ImageWebp",
            ImageMimeType::ImageGif => "ImageGif",
            ImageMimeType::ImageJpeg => "ImageJpeg",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ImageMimeType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageTiff\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageTiff")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImagePng\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImagePng")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageBmp\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageBmp")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageSvgXml\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageSvgXml")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageHeic\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageHeic")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageWebp\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageWebp")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageGif\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageGif")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageJpeg\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageJpeg")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ImageMimeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ImageMimeType_194() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ImageMimeType\0",
        __register__enum__ImageMimeType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ImageMimeType_194___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ImageMimeType_194___rust_ctor___ctor() -> usize {
        __napi_register__ImageMimeType_194();
        0
    }
    __napi_register__ImageMimeType_194___rust_ctor___ctor
};
pub enum LifecycleStatus {
    Issued,
    Expired,
    Active,
    Suspended,
    Cancelled,
    Redeemed,
}
#[automatically_derived]
impl ::core::marker::Copy for LifecycleStatus {}
#[automatically_derived]
impl ::core::clone::Clone for LifecycleStatus {
    #[inline]
    fn clone(&self) -> LifecycleStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for LifecycleStatus {
    fn type_name() -> &'static str {
        "LifecycleStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for LifecycleStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for LifecycleStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "LifecycleStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Issued" => Ok(LifecycleStatus::Issued),
            "Expired" => Ok(LifecycleStatus::Expired),
            "Active" => Ok(LifecycleStatus::Active),
            "Suspended" => Ok(LifecycleStatus::Suspended),
            "Cancelled" => Ok(LifecycleStatus::Cancelled),
            "Redeemed" => Ok(LifecycleStatus::Redeemed),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "LifecycleStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for LifecycleStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            LifecycleStatus::Issued => "Issued",
            LifecycleStatus::Expired => "Expired",
            LifecycleStatus::Active => "Active",
            LifecycleStatus::Suspended => "Suspended",
            LifecycleStatus::Cancelled => "Cancelled",
            LifecycleStatus::Redeemed => "Redeemed",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__LifecycleStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Issued\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Issued")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Expired\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Expired")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suspended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suspended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Redeemed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Redeemed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "LifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__LifecycleStatus_195() {
    napi::bindgen_prelude::register_module_export(
        None,
        "LifecycleStatus\0",
        __register__enum__LifecycleStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__LifecycleStatus_195___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__LifecycleStatus_195___rust_ctor___ctor() -> usize {
        __napi_register__LifecycleStatus_195();
        0
    }
    __napi_register__LifecycleStatus_195___rust_ctor___ctor
};
pub enum FulfillmentStatus {
    Delivered,
    Failure,
    Cancelled,
    Pending,
    InTransit,
    Returned,
}
#[automatically_derived]
impl ::core::marker::Copy for FulfillmentStatus {}
#[automatically_derived]
impl ::core::clone::Clone for FulfillmentStatus {
    #[inline]
    fn clone(&self) -> FulfillmentStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FulfillmentStatus {
    fn type_name() -> &'static str {
        "FulfillmentStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FulfillmentStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FulfillmentStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FulfillmentStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Delivered" => Ok(FulfillmentStatus::Delivered),
            "Failure" => Ok(FulfillmentStatus::Failure),
            "Cancelled" => Ok(FulfillmentStatus::Cancelled),
            "Pending" => Ok(FulfillmentStatus::Pending),
            "InTransit" => Ok(FulfillmentStatus::InTransit),
            "Returned" => Ok(FulfillmentStatus::Returned),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FulfillmentStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FulfillmentStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FulfillmentStatus::Delivered => "Delivered",
            FulfillmentStatus::Failure => "Failure",
            FulfillmentStatus::Cancelled => "Cancelled",
            FulfillmentStatus::Pending => "Pending",
            FulfillmentStatus::InTransit => "InTransit",
            FulfillmentStatus::Returned => "Returned",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FulfillmentStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Delivered\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Delivered")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FulfillmentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failure\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failure")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FulfillmentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FulfillmentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FulfillmentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InTransit\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InTransit")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FulfillmentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Returned\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Returned")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FulfillmentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FulfillmentStatus_196() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FulfillmentStatus\0",
        __register__enum__FulfillmentStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FulfillmentStatus_196___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FulfillmentStatus_196___rust_ctor___ctor() -> usize {
        __napi_register__FulfillmentStatus_196();
        0
    }
    __napi_register__FulfillmentStatus_196___rust_ctor___ctor
};
pub enum PaymentMethod {
    MobilePayment,
    CreditCard,
    Paypal,
    BankTransfer,
    Check,
    Cryptocurrency,
    DebitCard,
    Other,
    MobileWallet,
    Cash,
    CashOnDelivery,
}
#[automatically_derived]
impl ::core::marker::Copy for PaymentMethod {}
#[automatically_derived]
impl ::core::clone::Clone for PaymentMethod {
    #[inline]
    fn clone(&self) -> PaymentMethod {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for PaymentMethod {
    fn type_name() -> &'static str {
        "PaymentMethod"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PaymentMethod {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for PaymentMethod {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "PaymentMethod",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "MobilePayment" => Ok(PaymentMethod::MobilePayment),
            "CreditCard" => Ok(PaymentMethod::CreditCard),
            "Paypal" => Ok(PaymentMethod::Paypal),
            "BankTransfer" => Ok(PaymentMethod::BankTransfer),
            "Check" => Ok(PaymentMethod::Check),
            "Cryptocurrency" => Ok(PaymentMethod::Cryptocurrency),
            "DebitCard" => Ok(PaymentMethod::DebitCard),
            "Other" => Ok(PaymentMethod::Other),
            "MobileWallet" => Ok(PaymentMethod::MobileWallet),
            "Cash" => Ok(PaymentMethod::Cash),
            "CashOnDelivery" => Ok(PaymentMethod::CashOnDelivery),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "PaymentMethod",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for PaymentMethod {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            PaymentMethod::MobilePayment => "MobilePayment",
            PaymentMethod::CreditCard => "CreditCard",
            PaymentMethod::Paypal => "Paypal",
            PaymentMethod::BankTransfer => "BankTransfer",
            PaymentMethod::Check => "Check",
            PaymentMethod::Cryptocurrency => "Cryptocurrency",
            PaymentMethod::DebitCard => "DebitCard",
            PaymentMethod::Other => "Other",
            PaymentMethod::MobileWallet => "MobileWallet",
            PaymentMethod::Cash => "Cash",
            PaymentMethod::CashOnDelivery => "CashOnDelivery",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__PaymentMethod_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "MobilePayment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MobilePayment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CreditCard\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CreditCard")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Paypal\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Paypal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BankTransfer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BankTransfer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Check\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Check")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cryptocurrency\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cryptocurrency")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DebitCard\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DebitCard")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "MobileWallet\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "MobileWallet")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Cash\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cash")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CashOnDelivery\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CashOnDelivery")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__PaymentMethod_197() {
    napi::bindgen_prelude::register_module_export(
        None,
        "PaymentMethod\0",
        __register__enum__PaymentMethod_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__PaymentMethod_197___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__PaymentMethod_197___rust_ctor___ctor() -> usize {
        __napi_register__PaymentMethod_197();
        0
    }
    __napi_register__PaymentMethod_197___rust_ctor___ctor
};
pub enum FinancialTransactionStatus {
    Cleared,
    Cancelled,
    Authorized,
    SettlementInProgress,
    Failed,
    Refunded,
    Disputed,
    Pending,
}
#[automatically_derived]
impl ::core::marker::Copy for FinancialTransactionStatus {}
#[automatically_derived]
impl ::core::clone::Clone for FinancialTransactionStatus {
    #[inline]
    fn clone(&self) -> FinancialTransactionStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FinancialTransactionStatus {
    fn type_name() -> &'static str {
        "FinancialTransactionStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FinancialTransactionStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FinancialTransactionStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FinancialTransactionStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Cleared" => Ok(FinancialTransactionStatus::Cleared),
            "Cancelled" => Ok(FinancialTransactionStatus::Cancelled),
            "Authorized" => Ok(FinancialTransactionStatus::Authorized),
            "SettlementInProgress" => {
                Ok(FinancialTransactionStatus::SettlementInProgress)
            }
            "Failed" => Ok(FinancialTransactionStatus::Failed),
            "Refunded" => Ok(FinancialTransactionStatus::Refunded),
            "Disputed" => Ok(FinancialTransactionStatus::Disputed),
            "Pending" => Ok(FinancialTransactionStatus::Pending),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FinancialTransactionStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FinancialTransactionStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FinancialTransactionStatus::Cleared => "Cleared",
            FinancialTransactionStatus::Cancelled => "Cancelled",
            FinancialTransactionStatus::Authorized => "Authorized",
            FinancialTransactionStatus::SettlementInProgress => "SettlementInProgress",
            FinancialTransactionStatus::Failed => "Failed",
            FinancialTransactionStatus::Refunded => "Refunded",
            FinancialTransactionStatus::Disputed => "Disputed",
            FinancialTransactionStatus::Pending => "Pending",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FinancialTransactionStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Cleared\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cleared")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Authorized\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Authorized")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SettlementInProgress\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "SettlementInProgress",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Refunded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Refunded")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Disputed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Disputed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FinancialTransactionStatus_198() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FinancialTransactionStatus\0",
        __register__enum__FinancialTransactionStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FinancialTransactionStatus_198___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FinancialTransactionStatus_198___rust_ctor___ctor() -> usize {
        __napi_register__FinancialTransactionStatus_198();
        0
    }
    __napi_register__FinancialTransactionStatus_198___rust_ctor___ctor
};
pub enum OrderingCriteria {
    Rating,
    PriceAscending,
    Relevance,
    Alphabetical,
    CreationDate,
    Popularity,
    Manual,
    PriceDescending,
}
#[automatically_derived]
impl ::core::marker::Copy for OrderingCriteria {}
#[automatically_derived]
impl ::core::clone::Clone for OrderingCriteria {
    #[inline]
    fn clone(&self) -> OrderingCriteria {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for OrderingCriteria {
    fn type_name() -> &'static str {
        "OrderingCriteria"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for OrderingCriteria {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for OrderingCriteria {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "OrderingCriteria",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Rating" => Ok(OrderingCriteria::Rating),
            "PriceAscending" => Ok(OrderingCriteria::PriceAscending),
            "Relevance" => Ok(OrderingCriteria::Relevance),
            "Alphabetical" => Ok(OrderingCriteria::Alphabetical),
            "CreationDate" => Ok(OrderingCriteria::CreationDate),
            "Popularity" => Ok(OrderingCriteria::Popularity),
            "Manual" => Ok(OrderingCriteria::Manual),
            "PriceDescending" => Ok(OrderingCriteria::PriceDescending),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "OrderingCriteria",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for OrderingCriteria {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            OrderingCriteria::Rating => "Rating",
            OrderingCriteria::PriceAscending => "PriceAscending",
            OrderingCriteria::Relevance => "Relevance",
            OrderingCriteria::Alphabetical => "Alphabetical",
            OrderingCriteria::CreationDate => "CreationDate",
            OrderingCriteria::Popularity => "Popularity",
            OrderingCriteria::Manual => "Manual",
            OrderingCriteria::PriceDescending => "PriceDescending",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__OrderingCriteria_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Rating\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Rating")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PriceAscending\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PriceAscending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Relevance\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Relevance")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Alphabetical\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Alphabetical")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "CreationDate\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "CreationDate")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Popularity\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Popularity")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Manual\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Manual")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PriceDescending\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "PriceDescending",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "OrderingCriteria\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__OrderingCriteria_199() {
    napi::bindgen_prelude::register_module_export(
        None,
        "OrderingCriteria\0",
        __register__enum__OrderingCriteria_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__OrderingCriteria_199___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__OrderingCriteria_199___rust_ctor___ctor() -> usize {
        __napi_register__OrderingCriteria_199();
        0
    }
    __napi_register__OrderingCriteria_199___rust_ctor___ctor
};
pub enum ChatType {
    Public,
    Group,
    Private,
}
#[automatically_derived]
impl ::core::marker::Copy for ChatType {}
#[automatically_derived]
impl ::core::clone::Clone for ChatType {
    #[inline]
    fn clone(&self) -> ChatType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ChatType {
    fn type_name() -> &'static str {
        "ChatType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ChatType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ChatType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ChatType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Public" => Ok(ChatType::Public),
            "Group" => Ok(ChatType::Group),
            "Private" => Ok(ChatType::Private),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ChatType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ChatType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ChatType::Public => "Public",
            ChatType::Group => "Group",
            ChatType::Private => "Private",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ChatType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Public\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Public")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "ChatType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Group\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Group")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "ChatType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Private\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Private")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "ChatType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ChatType_200() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ChatType\0",
        __register__enum__ChatType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ChatType_200___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ChatType_200___rust_ctor___ctor() -> usize {
        __napi_register__ChatType_200();
        0
    }
    __napi_register__ChatType_200___rust_ctor___ctor
};
pub enum AuditOpinionType {
    Qualified,
    Unqualified,
    Adverse,
    Disclaimer,
}
#[automatically_derived]
impl ::core::marker::Copy for AuditOpinionType {}
#[automatically_derived]
impl ::core::clone::Clone for AuditOpinionType {
    #[inline]
    fn clone(&self) -> AuditOpinionType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for AuditOpinionType {
    fn type_name() -> &'static str {
        "AuditOpinionType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AuditOpinionType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for AuditOpinionType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "AuditOpinionType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Qualified" => Ok(AuditOpinionType::Qualified),
            "Unqualified" => Ok(AuditOpinionType::Unqualified),
            "Adverse" => Ok(AuditOpinionType::Adverse),
            "Disclaimer" => Ok(AuditOpinionType::Disclaimer),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "AuditOpinionType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for AuditOpinionType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            AuditOpinionType::Qualified => "Qualified",
            AuditOpinionType::Unqualified => "Unqualified",
            AuditOpinionType::Adverse => "Adverse",
            AuditOpinionType::Disclaimer => "Disclaimer",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__AuditOpinionType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Qualified\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Qualified")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AuditOpinionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Unqualified\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Unqualified")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AuditOpinionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Adverse\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Adverse")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AuditOpinionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Disclaimer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Disclaimer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AuditOpinionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__AuditOpinionType_201() {
    napi::bindgen_prelude::register_module_export(
        None,
        "AuditOpinionType\0",
        __register__enum__AuditOpinionType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__AuditOpinionType_201___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__AuditOpinionType_201___rust_ctor___ctor() -> usize {
        __napi_register__AuditOpinionType_201();
        0
    }
    __napi_register__AuditOpinionType_201___rust_ctor___ctor
};
pub enum InventoryStorageType {
    Consignment,
    RetailStore,
    DistributionCenter,
    Warehouse,
    Other,
    DropShipper,
    OnlineMarketplace,
}
#[automatically_derived]
impl ::core::marker::Copy for InventoryStorageType {}
#[automatically_derived]
impl ::core::clone::Clone for InventoryStorageType {
    #[inline]
    fn clone(&self) -> InventoryStorageType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for InventoryStorageType {
    fn type_name() -> &'static str {
        "InventoryStorageType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for InventoryStorageType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for InventoryStorageType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "InventoryStorageType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Consignment" => Ok(InventoryStorageType::Consignment),
            "RetailStore" => Ok(InventoryStorageType::RetailStore),
            "DistributionCenter" => Ok(InventoryStorageType::DistributionCenter),
            "Warehouse" => Ok(InventoryStorageType::Warehouse),
            "Other" => Ok(InventoryStorageType::Other),
            "DropShipper" => Ok(InventoryStorageType::DropShipper),
            "OnlineMarketplace" => Ok(InventoryStorageType::OnlineMarketplace),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "InventoryStorageType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for InventoryStorageType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            InventoryStorageType::Consignment => "Consignment",
            InventoryStorageType::RetailStore => "RetailStore",
            InventoryStorageType::DistributionCenter => "DistributionCenter",
            InventoryStorageType::Warehouse => "Warehouse",
            InventoryStorageType::Other => "Other",
            InventoryStorageType::DropShipper => "DropShipper",
            InventoryStorageType::OnlineMarketplace => "OnlineMarketplace",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__InventoryStorageType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Consignment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Consignment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RetailStore\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RetailStore")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DistributionCenter\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "DistributionCenter",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Warehouse\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Warehouse")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "DropShipper\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "DropShipper")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OnlineMarketplace\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "OnlineMarketplace",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InventoryStorageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__InventoryStorageType_202() {
    napi::bindgen_prelude::register_module_export(
        None,
        "InventoryStorageType\0",
        __register__enum__InventoryStorageType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__InventoryStorageType_202___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__InventoryStorageType_202___rust_ctor___ctor() -> usize {
        __napi_register__InventoryStorageType_202();
        0
    }
    __napi_register__InventoryStorageType_202___rust_ctor___ctor
};
pub enum ProductAvailabilityStatus {
    InStock,
    BackOrder,
    OutOfStock,
    PreOrder,
    Discontinued,
}
#[automatically_derived]
impl ::core::marker::Copy for ProductAvailabilityStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ProductAvailabilityStatus {
    #[inline]
    fn clone(&self) -> ProductAvailabilityStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ProductAvailabilityStatus {
    fn type_name() -> &'static str {
        "ProductAvailabilityStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ProductAvailabilityStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ProductAvailabilityStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ProductAvailabilityStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "InStock" => Ok(ProductAvailabilityStatus::InStock),
            "BackOrder" => Ok(ProductAvailabilityStatus::BackOrder),
            "OutOfStock" => Ok(ProductAvailabilityStatus::OutOfStock),
            "PreOrder" => Ok(ProductAvailabilityStatus::PreOrder),
            "Discontinued" => Ok(ProductAvailabilityStatus::Discontinued),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ProductAvailabilityStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ProductAvailabilityStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ProductAvailabilityStatus::InStock => "InStock",
            ProductAvailabilityStatus::BackOrder => "BackOrder",
            ProductAvailabilityStatus::OutOfStock => "OutOfStock",
            ProductAvailabilityStatus::PreOrder => "PreOrder",
            ProductAvailabilityStatus::Discontinued => "Discontinued",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ProductAvailabilityStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("InStock\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InStock")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ProductAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BackOrder\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BackOrder")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ProductAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OutOfStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OutOfStock")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ProductAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PreOrder\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PreOrder")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ProductAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Discontinued\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Discontinued")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ProductAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ProductAvailabilityStatus_203() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ProductAvailabilityStatus\0",
        __register__enum__ProductAvailabilityStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ProductAvailabilityStatus_203___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ProductAvailabilityStatus_203___rust_ctor___ctor() -> usize {
        __napi_register__ProductAvailabilityStatus_203();
        0
    }
    __napi_register__ProductAvailabilityStatus_203___rust_ctor___ctor
};
pub enum ItemCondition {
    New,
    LikeNew,
    OpenBox,
    Refurbished,
    Damaged,
    Used,
}
#[automatically_derived]
impl ::core::marker::Copy for ItemCondition {}
#[automatically_derived]
impl ::core::clone::Clone for ItemCondition {
    #[inline]
    fn clone(&self) -> ItemCondition {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ItemCondition {
    fn type_name() -> &'static str {
        "ItemCondition"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ItemCondition {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ItemCondition {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ItemCondition",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "New" => Ok(ItemCondition::New),
            "LikeNew" => Ok(ItemCondition::LikeNew),
            "OpenBox" => Ok(ItemCondition::OpenBox),
            "Refurbished" => Ok(ItemCondition::Refurbished),
            "Damaged" => Ok(ItemCondition::Damaged),
            "Used" => Ok(ItemCondition::Used),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ItemCondition",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ItemCondition {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ItemCondition::New => "New",
            ItemCondition::LikeNew => "LikeNew",
            ItemCondition::OpenBox => "OpenBox",
            ItemCondition::Refurbished => "Refurbished",
            ItemCondition::Damaged => "Damaged",
            ItemCondition::Used => "Used",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ItemCondition_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("New\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "New")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemCondition\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LikeNew\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LikeNew")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemCondition\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("OpenBox\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OpenBox")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemCondition\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Refurbished\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Refurbished")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemCondition\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Damaged\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Damaged")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemCondition\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Used\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Used")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemCondition\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ItemCondition_204() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ItemCondition\0",
        __register__enum__ItemCondition_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ItemCondition_204___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ItemCondition_204___rust_ctor___ctor() -> usize {
        __napi_register__ItemCondition_204();
        0
    }
    __napi_register__ItemCondition_204___rust_ctor___ctor
};
pub enum ExpenseApprovalStatus {
    New,
    Approved,
    Pending,
    Processed,
    Reviewing,
    Reimbursed,
    Cancelled,
    Denied,
}
#[automatically_derived]
impl ::core::marker::Copy for ExpenseApprovalStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ExpenseApprovalStatus {
    #[inline]
    fn clone(&self) -> ExpenseApprovalStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ExpenseApprovalStatus {
    fn type_name() -> &'static str {
        "ExpenseApprovalStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ExpenseApprovalStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ExpenseApprovalStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ExpenseApprovalStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "New" => Ok(ExpenseApprovalStatus::New),
            "Approved" => Ok(ExpenseApprovalStatus::Approved),
            "Pending" => Ok(ExpenseApprovalStatus::Pending),
            "Processed" => Ok(ExpenseApprovalStatus::Processed),
            "Reviewing" => Ok(ExpenseApprovalStatus::Reviewing),
            "Reimbursed" => Ok(ExpenseApprovalStatus::Reimbursed),
            "Cancelled" => Ok(ExpenseApprovalStatus::Cancelled),
            "Denied" => Ok(ExpenseApprovalStatus::Denied),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ExpenseApprovalStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ExpenseApprovalStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ExpenseApprovalStatus::New => "New",
            ExpenseApprovalStatus::Approved => "Approved",
            ExpenseApprovalStatus::Pending => "Pending",
            ExpenseApprovalStatus::Processed => "Processed",
            ExpenseApprovalStatus::Reviewing => "Reviewing",
            ExpenseApprovalStatus::Reimbursed => "Reimbursed",
            ExpenseApprovalStatus::Cancelled => "Cancelled",
            ExpenseApprovalStatus::Denied => "Denied",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ExpenseApprovalStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("New\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "New")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Approved\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Approved")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Processed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Processed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Reviewing\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Reviewing")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Reimbursed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Reimbursed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Denied\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Denied")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ExpenseApprovalStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ExpenseApprovalStatus_205() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ExpenseApprovalStatus\0",
        __register__enum__ExpenseApprovalStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ExpenseApprovalStatus_205___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ExpenseApprovalStatus_205___rust_ctor___ctor() -> usize {
        __napi_register__ExpenseApprovalStatus_205();
        0
    }
    __napi_register__ExpenseApprovalStatus_205___rust_ctor___ctor
};
pub enum FinancialChargeType {
    Commission,
    Other,
    TransactionFee,
    ServiceCharge,
    LateFee,
    InterestCharge,
    ProcessingFee,
}
#[automatically_derived]
impl ::core::marker::Copy for FinancialChargeType {}
#[automatically_derived]
impl ::core::clone::Clone for FinancialChargeType {
    #[inline]
    fn clone(&self) -> FinancialChargeType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FinancialChargeType {
    fn type_name() -> &'static str {
        "FinancialChargeType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FinancialChargeType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FinancialChargeType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FinancialChargeType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Commission" => Ok(FinancialChargeType::Commission),
            "Other" => Ok(FinancialChargeType::Other),
            "TransactionFee" => Ok(FinancialChargeType::TransactionFee),
            "ServiceCharge" => Ok(FinancialChargeType::ServiceCharge),
            "LateFee" => Ok(FinancialChargeType::LateFee),
            "InterestCharge" => Ok(FinancialChargeType::InterestCharge),
            "ProcessingFee" => Ok(FinancialChargeType::ProcessingFee),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FinancialChargeType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FinancialChargeType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FinancialChargeType::Commission => "Commission",
            FinancialChargeType::Other => "Other",
            FinancialChargeType::TransactionFee => "TransactionFee",
            FinancialChargeType::ServiceCharge => "ServiceCharge",
            FinancialChargeType::LateFee => "LateFee",
            FinancialChargeType::InterestCharge => "InterestCharge",
            FinancialChargeType::ProcessingFee => "ProcessingFee",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FinancialChargeType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Commission\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Commission")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "TransactionFee\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "TransactionFee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ServiceCharge\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ServiceCharge")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("LateFee\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "LateFee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InterestCharge\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InterestCharge")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ProcessingFee\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ProcessingFee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialChargeType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FinancialChargeType_206() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FinancialChargeType\0",
        __register__enum__FinancialChargeType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FinancialChargeType_206___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FinancialChargeType_206___rust_ctor___ctor() -> usize {
        __napi_register__FinancialChargeType_206();
        0
    }
    __napi_register__FinancialChargeType_206___rust_ctor___ctor
};
pub enum ItemAvailabilityStatus {
    Active,
    Inactive,
    OutOfStock,
    Discontinued,
}
#[automatically_derived]
impl ::core::marker::Copy for ItemAvailabilityStatus {}
#[automatically_derived]
impl ::core::clone::Clone for ItemAvailabilityStatus {
    #[inline]
    fn clone(&self) -> ItemAvailabilityStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ItemAvailabilityStatus {
    fn type_name() -> &'static str {
        "ItemAvailabilityStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ItemAvailabilityStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ItemAvailabilityStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ItemAvailabilityStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Active" => Ok(ItemAvailabilityStatus::Active),
            "Inactive" => Ok(ItemAvailabilityStatus::Inactive),
            "OutOfStock" => Ok(ItemAvailabilityStatus::OutOfStock),
            "Discontinued" => Ok(ItemAvailabilityStatus::Discontinued),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ItemAvailabilityStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ItemAvailabilityStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ItemAvailabilityStatus::Active => "Active",
            ItemAvailabilityStatus::Inactive => "Inactive",
            ItemAvailabilityStatus::OutOfStock => "OutOfStock",
            ItemAvailabilityStatus::Discontinued => "Discontinued",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ItemAvailabilityStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "OutOfStock\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OutOfStock")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Discontinued\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Discontinued")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ItemAvailabilityStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ItemAvailabilityStatus_207() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ItemAvailabilityStatus\0",
        __register__enum__ItemAvailabilityStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ItemAvailabilityStatus_207___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ItemAvailabilityStatus_207___rust_ctor___ctor() -> usize {
        __napi_register__ItemAvailabilityStatus_207();
        0
    }
    __napi_register__ItemAvailabilityStatus_207___rust_ctor___ctor
};
pub enum FinancialAccountStatus {
    Inactive,
    Closed,
    UnderReview,
    Delinquent,
    Active,
    Frozen,
    Suspended,
}
#[automatically_derived]
impl ::core::marker::Copy for FinancialAccountStatus {}
#[automatically_derived]
impl ::core::clone::Clone for FinancialAccountStatus {
    #[inline]
    fn clone(&self) -> FinancialAccountStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FinancialAccountStatus {
    fn type_name() -> &'static str {
        "FinancialAccountStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FinancialAccountStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FinancialAccountStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FinancialAccountStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Inactive" => Ok(FinancialAccountStatus::Inactive),
            "Closed" => Ok(FinancialAccountStatus::Closed),
            "UnderReview" => Ok(FinancialAccountStatus::UnderReview),
            "Delinquent" => Ok(FinancialAccountStatus::Delinquent),
            "Active" => Ok(FinancialAccountStatus::Active),
            "Frozen" => Ok(FinancialAccountStatus::Frozen),
            "Suspended" => Ok(FinancialAccountStatus::Suspended),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FinancialAccountStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FinancialAccountStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FinancialAccountStatus::Inactive => "Inactive",
            FinancialAccountStatus::Closed => "Closed",
            FinancialAccountStatus::UnderReview => "UnderReview",
            FinancialAccountStatus::Delinquent => "Delinquent",
            FinancialAccountStatus::Active => "Active",
            FinancialAccountStatus::Frozen => "Frozen",
            FinancialAccountStatus::Suspended => "Suspended",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FinancialAccountStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Closed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Closed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "UnderReview\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UnderReview")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Delinquent\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Delinquent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Frozen\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Frozen")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suspended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suspended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialAccountStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FinancialAccountStatus_208() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FinancialAccountStatus\0",
        __register__enum__FinancialAccountStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FinancialAccountStatus_208___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FinancialAccountStatus_208___rust_ctor___ctor() -> usize {
        __napi_register__FinancialAccountStatus_208();
        0
    }
    __napi_register__FinancialAccountStatus_208___rust_ctor___ctor
};
pub enum TransactionStatus {
    Error,
    InProgress,
    Succeeded,
    Initiated,
    Failed,
    Cancelled,
    Pending,
}
#[automatically_derived]
impl ::core::marker::Copy for TransactionStatus {}
#[automatically_derived]
impl ::core::clone::Clone for TransactionStatus {
    #[inline]
    fn clone(&self) -> TransactionStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for TransactionStatus {
    fn type_name() -> &'static str {
        "TransactionStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TransactionStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for TransactionStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "TransactionStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Error" => Ok(TransactionStatus::Error),
            "InProgress" => Ok(TransactionStatus::InProgress),
            "Succeeded" => Ok(TransactionStatus::Succeeded),
            "Initiated" => Ok(TransactionStatus::Initiated),
            "Failed" => Ok(TransactionStatus::Failed),
            "Cancelled" => Ok(TransactionStatus::Cancelled),
            "Pending" => Ok(TransactionStatus::Pending),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "TransactionStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for TransactionStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            TransactionStatus::Error => "Error",
            TransactionStatus::InProgress => "InProgress",
            TransactionStatus::Succeeded => "Succeeded",
            TransactionStatus::Initiated => "Initiated",
            TransactionStatus::Failed => "Failed",
            TransactionStatus::Cancelled => "Cancelled",
            TransactionStatus::Pending => "Pending",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__TransactionStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Error\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Error")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InProgress\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InProgress")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Succeeded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Succeeded")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Initiated\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Initiated")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__TransactionStatus_209() {
    napi::bindgen_prelude::register_module_export(
        None,
        "TransactionStatus\0",
        __register__enum__TransactionStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__TransactionStatus_209___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__TransactionStatus_209___rust_ctor___ctor() -> usize {
        __napi_register__TransactionStatus_209();
        0
    }
    __napi_register__TransactionStatus_209___rust_ctor___ctor
};
pub enum BillingStatus {
    Paid,
    Unpaid,
    Overdue,
    PartiallyPaid,
    Pending,
}
#[automatically_derived]
impl ::core::marker::Copy for BillingStatus {}
#[automatically_derived]
impl ::core::clone::Clone for BillingStatus {
    #[inline]
    fn clone(&self) -> BillingStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for BillingStatus {
    fn type_name() -> &'static str {
        "BillingStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for BillingStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for BillingStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "BillingStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Paid" => Ok(BillingStatus::Paid),
            "Unpaid" => Ok(BillingStatus::Unpaid),
            "Overdue" => Ok(BillingStatus::Overdue),
            "PartiallyPaid" => Ok(BillingStatus::PartiallyPaid),
            "Pending" => Ok(BillingStatus::Pending),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "BillingStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for BillingStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            BillingStatus::Paid => "Paid",
            BillingStatus::Unpaid => "Unpaid",
            BillingStatus::Overdue => "Overdue",
            BillingStatus::PartiallyPaid => "PartiallyPaid",
            BillingStatus::Pending => "Pending",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__BillingStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Paid\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Paid")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "BillingStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Unpaid\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Unpaid")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "BillingStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Overdue\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Overdue")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "BillingStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PartiallyPaid\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PartiallyPaid")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "BillingStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "BillingStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__BillingStatus_210() {
    napi::bindgen_prelude::register_module_export(
        None,
        "BillingStatus\0",
        __register__enum__BillingStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__BillingStatus_210___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__BillingStatus_210___rust_ctor___ctor() -> usize {
        __napi_register__BillingStatus_210();
        0
    }
    __napi_register__BillingStatus_210___rust_ctor___ctor
};
pub enum TransactionType {
    Charge,
    Fee,
    Withdrawal,
    Adjustment,
    Deposit,
    Refund,
    Payment,
    Transfer,
}
#[automatically_derived]
impl ::core::marker::Copy for TransactionType {}
#[automatically_derived]
impl ::core::clone::Clone for TransactionType {
    #[inline]
    fn clone(&self) -> TransactionType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for TransactionType {
    fn type_name() -> &'static str {
        "TransactionType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TransactionType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for TransactionType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "TransactionType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Charge" => Ok(TransactionType::Charge),
            "Fee" => Ok(TransactionType::Fee),
            "Withdrawal" => Ok(TransactionType::Withdrawal),
            "Adjustment" => Ok(TransactionType::Adjustment),
            "Deposit" => Ok(TransactionType::Deposit),
            "Refund" => Ok(TransactionType::Refund),
            "Payment" => Ok(TransactionType::Payment),
            "Transfer" => Ok(TransactionType::Transfer),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "TransactionType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for TransactionType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            TransactionType::Charge => "Charge",
            TransactionType::Fee => "Fee",
            TransactionType::Withdrawal => "Withdrawal",
            TransactionType::Adjustment => "Adjustment",
            TransactionType::Deposit => "Deposit",
            TransactionType::Refund => "Refund",
            TransactionType::Payment => "Payment",
            TransactionType::Transfer => "Transfer",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__TransactionType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Charge\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Charge")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Fee\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Fee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Withdrawal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Withdrawal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Adjustment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Adjustment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Deposit\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Deposit")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Refund\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Refund")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Payment\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Payment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Transfer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Transfer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__TransactionType_211() {
    napi::bindgen_prelude::register_module_export(
        None,
        "TransactionType\0",
        __register__enum__TransactionType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__TransactionType_211___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__TransactionType_211___rust_ctor___ctor() -> usize {
        __napi_register__TransactionType_211();
        0
    }
    __napi_register__TransactionType_211___rust_ctor___ctor
};
pub enum VisibilityScope {
    App,
    Private,
    Global,
    Web,
    Internal,
}
#[automatically_derived]
impl ::core::marker::Copy for VisibilityScope {}
#[automatically_derived]
impl ::core::clone::Clone for VisibilityScope {
    #[inline]
    fn clone(&self) -> VisibilityScope {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for VisibilityScope {
    fn type_name() -> &'static str {
        "VisibilityScope"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for VisibilityScope {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for VisibilityScope {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "VisibilityScope",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "App" => Ok(VisibilityScope::App),
            "Private" => Ok(VisibilityScope::Private),
            "Global" => Ok(VisibilityScope::Global),
            "Web" => Ok(VisibilityScope::Web),
            "Internal" => Ok(VisibilityScope::Internal),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "VisibilityScope",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for VisibilityScope {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            VisibilityScope::App => "App",
            VisibilityScope::Private => "Private",
            VisibilityScope::Global => "Global",
            VisibilityScope::Web => "Web",
            VisibilityScope::Internal => "Internal",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__VisibilityScope_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("App\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "App")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "VisibilityScope\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Private\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Private")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "VisibilityScope\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Global\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Global")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "VisibilityScope\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Web\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Web")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "VisibilityScope\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Internal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Internal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "VisibilityScope\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__VisibilityScope_212() {
    napi::bindgen_prelude::register_module_export(
        None,
        "VisibilityScope\0",
        __register__enum__VisibilityScope_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__VisibilityScope_212___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__VisibilityScope_212___rust_ctor___ctor() -> usize {
        __napi_register__VisibilityScope_212();
        0
    }
    __napi_register__VisibilityScope_212___rust_ctor___ctor
};
pub enum PaymentStatus {
    Overdue,
    Cancelled,
    Adjusted,
    PartiallyRefunded,
    Pending,
    Error,
    Processing,
    Succeeded,
    Failed,
    Disputed,
    Draft,
    Partial,
    Refunded,
}
#[automatically_derived]
impl ::core::marker::Copy for PaymentStatus {}
#[automatically_derived]
impl ::core::clone::Clone for PaymentStatus {
    #[inline]
    fn clone(&self) -> PaymentStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for PaymentStatus {
    fn type_name() -> &'static str {
        "PaymentStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PaymentStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for PaymentStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "PaymentStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Overdue" => Ok(PaymentStatus::Overdue),
            "Cancelled" => Ok(PaymentStatus::Cancelled),
            "Adjusted" => Ok(PaymentStatus::Adjusted),
            "PartiallyRefunded" => Ok(PaymentStatus::PartiallyRefunded),
            "Pending" => Ok(PaymentStatus::Pending),
            "Error" => Ok(PaymentStatus::Error),
            "Processing" => Ok(PaymentStatus::Processing),
            "Succeeded" => Ok(PaymentStatus::Succeeded),
            "Failed" => Ok(PaymentStatus::Failed),
            "Disputed" => Ok(PaymentStatus::Disputed),
            "Draft" => Ok(PaymentStatus::Draft),
            "Partial" => Ok(PaymentStatus::Partial),
            "Refunded" => Ok(PaymentStatus::Refunded),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "PaymentStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for PaymentStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            PaymentStatus::Overdue => "Overdue",
            PaymentStatus::Cancelled => "Cancelled",
            PaymentStatus::Adjusted => "Adjusted",
            PaymentStatus::PartiallyRefunded => "PartiallyRefunded",
            PaymentStatus::Pending => "Pending",
            PaymentStatus::Error => "Error",
            PaymentStatus::Processing => "Processing",
            PaymentStatus::Succeeded => "Succeeded",
            PaymentStatus::Failed => "Failed",
            PaymentStatus::Disputed => "Disputed",
            PaymentStatus::Draft => "Draft",
            PaymentStatus::Partial => "Partial",
            PaymentStatus::Refunded => "Refunded",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__PaymentStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Overdue\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Overdue")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Adjusted\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Adjusted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PartiallyRefunded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "PartiallyRefunded",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Error\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Error")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Processing\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Processing")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Succeeded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Succeeded")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Failed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Failed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Disputed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Disputed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Draft\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Draft")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Partial\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Partial")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Refunded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Refunded")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PaymentStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__PaymentStatus_213() {
    napi::bindgen_prelude::register_module_export(
        None,
        "PaymentStatus\0",
        __register__enum__PaymentStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__PaymentStatus_213___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__PaymentStatus_213___rust_ctor___ctor() -> usize {
        __napi_register__PaymentStatus_213();
        0
    }
    __napi_register__PaymentStatus_213___rust_ctor___ctor
};
pub enum InvoiceAdjustmentType {
    Shipping,
    Discount,
    Tip,
    Other,
    Tax,
}
#[automatically_derived]
impl ::core::marker::Copy for InvoiceAdjustmentType {}
#[automatically_derived]
impl ::core::clone::Clone for InvoiceAdjustmentType {
    #[inline]
    fn clone(&self) -> InvoiceAdjustmentType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for InvoiceAdjustmentType {
    fn type_name() -> &'static str {
        "InvoiceAdjustmentType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for InvoiceAdjustmentType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for InvoiceAdjustmentType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "InvoiceAdjustmentType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Shipping" => Ok(InvoiceAdjustmentType::Shipping),
            "Discount" => Ok(InvoiceAdjustmentType::Discount),
            "Tip" => Ok(InvoiceAdjustmentType::Tip),
            "Other" => Ok(InvoiceAdjustmentType::Other),
            "Tax" => Ok(InvoiceAdjustmentType::Tax),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "InvoiceAdjustmentType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for InvoiceAdjustmentType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            InvoiceAdjustmentType::Shipping => "Shipping",
            InvoiceAdjustmentType::Discount => "Discount",
            InvoiceAdjustmentType::Tip => "Tip",
            InvoiceAdjustmentType::Other => "Other",
            InvoiceAdjustmentType::Tax => "Tax",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__InvoiceAdjustmentType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Shipping\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Shipping")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InvoiceAdjustmentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Discount\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Discount")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InvoiceAdjustmentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tip\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tip")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InvoiceAdjustmentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InvoiceAdjustmentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Tax\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Tax")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "InvoiceAdjustmentType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__InvoiceAdjustmentType_214() {
    napi::bindgen_prelude::register_module_export(
        None,
        "InvoiceAdjustmentType\0",
        __register__enum__InvoiceAdjustmentType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__InvoiceAdjustmentType_214___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__InvoiceAdjustmentType_214___rust_ctor___ctor() -> usize {
        __napi_register__InvoiceAdjustmentType_214();
        0
    }
    __napi_register__InvoiceAdjustmentType_214___rust_ctor___ctor
};
pub enum DataType {
    Object,
    Binary,
    Number,
    Boolean,
    String,
    Date,
    Json,
    Null,
    Undefined,
    Array,
}
#[automatically_derived]
impl ::core::marker::Copy for DataType {}
#[automatically_derived]
impl ::core::clone::Clone for DataType {
    #[inline]
    fn clone(&self) -> DataType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for DataType {
    fn type_name() -> &'static str {
        "DataType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for DataType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for DataType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "DataType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Object" => Ok(DataType::Object),
            "Binary" => Ok(DataType::Binary),
            "Number" => Ok(DataType::Number),
            "Boolean" => Ok(DataType::Boolean),
            "String" => Ok(DataType::String),
            "Date" => Ok(DataType::Date),
            "Json" => Ok(DataType::Json),
            "Null" => Ok(DataType::Null),
            "Undefined" => Ok(DataType::Undefined),
            "Array" => Ok(DataType::Array),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "DataType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for DataType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            DataType::Object => "Object",
            DataType::Binary => "Binary",
            DataType::Number => "Number",
            DataType::Boolean => "Boolean",
            DataType::String => "String",
            DataType::Date => "Date",
            DataType::Json => "Json",
            DataType::Null => "Null",
            DataType::Undefined => "Undefined",
            DataType::Array => "Array",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__DataType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Object\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Object")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Binary\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Binary")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Number\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Number")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Boolean\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Boolean")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("String\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "String")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Date\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Date")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Json\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Json")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Null\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Null")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Undefined\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Undefined")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Array\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Array")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "DataType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__DataType_215() {
    napi::bindgen_prelude::register_module_export(
        None,
        "DataType\0",
        __register__enum__DataType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__DataType_215___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__DataType_215___rust_ctor___ctor() -> usize {
        __napi_register__DataType_215();
        0
    }
    __napi_register__DataType_215___rust_ctor___ctor
};
pub enum EntityLifecycleStatus {
    Inactive,
    Preorder,
    Scheduled,
    Active,
    Draft,
    Deleted,
    Archived,
}
#[automatically_derived]
impl ::core::marker::Copy for EntityLifecycleStatus {}
#[automatically_derived]
impl ::core::clone::Clone for EntityLifecycleStatus {
    #[inline]
    fn clone(&self) -> EntityLifecycleStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for EntityLifecycleStatus {
    fn type_name() -> &'static str {
        "EntityLifecycleStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for EntityLifecycleStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for EntityLifecycleStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "EntityLifecycleStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Inactive" => Ok(EntityLifecycleStatus::Inactive),
            "Preorder" => Ok(EntityLifecycleStatus::Preorder),
            "Scheduled" => Ok(EntityLifecycleStatus::Scheduled),
            "Active" => Ok(EntityLifecycleStatus::Active),
            "Draft" => Ok(EntityLifecycleStatus::Draft),
            "Deleted" => Ok(EntityLifecycleStatus::Deleted),
            "Archived" => Ok(EntityLifecycleStatus::Archived),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "EntityLifecycleStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for EntityLifecycleStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            EntityLifecycleStatus::Inactive => "Inactive",
            EntityLifecycleStatus::Preorder => "Preorder",
            EntityLifecycleStatus::Scheduled => "Scheduled",
            EntityLifecycleStatus::Active => "Active",
            EntityLifecycleStatus::Draft => "Draft",
            EntityLifecycleStatus::Deleted => "Deleted",
            EntityLifecycleStatus::Archived => "Archived",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__EntityLifecycleStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Preorder\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Preorder")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Scheduled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Scheduled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Draft\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Draft")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Deleted\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Deleted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Archived\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Archived")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityLifecycleStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__EntityLifecycleStatus_216() {
    napi::bindgen_prelude::register_module_export(
        None,
        "EntityLifecycleStatus\0",
        __register__enum__EntityLifecycleStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__EntityLifecycleStatus_216___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__EntityLifecycleStatus_216___rust_ctor___ctor() -> usize {
        __napi_register__EntityLifecycleStatus_216();
        0
    }
    __napi_register__EntityLifecycleStatus_216___rust_ctor___ctor
};
pub enum TransactionChannel {
    Telephone,
    Other,
    BankBranch,
    Mail,
    InPerson,
    Online,
    Mobile,
    Atm,
}
#[automatically_derived]
impl ::core::marker::Copy for TransactionChannel {}
#[automatically_derived]
impl ::core::clone::Clone for TransactionChannel {
    #[inline]
    fn clone(&self) -> TransactionChannel {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for TransactionChannel {
    fn type_name() -> &'static str {
        "TransactionChannel"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TransactionChannel {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for TransactionChannel {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "TransactionChannel",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Telephone" => Ok(TransactionChannel::Telephone),
            "Other" => Ok(TransactionChannel::Other),
            "BankBranch" => Ok(TransactionChannel::BankBranch),
            "Mail" => Ok(TransactionChannel::Mail),
            "InPerson" => Ok(TransactionChannel::InPerson),
            "Online" => Ok(TransactionChannel::Online),
            "Mobile" => Ok(TransactionChannel::Mobile),
            "Atm" => Ok(TransactionChannel::Atm),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "TransactionChannel",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for TransactionChannel {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            TransactionChannel::Telephone => "Telephone",
            TransactionChannel::Other => "Other",
            TransactionChannel::BankBranch => "BankBranch",
            TransactionChannel::Mail => "Mail",
            TransactionChannel::InPerson => "InPerson",
            TransactionChannel::Online => "Online",
            TransactionChannel::Mobile => "Mobile",
            TransactionChannel::Atm => "Atm",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__TransactionChannel_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Telephone\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Telephone")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BankBranch\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BankBranch")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mail\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mail")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InPerson\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InPerson")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Online\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Online")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mobile\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mobile")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Atm\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Atm")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "TransactionChannel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__TransactionChannel_217() {
    napi::bindgen_prelude::register_module_export(
        None,
        "TransactionChannel\0",
        __register__enum__TransactionChannel_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__TransactionChannel_217___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__TransactionChannel_217___rust_ctor___ctor() -> usize {
        __napi_register__TransactionChannel_217();
        0
    }
    __napi_register__TransactionChannel_217___rust_ctor___ctor
};
pub enum FinancialDisputeStatus {
    Lost,
    Closed,
    AwaitingEvidence,
    NeedsResponse,
    UnderReview,
    ChargeRefunded,
    Escalated,
    Won,
}
#[automatically_derived]
impl ::core::marker::Copy for FinancialDisputeStatus {}
#[automatically_derived]
impl ::core::clone::Clone for FinancialDisputeStatus {
    #[inline]
    fn clone(&self) -> FinancialDisputeStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FinancialDisputeStatus {
    fn type_name() -> &'static str {
        "FinancialDisputeStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FinancialDisputeStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FinancialDisputeStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FinancialDisputeStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Lost" => Ok(FinancialDisputeStatus::Lost),
            "Closed" => Ok(FinancialDisputeStatus::Closed),
            "AwaitingEvidence" => Ok(FinancialDisputeStatus::AwaitingEvidence),
            "NeedsResponse" => Ok(FinancialDisputeStatus::NeedsResponse),
            "UnderReview" => Ok(FinancialDisputeStatus::UnderReview),
            "ChargeRefunded" => Ok(FinancialDisputeStatus::ChargeRefunded),
            "Escalated" => Ok(FinancialDisputeStatus::Escalated),
            "Won" => Ok(FinancialDisputeStatus::Won),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FinancialDisputeStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FinancialDisputeStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FinancialDisputeStatus::Lost => "Lost",
            FinancialDisputeStatus::Closed => "Closed",
            FinancialDisputeStatus::AwaitingEvidence => "AwaitingEvidence",
            FinancialDisputeStatus::NeedsResponse => "NeedsResponse",
            FinancialDisputeStatus::UnderReview => "UnderReview",
            FinancialDisputeStatus::ChargeRefunded => "ChargeRefunded",
            FinancialDisputeStatus::Escalated => "Escalated",
            FinancialDisputeStatus::Won => "Won",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FinancialDisputeStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Lost\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Lost")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Closed\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Closed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "AwaitingEvidence\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "AwaitingEvidence",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "NeedsResponse\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "NeedsResponse")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "UnderReview\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "UnderReview")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ChargeRefunded\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ChargeRefunded")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Escalated\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Escalated")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Won\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Won")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialDisputeStatus\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FinancialDisputeStatus_218() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FinancialDisputeStatus\0",
        __register__enum__FinancialDisputeStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FinancialDisputeStatus_218___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FinancialDisputeStatus_218___rust_ctor___ctor() -> usize {
        __napi_register__FinancialDisputeStatus_218();
        0
    }
    __napi_register__FinancialDisputeStatus_218___rust_ctor___ctor
};
pub enum ContentVisibility {
    Protected,
    Internal,
    Public,
    Shared,
    Private,
}
#[automatically_derived]
impl ::core::marker::Copy for ContentVisibility {}
#[automatically_derived]
impl ::core::clone::Clone for ContentVisibility {
    #[inline]
    fn clone(&self) -> ContentVisibility {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ContentVisibility {
    fn type_name() -> &'static str {
        "ContentVisibility"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ContentVisibility {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ContentVisibility {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ContentVisibility",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Protected" => Ok(ContentVisibility::Protected),
            "Internal" => Ok(ContentVisibility::Internal),
            "Public" => Ok(ContentVisibility::Public),
            "Shared" => Ok(ContentVisibility::Shared),
            "Private" => Ok(ContentVisibility::Private),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ContentVisibility",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ContentVisibility {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ContentVisibility::Protected => "Protected",
            ContentVisibility::Internal => "Internal",
            ContentVisibility::Public => "Public",
            ContentVisibility::Shared => "Shared",
            ContentVisibility::Private => "Private",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ContentVisibility_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Protected\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Protected")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContentVisibility\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Internal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Internal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContentVisibility\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Public\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Public")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContentVisibility\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Shared\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Shared")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContentVisibility\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Private\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Private")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ContentVisibility\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ContentVisibility_219() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ContentVisibility\0",
        __register__enum__ContentVisibility_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ContentVisibility_219___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ContentVisibility_219___rust_ctor___ctor() -> usize {
        __napi_register__ContentVisibility_219();
        0
    }
    __napi_register__ContentVisibility_219___rust_ctor___ctor
};
pub enum EmailCategoryType {
    Personal,
    Governmental,
    Other,
    Business,
    Transactional,
    Spam,
    Educational,
    Promotional,
}
#[automatically_derived]
impl ::core::marker::Copy for EmailCategoryType {}
#[automatically_derived]
impl ::core::clone::Clone for EmailCategoryType {
    #[inline]
    fn clone(&self) -> EmailCategoryType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for EmailCategoryType {
    fn type_name() -> &'static str {
        "EmailCategoryType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for EmailCategoryType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for EmailCategoryType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "EmailCategoryType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Personal" => Ok(EmailCategoryType::Personal),
            "Governmental" => Ok(EmailCategoryType::Governmental),
            "Other" => Ok(EmailCategoryType::Other),
            "Business" => Ok(EmailCategoryType::Business),
            "Transactional" => Ok(EmailCategoryType::Transactional),
            "Spam" => Ok(EmailCategoryType::Spam),
            "Educational" => Ok(EmailCategoryType::Educational),
            "Promotional" => Ok(EmailCategoryType::Promotional),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "EmailCategoryType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for EmailCategoryType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            EmailCategoryType::Personal => "Personal",
            EmailCategoryType::Governmental => "Governmental",
            EmailCategoryType::Other => "Other",
            EmailCategoryType::Business => "Business",
            EmailCategoryType::Transactional => "Transactional",
            EmailCategoryType::Spam => "Spam",
            EmailCategoryType::Educational => "Educational",
            EmailCategoryType::Promotional => "Promotional",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__EmailCategoryType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Personal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Personal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Governmental\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Governmental")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Business\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Business")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Transactional\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Transactional")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Spam\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Spam")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Educational\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Educational")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Promotional\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Promotional")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EmailCategoryType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__EmailCategoryType_220() {
    napi::bindgen_prelude::register_module_export(
        None,
        "EmailCategoryType\0",
        __register__enum__EmailCategoryType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__EmailCategoryType_220___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__EmailCategoryType_220___rust_ctor___ctor() -> usize {
        __napi_register__EmailCategoryType_220();
        0
    }
    __napi_register__EmailCategoryType_220___rust_ctor___ctor
};
pub enum DeviceUsageType {
    Personal,
    Industrial,
    Educational,
    Other,
    Healthcare,
    Business,
}
#[automatically_derived]
impl ::core::marker::Copy for DeviceUsageType {}
#[automatically_derived]
impl ::core::clone::Clone for DeviceUsageType {
    #[inline]
    fn clone(&self) -> DeviceUsageType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for DeviceUsageType {
    fn type_name() -> &'static str {
        "DeviceUsageType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for DeviceUsageType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for DeviceUsageType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "DeviceUsageType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Personal" => Ok(DeviceUsageType::Personal),
            "Industrial" => Ok(DeviceUsageType::Industrial),
            "Educational" => Ok(DeviceUsageType::Educational),
            "Other" => Ok(DeviceUsageType::Other),
            "Healthcare" => Ok(DeviceUsageType::Healthcare),
            "Business" => Ok(DeviceUsageType::Business),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "DeviceUsageType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for DeviceUsageType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            DeviceUsageType::Personal => "Personal",
            DeviceUsageType::Industrial => "Industrial",
            DeviceUsageType::Educational => "Educational",
            DeviceUsageType::Other => "Other",
            DeviceUsageType::Healthcare => "Healthcare",
            DeviceUsageType::Business => "Business",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__DeviceUsageType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Personal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Personal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DeviceUsageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Industrial\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Industrial")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DeviceUsageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Educational\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Educational")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DeviceUsageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DeviceUsageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Healthcare\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Healthcare")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DeviceUsageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Business\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Business")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "DeviceUsageType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__DeviceUsageType_221() {
    napi::bindgen_prelude::register_module_export(
        None,
        "DeviceUsageType\0",
        __register__enum__DeviceUsageType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__DeviceUsageType_221___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__DeviceUsageType_221___rust_ctor___ctor() -> usize {
        __napi_register__DeviceUsageType_221();
        0
    }
    __napi_register__DeviceUsageType_221___rust_ctor___ctor
};
pub enum UniversalIdentifierType {
    Number,
    Email,
    Url,
    String,
    Uuid,
}
#[automatically_derived]
impl ::core::marker::Copy for UniversalIdentifierType {}
#[automatically_derived]
impl ::core::clone::Clone for UniversalIdentifierType {
    #[inline]
    fn clone(&self) -> UniversalIdentifierType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for UniversalIdentifierType {
    fn type_name() -> &'static str {
        "UniversalIdentifierType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for UniversalIdentifierType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for UniversalIdentifierType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "UniversalIdentifierType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Number" => Ok(UniversalIdentifierType::Number),
            "Email" => Ok(UniversalIdentifierType::Email),
            "Url" => Ok(UniversalIdentifierType::Url),
            "String" => Ok(UniversalIdentifierType::String),
            "Uuid" => Ok(UniversalIdentifierType::Uuid),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "UniversalIdentifierType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for UniversalIdentifierType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            UniversalIdentifierType::Number => "Number",
            UniversalIdentifierType::Email => "Email",
            UniversalIdentifierType::Url => "Url",
            UniversalIdentifierType::String => "String",
            UniversalIdentifierType::Uuid => "Uuid",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__UniversalIdentifierType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Number\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Number")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "UniversalIdentifierType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Email\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Email")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "UniversalIdentifierType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Url\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Url")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "UniversalIdentifierType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("String\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "String")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "UniversalIdentifierType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Uuid\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Uuid")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "UniversalIdentifierType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__UniversalIdentifierType_222() {
    napi::bindgen_prelude::register_module_export(
        None,
        "UniversalIdentifierType\0",
        __register__enum__UniversalIdentifierType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__UniversalIdentifierType_222___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__UniversalIdentifierType_222___rust_ctor___ctor() -> usize {
        __napi_register__UniversalIdentifierType_222();
        0
    }
    __napi_register__UniversalIdentifierType_222___rust_ctor___ctor
};
pub enum EntityCategory {
    Person,
    User,
    Other,
    Message,
    Document,
    Task,
    Event,
    Project,
}
#[automatically_derived]
impl ::core::marker::Copy for EntityCategory {}
#[automatically_derived]
impl ::core::clone::Clone for EntityCategory {
    #[inline]
    fn clone(&self) -> EntityCategory {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for EntityCategory {
    fn type_name() -> &'static str {
        "EntityCategory"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for EntityCategory {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for EntityCategory {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "EntityCategory",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Person" => Ok(EntityCategory::Person),
            "User" => Ok(EntityCategory::User),
            "Other" => Ok(EntityCategory::Other),
            "Message" => Ok(EntityCategory::Message),
            "Document" => Ok(EntityCategory::Document),
            "Task" => Ok(EntityCategory::Task),
            "Event" => Ok(EntityCategory::Event),
            "Project" => Ok(EntityCategory::Project),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "EntityCategory",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for EntityCategory {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            EntityCategory::Person => "Person",
            EntityCategory::User => "User",
            EntityCategory::Other => "Other",
            EntityCategory::Message => "Message",
            EntityCategory::Document => "Document",
            EntityCategory::Task => "Task",
            EntityCategory::Event => "Event",
            EntityCategory::Project => "Project",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__EntityCategory_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Person\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Person")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("User\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "User")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Message\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Message")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Document\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Document")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Task\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Task")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Event\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Event")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Project\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Project")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "EntityCategory\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__EntityCategory_223() {
    napi::bindgen_prelude::register_module_export(
        None,
        "EntityCategory\0",
        __register__enum__EntityCategory_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__EntityCategory_223___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__EntityCategory_223___rust_ctor___ctor() -> usize {
        __napi_register__EntityCategory_223();
        0
    }
    __napi_register__EntityCategory_223___rust_ctor___ctor
};
pub enum AccessControlModel {
    Custom,
    Rbac,
    Mac,
    Abac,
    Dac,
    None,
}
#[automatically_derived]
impl ::core::marker::Copy for AccessControlModel {}
#[automatically_derived]
impl ::core::clone::Clone for AccessControlModel {
    #[inline]
    fn clone(&self) -> AccessControlModel {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for AccessControlModel {
    fn type_name() -> &'static str {
        "AccessControlModel"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for AccessControlModel {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for AccessControlModel {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "AccessControlModel",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Custom" => Ok(AccessControlModel::Custom),
            "Rbac" => Ok(AccessControlModel::Rbac),
            "Mac" => Ok(AccessControlModel::Mac),
            "Abac" => Ok(AccessControlModel::Abac),
            "Dac" => Ok(AccessControlModel::Dac),
            "None" => Ok(AccessControlModel::None),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "AccessControlModel",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for AccessControlModel {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            AccessControlModel::Custom => "Custom",
            AccessControlModel::Rbac => "Rbac",
            AccessControlModel::Mac => "Mac",
            AccessControlModel::Abac => "Abac",
            AccessControlModel::Dac => "Dac",
            AccessControlModel::None => "None",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__AccessControlModel_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Custom\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Custom")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccessControlModel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Rbac\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Rbac")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccessControlModel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mac\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mac")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccessControlModel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Abac\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Abac")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccessControlModel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Dac\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Dac")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccessControlModel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("None\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "None")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "AccessControlModel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__AccessControlModel_224() {
    napi::bindgen_prelude::register_module_export(
        None,
        "AccessControlModel\0",
        __register__enum__AccessControlModel_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__AccessControlModel_224___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__AccessControlModel_224___rust_ctor___ctor() -> usize {
        __napi_register__AccessControlModel_224();
        0
    }
    __napi_register__AccessControlModel_224___rust_ctor___ctor
};
pub enum ParticipantType {
    Group,
    ExternalParticipant,
    User,
    Organization,
    Team,
}
#[automatically_derived]
impl ::core::marker::Copy for ParticipantType {}
#[automatically_derived]
impl ::core::clone::Clone for ParticipantType {
    #[inline]
    fn clone(&self) -> ParticipantType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for ParticipantType {
    fn type_name() -> &'static str {
        "ParticipantType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for ParticipantType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for ParticipantType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "ParticipantType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Group" => Ok(ParticipantType::Group),
            "ExternalParticipant" => Ok(ParticipantType::ExternalParticipant),
            "User" => Ok(ParticipantType::User),
            "Organization" => Ok(ParticipantType::Organization),
            "Team" => Ok(ParticipantType::Team),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "ParticipantType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for ParticipantType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            ParticipantType::Group => "Group",
            ParticipantType::ExternalParticipant => "ExternalParticipant",
            ParticipantType::User => "User",
            ParticipantType::Organization => "Organization",
            ParticipantType::Team => "Team",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__ParticipantType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Group\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Group")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ExternalParticipant\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "ExternalParticipant",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("User\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "User")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Organization\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Organization")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Team\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Team")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "ParticipantType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__ParticipantType_225() {
    napi::bindgen_prelude::register_module_export(
        None,
        "ParticipantType\0",
        __register__enum__ParticipantType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__ParticipantType_225___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__ParticipantType_225___rust_ctor___ctor() -> usize {
        __napi_register__ParticipantType_225();
        0
    }
    __napi_register__ParticipantType_225___rust_ctor___ctor
};
pub enum PriorityLevel {
    Low,
    Urgent,
    Medium,
    High,
    Elevated,
}
#[automatically_derived]
impl ::core::marker::Copy for PriorityLevel {}
#[automatically_derived]
impl ::core::clone::Clone for PriorityLevel {
    #[inline]
    fn clone(&self) -> PriorityLevel {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for PriorityLevel {
    fn type_name() -> &'static str {
        "PriorityLevel"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PriorityLevel {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for PriorityLevel {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "PriorityLevel",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Low" => Ok(PriorityLevel::Low),
            "Urgent" => Ok(PriorityLevel::Urgent),
            "Medium" => Ok(PriorityLevel::Medium),
            "High" => Ok(PriorityLevel::High),
            "Elevated" => Ok(PriorityLevel::Elevated),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "PriorityLevel",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for PriorityLevel {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            PriorityLevel::Low => "Low",
            PriorityLevel::Urgent => "Urgent",
            PriorityLevel::Medium => "Medium",
            PriorityLevel::High => "High",
            PriorityLevel::Elevated => "Elevated",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__PriorityLevel_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Low\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Low")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PriorityLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Urgent\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Urgent")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PriorityLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Medium\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Medium")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PriorityLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("High\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "High")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PriorityLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Elevated\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Elevated")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PriorityLevel\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__PriorityLevel_226() {
    napi::bindgen_prelude::register_module_export(
        None,
        "PriorityLevel\0",
        __register__enum__PriorityLevel_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__PriorityLevel_226___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__PriorityLevel_226___rust_ctor___ctor() -> usize {
        __napi_register__PriorityLevel_226();
        0
    }
    __napi_register__PriorityLevel_226___rust_ctor___ctor
};
pub enum TaskStatus {
    OnHold,
    Cancelled,
    Todo,
    InProgress,
    Blocked,
    Done,
}
#[automatically_derived]
impl ::core::marker::Copy for TaskStatus {}
#[automatically_derived]
impl ::core::clone::Clone for TaskStatus {
    #[inline]
    fn clone(&self) -> TaskStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for TaskStatus {
    fn type_name() -> &'static str {
        "TaskStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for TaskStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for TaskStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "TaskStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "OnHold" => Ok(TaskStatus::OnHold),
            "Cancelled" => Ok(TaskStatus::Cancelled),
            "Todo" => Ok(TaskStatus::Todo),
            "InProgress" => Ok(TaskStatus::InProgress),
            "Blocked" => Ok(TaskStatus::Blocked),
            "Done" => Ok(TaskStatus::Done),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "TaskStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for TaskStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            TaskStatus::OnHold => "OnHold",
            TaskStatus::Cancelled => "Cancelled",
            TaskStatus::Todo => "Todo",
            TaskStatus::InProgress => "InProgress",
            TaskStatus::Blocked => "Blocked",
            TaskStatus::Done => "Done",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__TaskStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("OnHold\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "OnHold")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TaskStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Cancelled\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Cancelled")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TaskStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Todo\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Todo")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TaskStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InProgress\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InProgress")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TaskStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Blocked\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Blocked")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TaskStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Done\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Done")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "TaskStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__TaskStatus_227() {
    napi::bindgen_prelude::register_module_export(
        None,
        "TaskStatus\0",
        __register__enum__TaskStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__TaskStatus_227___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__TaskStatus_227___rust_ctor___ctor() -> usize {
        __napi_register__TaskStatus_227();
        0
    }
    __napi_register__TaskStatus_227___rust_ctor___ctor
};
pub enum GenderIdentity {
    Male,
    PreferNotToSay,
    Female,
    Other,
}
#[automatically_derived]
impl ::core::marker::Copy for GenderIdentity {}
#[automatically_derived]
impl ::core::clone::Clone for GenderIdentity {
    #[inline]
    fn clone(&self) -> GenderIdentity {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for GenderIdentity {
    fn type_name() -> &'static str {
        "GenderIdentity"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for GenderIdentity {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for GenderIdentity {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "GenderIdentity",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Male" => Ok(GenderIdentity::Male),
            "PreferNotToSay" => Ok(GenderIdentity::PreferNotToSay),
            "Female" => Ok(GenderIdentity::Female),
            "Other" => Ok(GenderIdentity::Other),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "GenderIdentity",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for GenderIdentity {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            GenderIdentity::Male => "Male",
            GenderIdentity::PreferNotToSay => "PreferNotToSay",
            GenderIdentity::Female => "Female",
            GenderIdentity::Other => "Other",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__GenderIdentity_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Male\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Male")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GenderIdentity\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PreferNotToSay\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "PreferNotToSay")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GenderIdentity\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Female\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Female")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GenderIdentity\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "GenderIdentity\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__GenderIdentity_228() {
    napi::bindgen_prelude::register_module_export(
        None,
        "GenderIdentity\0",
        __register__enum__GenderIdentity_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__GenderIdentity_228___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__GenderIdentity_228___rust_ctor___ctor() -> usize {
        __napi_register__GenderIdentity_228();
        0
    }
    __napi_register__GenderIdentity_228___rust_ctor___ctor
};
pub enum UserStatus {
    Inactive,
    Suspended,
    Banned,
    Deleted,
    Archived,
    Pending,
    Verified,
    Active,
    WaitListed,
}
#[automatically_derived]
impl ::core::marker::Copy for UserStatus {}
#[automatically_derived]
impl ::core::clone::Clone for UserStatus {
    #[inline]
    fn clone(&self) -> UserStatus {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for UserStatus {
    fn type_name() -> &'static str {
        "UserStatus"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for UserStatus {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for UserStatus {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "UserStatus",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Inactive" => Ok(UserStatus::Inactive),
            "Suspended" => Ok(UserStatus::Suspended),
            "Banned" => Ok(UserStatus::Banned),
            "Deleted" => Ok(UserStatus::Deleted),
            "Archived" => Ok(UserStatus::Archived),
            "Pending" => Ok(UserStatus::Pending),
            "Verified" => Ok(UserStatus::Verified),
            "Active" => Ok(UserStatus::Active),
            "WaitListed" => Ok(UserStatus::WaitListed),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "UserStatus",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for UserStatus {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            UserStatus::Inactive => "Inactive",
            UserStatus::Suspended => "Suspended",
            UserStatus::Banned => "Banned",
            UserStatus::Deleted => "Deleted",
            UserStatus::Archived => "Archived",
            UserStatus::Pending => "Pending",
            UserStatus::Verified => "Verified",
            UserStatus::Active => "Active",
            UserStatus::WaitListed => "WaitListed",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__UserStatus_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Inactive\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Inactive")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Suspended\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Suspended")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Banned\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Banned")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Deleted\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Deleted")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Archived\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Archived")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Pending\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Pending")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Verified\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Verified")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Active\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Active")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "WaitListed\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "WaitListed")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "UserStatus\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__UserStatus_229() {
    napi::bindgen_prelude::register_module_export(
        None,
        "UserStatus\0",
        __register__enum__UserStatus_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__UserStatus_229___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__UserStatus_229___rust_ctor___ctor() -> usize {
        __napi_register__UserStatus_229();
        0
    }
    __napi_register__UserStatus_229___rust_ctor___ctor
};
pub enum CommunicationMethod {
    Text,
    Mail,
    InPerson,
    PushNotification,
    SocialMedia,
    Email,
    Phone,
    Sms,
    VideoCall,
    InstantMessage,
    Other,
}
#[automatically_derived]
impl ::core::marker::Copy for CommunicationMethod {}
#[automatically_derived]
impl ::core::clone::Clone for CommunicationMethod {
    #[inline]
    fn clone(&self) -> CommunicationMethod {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for CommunicationMethod {
    fn type_name() -> &'static str {
        "CommunicationMethod"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for CommunicationMethod {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for CommunicationMethod {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "CommunicationMethod",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Text" => Ok(CommunicationMethod::Text),
            "Mail" => Ok(CommunicationMethod::Mail),
            "InPerson" => Ok(CommunicationMethod::InPerson),
            "PushNotification" => Ok(CommunicationMethod::PushNotification),
            "SocialMedia" => Ok(CommunicationMethod::SocialMedia),
            "Email" => Ok(CommunicationMethod::Email),
            "Phone" => Ok(CommunicationMethod::Phone),
            "Sms" => Ok(CommunicationMethod::Sms),
            "VideoCall" => Ok(CommunicationMethod::VideoCall),
            "InstantMessage" => Ok(CommunicationMethod::InstantMessage),
            "Other" => Ok(CommunicationMethod::Other),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "CommunicationMethod",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for CommunicationMethod {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            CommunicationMethod::Text => "Text",
            CommunicationMethod::Mail => "Mail",
            CommunicationMethod::InPerson => "InPerson",
            CommunicationMethod::PushNotification => "PushNotification",
            CommunicationMethod::SocialMedia => "SocialMedia",
            CommunicationMethod::Email => "Email",
            CommunicationMethod::Phone => "Phone",
            CommunicationMethod::Sms => "Sms",
            CommunicationMethod::VideoCall => "VideoCall",
            CommunicationMethod::InstantMessage => "InstantMessage",
            CommunicationMethod::Other => "Other",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__CommunicationMethod_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Text\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Text")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Mail\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Mail")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InPerson\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InPerson")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "PushNotification\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(
                    env,
                    "PushNotification",
                )?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "SocialMedia\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "SocialMedia")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Email\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Email")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Phone\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Phone")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sms\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sms")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "VideoCall\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "VideoCall")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "InstantMessage\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "InstantMessage")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "CommunicationMethod\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__CommunicationMethod_230() {
    napi::bindgen_prelude::register_module_export(
        None,
        "CommunicationMethod\0",
        __register__enum__CommunicationMethod_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__CommunicationMethod_230___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__CommunicationMethod_230___rust_ctor___ctor() -> usize {
        __napi_register__CommunicationMethod_230();
        0
    }
    __napi_register__CommunicationMethod_230___rust_ctor___ctor
};
pub enum PromotionType {
    FreeShipping,
    BuyOneGetOne,
    Percentage,
    FixedAmount,
    Other,
    RewardPoints,
}
#[automatically_derived]
impl ::core::marker::Copy for PromotionType {}
#[automatically_derived]
impl ::core::clone::Clone for PromotionType {
    #[inline]
    fn clone(&self) -> PromotionType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for PromotionType {
    fn type_name() -> &'static str {
        "PromotionType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for PromotionType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for PromotionType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "PromotionType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "FreeShipping" => Ok(PromotionType::FreeShipping),
            "BuyOneGetOne" => Ok(PromotionType::BuyOneGetOne),
            "Percentage" => Ok(PromotionType::Percentage),
            "FixedAmount" => Ok(PromotionType::FixedAmount),
            "Other" => Ok(PromotionType::Other),
            "RewardPoints" => Ok(PromotionType::RewardPoints),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "PromotionType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for PromotionType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            PromotionType::FreeShipping => "FreeShipping",
            PromotionType::BuyOneGetOne => "BuyOneGetOne",
            PromotionType::Percentage => "Percentage",
            PromotionType::FixedAmount => "FixedAmount",
            PromotionType::Other => "Other",
            PromotionType::RewardPoints => "RewardPoints",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__PromotionType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "FreeShipping\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FreeShipping")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PromotionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "BuyOneGetOne\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "BuyOneGetOne")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PromotionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Percentage\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Percentage")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PromotionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "FixedAmount\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "FixedAmount")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PromotionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PromotionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "RewardPoints\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "RewardPoints")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "PromotionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__PromotionType_231() {
    napi::bindgen_prelude::register_module_export(
        None,
        "PromotionType\0",
        __register__enum__PromotionType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__PromotionType_231___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__PromotionType_231___rust_ctor___ctor() -> usize {
        __napi_register__PromotionType_231();
        0
    }
    __napi_register__PromotionType_231___rust_ctor___ctor
};
pub enum FinancialTransactionType {
    Withdrawal,
    Transfer,
    Fee,
    Refund,
    Adjustment,
    Dividend,
    Payment,
    Charge,
    Chargeback,
    Other,
    Deposit,
    Sale,
    Interest,
}
#[automatically_derived]
impl ::core::marker::Copy for FinancialTransactionType {}
#[automatically_derived]
impl ::core::clone::Clone for FinancialTransactionType {
    #[inline]
    fn clone(&self) -> FinancialTransactionType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for FinancialTransactionType {
    fn type_name() -> &'static str {
        "FinancialTransactionType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for FinancialTransactionType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for FinancialTransactionType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "FinancialTransactionType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "Withdrawal" => Ok(FinancialTransactionType::Withdrawal),
            "Transfer" => Ok(FinancialTransactionType::Transfer),
            "Fee" => Ok(FinancialTransactionType::Fee),
            "Refund" => Ok(FinancialTransactionType::Refund),
            "Adjustment" => Ok(FinancialTransactionType::Adjustment),
            "Dividend" => Ok(FinancialTransactionType::Dividend),
            "Payment" => Ok(FinancialTransactionType::Payment),
            "Charge" => Ok(FinancialTransactionType::Charge),
            "Chargeback" => Ok(FinancialTransactionType::Chargeback),
            "Other" => Ok(FinancialTransactionType::Other),
            "Deposit" => Ok(FinancialTransactionType::Deposit),
            "Sale" => Ok(FinancialTransactionType::Sale),
            "Interest" => Ok(FinancialTransactionType::Interest),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "FinancialTransactionType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for FinancialTransactionType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            FinancialTransactionType::Withdrawal => "Withdrawal",
            FinancialTransactionType::Transfer => "Transfer",
            FinancialTransactionType::Fee => "Fee",
            FinancialTransactionType::Refund => "Refund",
            FinancialTransactionType::Adjustment => "Adjustment",
            FinancialTransactionType::Dividend => "Dividend",
            FinancialTransactionType::Payment => "Payment",
            FinancialTransactionType::Charge => "Charge",
            FinancialTransactionType::Chargeback => "Chargeback",
            FinancialTransactionType::Other => "Other",
            FinancialTransactionType::Deposit => "Deposit",
            FinancialTransactionType::Sale => "Sale",
            FinancialTransactionType::Interest => "Interest",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__FinancialTransactionType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Withdrawal\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Withdrawal")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Transfer\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Transfer")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Fee\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Fee")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Refund\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Refund")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Adjustment\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Adjustment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Dividend\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Dividend")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Payment\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Payment")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Charge\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Charge")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Chargeback\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Chargeback")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Other\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Other")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Deposit\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Deposit")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked("Sale\0".as_bytes());
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Sale")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "Interest\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "Interest")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Failed to defined enum `{0}`",
                                        "FinancialTransactionType\0",
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__FinancialTransactionType_232() {
    napi::bindgen_prelude::register_module_export(
        None,
        "FinancialTransactionType\0",
        __register__enum__FinancialTransactionType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__FinancialTransactionType_232___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__FinancialTransactionType_232___rust_ctor___ctor() -> usize {
        __napi_register__FinancialTransactionType_232();
        0
    }
    __napi_register__FinancialTransactionType_232___rust_ctor___ctor
};
pub enum MimeType {
    ImageWebp,
    ImageJpeg,
    ImageGif,
    ImageSvgXml,
    ImagePng,
}
#[automatically_derived]
impl ::core::marker::Copy for MimeType {}
#[automatically_derived]
impl ::core::clone::Clone for MimeType {
    #[inline]
    fn clone(&self) -> MimeType {
        *self
    }
}
impl napi::bindgen_prelude::TypeName for MimeType {
    fn type_name() -> &'static str {
        "MimeType"
    }
    fn value_type() -> napi::ValueType {
        napi::ValueType::Object
    }
}
impl napi::bindgen_prelude::ValidateNapiValue for MimeType {
    unsafe fn validate(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<napi::sys::napi_value> {
        {
            let mut value_type = 0;
            #[allow(unused_unsafe)]
            {
                let c = unsafe {
                    ::napi::sys::napi_typeof(env, napi_val, &mut value_type)
                };
                match c {
                    ::napi::sys::Status::napi_ok => Ok(()),
                    _ => Err(::napi::Error::new(::napi::Status::from(c), "".to_owned())),
                }
            }
                .and_then(|_| Ok(::napi::ValueType::from(value_type)))
        }
            .and_then(|received_type| {
                if received_type == napi::bindgen_prelude::ValueType::Number {
                    Ok(())
                } else {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::InvalidArg,
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Expect value to be {0}, but received {1}",
                                        napi::bindgen_prelude::ValueType::Number,
                                        received_type,
                                    ),
                                );
                                res
                            },
                        ),
                    )
                }
            })?;
        Ok(std::ptr::null_mut())
    }
}
impl napi::bindgen_prelude::FromNapiValue for MimeType {
    unsafe fn from_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        napi_val: napi::bindgen_prelude::sys::napi_value,
    ) -> napi::bindgen_prelude::Result<Self> {
        let val = napi::bindgen_prelude::FromNapiValue::from_napi_value(env, napi_val)
            .map_err(|e| {
                ::napi::Error::new(
                    e.status,
                    {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Failed to convert napi value into enum `{0}`. {1}",
                                "MimeType",
                                e,
                            ),
                        );
                        res
                    },
                )
            })?;
        match val {
            "ImageWebp" => Ok(MimeType::ImageWebp),
            "ImageJpeg" => Ok(MimeType::ImageJpeg),
            "ImageGif" => Ok(MimeType::ImageGif),
            "ImageSvgXml" => Ok(MimeType::ImageSvgXml),
            "ImagePng" => Ok(MimeType::ImagePng),
            _ => {
                Err(
                    ::napi::Error::new(
                        napi::bindgen_prelude::Status::InvalidArg,
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "value `{0:?}` does not match any variant of enum `{1}`",
                                    val,
                                    "MimeType",
                                ),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }
}
impl napi::bindgen_prelude::ToNapiValue for MimeType {
    unsafe fn to_napi_value(
        env: napi::bindgen_prelude::sys::napi_env,
        val: Self,
    ) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
        let val = match val {
            MimeType::ImageWebp => "ImageWebp",
            MimeType::ImageJpeg => "ImageJpeg",
            MimeType::ImageGif => "ImageGif",
            MimeType::ImageSvgXml => "ImageSvgXml",
            MimeType::ImagePng => "ImagePng",
        };
        napi::bindgen_prelude::ToNapiValue::to_napi_value(env, val)
    }
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
unsafe fn __register__enum__MimeType_callback__(
    env: napi::bindgen_prelude::sys::napi_env,
) -> napi::bindgen_prelude::Result<napi::bindgen_prelude::sys::napi_value> {
    use std::ffi::CString;
    use std::ptr;
    let mut obj_ptr = ptr::null_mut();
    {
        let c = napi::bindgen_prelude::sys::napi_create_object(env, &mut obj_ptr);
        match c {
            ::napi::sys::Status::napi_ok => Ok(()),
            _ => {
                Err(
                    ::napi::Error::new(
                        ::napi::Status::from(c),
                        {
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create napi object"),
                            );
                            res
                        },
                    ),
                )
            }
        }
    }?;
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageWebp\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageWebp")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "MimeType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageJpeg\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageJpeg")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "MimeType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageGif\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageGif")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "MimeType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImageSvgXml\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImageSvgXml")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "MimeType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    {
        let name = std::ffi::CStr::from_bytes_with_nul_unchecked(
            "ImagePng\0".as_bytes(),
        );
        {
            let c = napi::bindgen_prelude::sys::napi_set_named_property(
                env,
                obj_ptr,
                name.as_ptr(),
                napi::bindgen_prelude::ToNapiValue::to_napi_value(env, "ImagePng")?,
            );
            match c {
                ::napi::sys::Status::napi_ok => Ok(()),
                _ => {
                    Err(
                        ::napi::Error::new(
                            ::napi::Status::from(c),
                            {
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to defined enum `{0}`", "MimeType\0"),
                                );
                                res
                            },
                        ),
                    )
                }
            }
        }?;
    };
    Ok(obj_ptr)
}
#[allow(non_snake_case)]
#[allow(clippy::all)]
#[cfg(all(not(test), not(feature = "noop"), not(target_family = "wasm")))]
extern fn __napi_register__MimeType_233() {
    napi::bindgen_prelude::register_module_export(
        None,
        "MimeType\0",
        __register__enum__MimeType_callback__,
    );
}
#[used]
#[allow(non_upper_case_globals, non_snake_case)]
#[doc(hidden)]
#[link_section = ".init_array"]
static __napi_register__MimeType_233___rust_ctor___ctor: unsafe extern "C" fn() -> usize = {
    #[allow(non_snake_case)]
    #[link_section = ".text.startup"]
    unsafe extern "C" fn __napi_register__MimeType_233___rust_ctor___ctor() -> usize {
        __napi_register__MimeType_233();
        0
    }
    __napi_register__MimeType_233___rust_ctor___ctor
};
